<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Nest Official_03_(Guards, Interceptors, Custom_decorators) - </title><meta name="Description" content="Hello New World"><meta property="og:title" content="Nest Official_03_(Guards, Interceptors, Custom_decorators)" />
<meta property="og:description" content="​
Guards  가드(Guard)는 라우트 핸들러 메서드의 실행 여부를 결정하는 역할을 합니다. 특히, 가드는 특정 조건이 충족되지 않으면 요청을 처리하기 전에 실행을 막습니다. 이는 권한 검사, 인증, 혹은 다양한 비즈니스 규칙을 적용할 때 유용합니다.
간단한 예로, 사용자의 권한을 확인하는 가드를 상상해볼 수 있습니다. 특정 엔드포인트에 접근하려는 사용자의 역할이나 권한이 충족되지 않으면 가드가 요청을 차단할 수 있습니다. 이를 통해 요청이 핸들러 메서드에 도달하기 전에 필요한 조건을 검사하고 처리할 수 있습니다.
 가드는 @Injectable() 데코레이터로 주석이 달린 클래스로, CanActivate 인터페이스를 구현합니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/" /><meta property="og:image" content="https://colinder.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-14T09:14:13+09:00" />
<meta property="article:modified_time" content="2024-01-14T09:14:13+09:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://colinder.github.io/logo.png"/>

<meta name="twitter:title" content="Nest Official_03_(Guards, Interceptors, Custom_decorators)"/>
<meta name="twitter:description" content="​
Guards  가드(Guard)는 라우트 핸들러 메서드의 실행 여부를 결정하는 역할을 합니다. 특히, 가드는 특정 조건이 충족되지 않으면 요청을 처리하기 전에 실행을 막습니다. 이는 권한 검사, 인증, 혹은 다양한 비즈니스 규칙을 적용할 때 유용합니다.
간단한 예로, 사용자의 권한을 확인하는 가드를 상상해볼 수 있습니다. 특정 엔드포인트에 접근하려는 사용자의 역할이나 권한이 충족되지 않으면 가드가 요청을 차단할 수 있습니다. 이를 통해 요청이 핸들러 메서드에 도달하기 전에 필요한 조건을 검사하고 처리할 수 있습니다.
 가드는 @Injectable() 데코레이터로 주석이 달린 클래스로, CanActivate 인터페이스를 구현합니다."/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/" /><link rel="prev" href="https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/" /><link rel="next" href="https://colinder.github.io/decorator/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><meta name="google-site-verification" content="colinder" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Nest Official_03_(Guards, Interceptors, Custom_decorators)",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/colinder.github.io\/nest-official_03_guards-interceptors-custom_decorators\/"
        },"genre": "posts","keywords": "Nest","wordcount":  3702 ,
        "url": "https:\/\/colinder.github.io\/nest-official_03_guards-interceptors-custom_decorators\/","datePublished": "2024-01-14T09:14:13+09:00","dateModified": "2024-01-14T09:14:13+09:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "colinder"
            },"description": ""
    }
    </script></head>
    <body header-desktop="auto" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="">Hello New World</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/categories/" title="대분류"> Categories </a><a class="menu-item" href="/posts/" title="게시글"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="검색할 내용을 입력해주세요" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="">Hello New World</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="검색할 내용을 입력해주세요" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/categories/" title="대분류">Categories</a><a class="menu-item" href="/posts/" title="게시글">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Nest Official_03_(Guards, Interceptors, Custom_decorators)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>colinder</a></span>&nbsp;<span class="post-category">included in <a href="/categories/nest/"><i class="far fa-folder fa-fw"></i>Nest</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2024-01-14">2024-01-14</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;3702 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;18 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#guards">Guards</a>
      <ul>
        <li><a href="#authorization-guardhttpsdocsnestjscomguardsauthorization-guard">Authorization guard<a href="https://docs.nestjs.com/guards#authorization-guard">#</a></a></li>
        <li><a href="#execution-contexthttpsdocsnestjscomguardsexecution-context">Execution context<a href="https://docs.nestjs.com/guards#execution-context">#</a></a></li>
        <li><a href="#role-based-authenticationhttpsdocsnestjscomguardsrole-based-authentication">Role-based authentication<a href="https://docs.nestjs.com/guards#role-based-authentication">#</a></a></li>
        <li><a href="#binding-guardshttpsdocsnestjscomguardsbinding-guards">Binding guards<a href="https://docs.nestjs.com/guards#binding-guards">#</a></a></li>
        <li><a href="#setting-roles-per-handlerhttpsdocsnestjscomguardssetting-roles-per-handler">Setting roles per handler<a href="https://docs.nestjs.com/guards#setting-roles-per-handler">#</a></a></li>
        <li><a href="#putting-it-all-togetherhttpsdocsnestjscomguardsputting-it-all-together">Putting it all together<a href="https://docs.nestjs.com/guards#putting-it-all-together">#</a></a></li>
      </ul>
    </li>
    <li><a href="#interceptors">Interceptors</a>
      <ul>
        <li><a href="#basicshttpsdocsnestjscominterceptorsbasics">Basics<a href="https://docs.nestjs.com/interceptors#basics">#</a></a></li>
        <li><a href="#execution-contexthttpsdocsnestjscominterceptorsexecution-context">Execution context<a href="https://docs.nestjs.com/interceptors#execution-context">#</a></a></li>
        <li><a href="#call-handlerhttpsdocsnestjscominterceptorscall-handler">Call handler<a href="https://docs.nestjs.com/interceptors#call-handler">#</a></a></li>
        <li><a href="#aspect-interceptionhttpsdocsnestjscominterceptorsaspect-interception">Aspect interception<a href="https://docs.nestjs.com/interceptors#aspect-interception">#</a></a></li>
        <li><a href="#binding-interceptorshttpsdocsnestjscominterceptorsbinding-interceptors">Binding interceptors<a href="https://docs.nestjs.com/interceptors#binding-interceptors">#</a></a></li>
        <li><a href="#response-mappinghttpsdocsnestjscominterceptorsresponse-mapping">Response mapping<a href="https://docs.nestjs.com/interceptors#response-mapping">#</a></a></li>
        <li><a href="#exception-mappinghttpsdocsnestjscominterceptorsexception-mapping">Exception mapping<a href="https://docs.nestjs.com/interceptors#exception-mapping">#</a></a></li>
        <li><a href="#stream-overridinghttpsdocsnestjscominterceptorsstream-overriding">Stream overriding<a href="https://docs.nestjs.com/interceptors#stream-overriding">#</a></a></li>
        <li><a href="#more-operatorshttpsdocsnestjscominterceptorsmore-operators">More operators<a href="https://docs.nestjs.com/interceptors#more-operators">#</a></a></li>
      </ul>
    </li>
    <li><a href="#custom-route-decorators">Custom route decorators</a>
      <ul>
        <li><a href="#param-decoratorshttpsdocsnestjscomcustom-decoratorsparam-decorators">Param decorators<a href="https://docs.nestjs.com/custom-decorators#param-decorators">#</a></a></li>
        <li><a href="#passing-datahttpsdocsnestjscomcustom-decoratorspassing-data">Passing data<a href="https://docs.nestjs.com/custom-decorators#passing-data">#</a></a></li>
        <li><a href="#working-with-pipeshttpsdocsnestjscomcustom-decoratorsworking-with-pipes">Working with pipes<a href="https://docs.nestjs.com/custom-decorators#working-with-pipes">#</a></a></li>
        <li><a href="#decorator-compositionhttpsdocsnestjscomcustom-decoratorsdecorator-composition">Decorator composition<a href="https://docs.nestjs.com/custom-decorators#decorator-composition">#</a></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>​</p>
<h2 id="guards">Guards</h2>
<blockquote>
<p>가드(Guard)는 라우트 핸들러 메서드의 실행 여부를 결정하는 역할을 합니다. 특히, 가드는 특정 조건이 충족되지 않으면 요청을 처리하기 전에 실행을 막습니다. 이는 권한 검사, 인증, 혹은 다양한 비즈니스 규칙을 적용할 때 유용합니다.</p>
<p>간단한 예로, 사용자의 권한을 확인하는 가드를 상상해볼 수 있습니다. 특정 엔드포인트에 접근하려는 사용자의 역할이나 권한이 충족되지 않으면 가드가 요청을 차단할 수 있습니다. 이를 통해 요청이 핸들러 메서드에 도달하기 전에 필요한 조건을 검사하고 처리할 수 있습니다.</p>
</blockquote>
<p>가드는 <code>@Injectable()</code> 데코레이터로 주석이 달린 클래스로, <code>CanActivate</code> 인터페이스를 구현합니다.</p>
<p>가드(Guards)는 <strong>단일 책임</strong>을 가지고 있습니다. <u>특정 조건(권한, 역할, ACL(access control list; 접근 제어 목록) 등)이 실행 시점에 존재하는지 여부에 따라 주어진 요청이 라우트 핸들러에 의해 처리될지 여부를 결정합니다.</u> 이는 일반적으로 <b>인가(authorization)</b>로 언급되며 종종 <b>인증(authentication)</b>과 함께 작동합니다. 전통적인 Express 애플리케이션에서는 <a href="https://docs.nestjs.com/middleware" target="_blank" rel="noopener noreffer">middleware</a>를 통해 일반적으로 이러한 작업이 처리되었습니다. 미들웨어는 토큰 유효성 검사 및 <code>request</code> 객체에 속성을 추가하는 것과 같은 작업이 특정 라우트 컨텍스트(및 해당 메타데이터)와 강하게 연결되어 있지 않기 때문에 인증에 대한 좋은 선택입니다.</p>
<p>그러나 미들웨어는 본질적으로 무지합니다. <code>next()</code> 함수를 호출한 후에 어떤 핸들러가 실행될지를 알지 못합니다. 반면에 <strong>가드</strong>는 <code>ExecutionContext</code> 인스턴스에 액세스할 수 있으며 따라서 정확히 다음에 실행될 것을 알고 있습니다. 이들은 예외 필터, 파이프, 인터셉터와 마찬가지로 요청/응답 주기에서 처리 로직을 정확한 지점에 삽입하고 선언적으로 수행할 수 있도록 설계되었습니다. 이는 코드를 DRY(Don&rsquo;t Repeat Yourself)하고 선언적으로 유지하는 데 도움이 됩니다.</p>
<blockquote>
<p><strong>HINT</strong></p>
<p>Guards are executed <strong>after</strong> all middleware, but <strong>before</strong> any interceptor or pipe.</p>
</blockquote>
<p>​</p>
<h3 id="authorization-guardhttpsdocsnestjscomguardsauthorization-guard">Authorization guard<a href="https://docs.nestjs.com/guards#authorization-guard" target="_blank" rel="noopener noreffer">#</a></h3>
<p>언급한 대로 <strong>권한</strong> 부여는 가드의 좋은 사용 사례입니다. 특정 라우트는 호출자(일반적으로 특정 인증된 사용자)가 충분한 권한을 가질 때만 사용 가능해야 합니다. 이제 구축할 <code>AuthGuard</code>는 인증된 사용자를 가정하고 (따라서 토큰이 요청 헤더에 첨부되어 있다고 가정합니다) 토큰을 추출하고 유효성을 검사한 다음 추출된 정보를 사용하여 요청이 계속 진행할 수 있는지 여부를 결정합니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//auth.guard.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">CanActivate</span><span class="p">,</span> <span class="nx">ExecutionContext</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AuthGuard</span> <span class="kr">implements</span> <span class="nx">CanActivate</span> <span class="p">{</span>
  <span class="nx">canActivate</span><span class="p">(</span>
    <span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span>
  <span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="o">|</span> <span class="nx">Promise</span><span class="p">&lt;</span><span class="nt">boolean</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">boolean</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">().</span><span class="nx">getRequest</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">validateRequest</span><span class="p">(</span><span class="nx">request</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>만약 애플리케이션에 인증 메커니즘을 구현하는 실제 예제를 찾고 있다면, <a href="https://docs.nestjs.com/security/authentication" target="_blank" rel="noopener noreffer">이 장</a>을 참조하세요. 마찬가지로 더 정교한(sophisticated ) 권한 부여 예제를 원한다면 <a href="https://docs.nestjs.com/security/authorization" target="_blank" rel="noopener noreffer">이 페이지</a>를 확인하세요.</p>
</blockquote>
<p><code>validateRequest()</code> 함수 내부의 로직은 필요에 따라 간단하거나 복잡할 수 있습니다. 이 예제의 주요 포인트는 가드가 요청/응답 주기에 어떻게 맞아 떨어지는지를 보여주는 것입니다.</p>
<p>모든 가드는 <code>canActivate()</code> 함수를 구현해야 합니다. 이 함수는 현재 요청이 허용되는지 여부를 나타내는 boolean 값을 반환해야 합니다. 이 함수는 동기적으로 또는 비동기적으로 (Promise나 Observable을 통해) 응답을 반환할 수 있습니다. Nest는 반환된 값을 사용하여 다음 동작을 제어합니다:</p>
<ul>
<li>true를 반환하면 요청이 처리됩니다.</li>
<li>false를 반환하면 Nest는 요청을 거부합니다.</li>
</ul>
<p>​</p>
<h3 id="execution-contexthttpsdocsnestjscomguardsexecution-context">Execution context<a href="https://docs.nestjs.com/guards#execution-context" target="_blank" rel="noopener noreffer">#</a></h3>
<p><code>canActivate()</code> 함수는 단일 인수인 <code>ExecutionContext</code> 인스턴스를 받습니다. <code>ExecutionContext</code>는 <code>ArgumentsHost</code>에서 상속됩니다. 이전에 예외 필터 챕터에서 <code>ArgumentsHost</code>를 보았습니다. 위의 예제에서는 이전에 사용한 것과 동일한 <code>ArgumentsHost</code>에서 정의된 도우미 메서드를 사용하여 <code>Request</code> 객체에 대한 참조를 가져 오고 있습니다. 이 주제에 대한 자세한 내용은 <a href="https://docs.nestjs.com/exception-filters#arguments-host" target="_blank" rel="noopener noreffer">exception filters</a> 챕터의 <strong>Arguments host</strong> 섹션을 참조할 수 있습니다.</p>
<p><code>ExecutionContext</code>는 <code>ArgumentsHost</code>를 확장함으로써 현재 실행 프로세스에 대한 추가적인 세부 정보를 제공하는 여러 개의 새로운 도우미 메서드를 추가합니다. 이러한 세부 정보는 더 일반적인 가드를 작성할 때 도움이 될 수 있으며 이 가드는 다양한 컨트롤러, 메서드 및 실행 컨텍스트 집합에서 작동할 수 있습니다. <code>ExecutionContext</code>에 대한 자세한 내용은 <a href="https://docs.nestjs.com/fundamentals/execution-context" target="_blank" rel="noopener noreffer">여기</a>에서 확인할 수 있습니다.</p>
<p>​</p>
<h3 id="role-based-authenticationhttpsdocsnestjscomguardsrole-based-authentication">Role-based authentication<a href="https://docs.nestjs.com/guards#role-based-authentication" target="_blank" rel="noopener noreffer">#</a></h3>
<p>특정 역할을 가진 사용자만 액세스를 허용하는 더 기능적인 가드를 만들어보겠습니다. 기본 가드 템플릿에서 시작하고 이후 섹션에서 이를 확장해 나갈 것입니다. 현재는 모든 요청을 허용하는 기본적인 구조입니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//roles.guard.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">CanActivate</span><span class="p">,</span> <span class="nx">ExecutionContext</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">RolesGuard</span> <span class="kr">implements</span> <span class="nx">CanActivate</span> <span class="p">{</span>
  <span class="nx">canActivate</span><span class="p">(</span>
    <span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span>
  <span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="o">|</span> <span class="nx">Promise</span><span class="p">&lt;</span><span class="nt">boolean</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">boolean</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="binding-guardshttpsdocsnestjscomguardsbinding-guards">Binding guards<a href="https://docs.nestjs.com/guards#binding-guards" target="_blank" rel="noopener noreffer">#</a></h3>
<p>파이프와 예외 필터와 마찬가지로 가드는 <strong>컨트롤러 범위(controller-scoped)</strong>, 메서드 범위, 또는 전역 범위로 설정할 수 있습니다. 아래에서는 <code>@UseGuards()</code> 데코레이터를 사용하여 컨트롤러 범위의 가드를 설정합니다. 이 데코레이터는 단일 인수나 쉼표로 구분된 인수 목록을 받을 수 있습니다. 이를 통해 하나의 선언으로 적절한 가드 집합을 쉽게 적용할 수 있습니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kd">@UseGuards</span><span class="p">(</span><span class="nx">RolesGuard</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>The <code>@UseGuards()</code> decorator is imported from the <code>@nestjs/common</code> package.</p>
</blockquote>
<p>위에서는 인스턴스 대신 <code>RolesGuard</code> 클래스를 전달하여 인스턴스화 책임을 프레임워크에게 맡기고 의존성 주입을 활성화했습니다. 파이프와 예외 필터와 마찬가지로 인스턴스를 직접 전달할 수도 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Controller</span><span class="p">(</span><span class="s1">&#39;cats&#39;</span><span class="p">)</span>
<span class="kd">@UseGuards</span><span class="p">(</span><span class="k">new</span> <span class="nx">RolesGuard</span><span class="p">())</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>위의 구성은 이 컨트롤러에서 선언된 모든 핸들러에 가드를 연결합니다. 가드를 하나의 메서드에만 적용하려면 <code>@UseGuards()</code> 데코레이터를 <strong>메서드 레벨</strong>에서 적용합니다.</p>
<p>전역 가드를 설정하려면 Nest 애플리케이션 인스턴스의 <code>useGlobalGuards()</code> 메서드를 사용하세요:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//main.ts
</span><span class="c1"></span>
<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">useGlobalGuards</span><span class="p">(</span><span class="k">new</span> <span class="nx">RolesGuard</span><span class="p">());</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>NOTICE</strong></p>
<p>하이브리드 앱의 경우 <code>useGlobalGuards()</code> 메서드는 기본적으로 게이트웨이 및 마이크로 서비스에 가드를 설정하지 않습니다. (이 동작을 변경하는 방법에 대한 정보는 <a href="https://docs.nestjs.com/faq/hybrid-application" target="_blank" rel="noopener noreffer">Hybrid application</a>을 참조하세요.) &ldquo;표준&rdquo; (비-하이브리드) 마이크로서비스 앱의 경우 <code>useGlobalGuards()</code>는 가드를 전역으로 마운트합니다.</p>
</blockquote>
<p>전역 가드는 전체 애플리케이션, 모든 컨트롤러 및 모든 라우트 핸들러에 걸쳐 사용됩니다. 의존성 주입 측면에서 모듈 외부에서 등록된 전역 가드 (<code>useGlobalGuards()</code>를 사용한 예제와 같이)는 어떤 모듈의 컨텍스트 외부에서 수행되므로 종속성을 주입할 수 없습니다. 이 문제를 해결하려면 다음 구성을 사용하여 모듈에서 직접 가드를 설정할 수 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//app.module.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Module</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">APP_GUARD</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>

<span class="kd">@Module</span><span class="p">({</span>
  <span class="nx">providers</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">provide</span>: <span class="kt">APP_GUARD</span><span class="p">,</span>
      <span class="nx">useClass</span>: <span class="kt">RolesGuard</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">],</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AppModule</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>이 방법을 사용하여 가드에 대한 종속성 주입을 수행할 때 어떤 모듈에서 이 구성을 사용하든지 간에 이 가드는 사실상 전역입니다. 어디에서 이 작업을 수행해야 할까요? 가드 (<code>RolesGuard</code>는 위의 예제에서와 같이)가 정의된 모듈을 선택하세요. 또한, <code>useClass</code>는 사용자 정의 공급자 등록을 다루는 유일한 방법이 아닙니다. <a href="https://docs.nestjs.com/fundamentals/custom-providers" target="_blank" rel="noopener noreffer">여기</a>에서 자세히 알아보세요.</p>
</blockquote>
<p>​</p>
<h3 id="setting-roles-per-handlerhttpsdocsnestjscomguardssetting-roles-per-handler">Setting roles per handler<a href="https://docs.nestjs.com/guards#setting-roles-per-handler" target="_blank" rel="noopener noreffer">#</a></h3>
<p><code>RolesGuard</code>가 작동하지만 아직 충분히 스마트하지 않습니다. 가장 중요한 가드 기능 중 하나인 <a href="https://docs.nestjs.com/fundamentals/execution-context" target="_blank" rel="noopener noreffer">실행 컨텍스트</a>를 아직 활용하고 있지 않습니다. 아직 역할이나 각 핸들러에 대한 허용된 역할에 대한 정보를 알지 못합니다. 예를 들어 <code>CatsController</code>는 다른 라우트에 대해 다른 권한 체계를 가질 수 있습니다. 어떤 라우트는 관리자 사용자만 사용할 수 있고 다른 라우트는 모두에게 열려 있을 수 있습니다. 어떻게 역할을 유연하고 재사용 가능한 방식으로 라우트에 매핑할 수 있을까요?</p>
<p>여기서 <strong>사용자 정의 메타데이터</strong>가 등장합니다 (<a href="https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata" target="_blank" rel="noopener noreffer">여기</a>에서 더 알아보세요). Nest는 <code>Reflector#createDecorator</code> 정적 메서드를 통해 생성된 데코레이터 또는 내장된 <code>@SetMetadata()</code> 데코레이터를 통해 라우트 핸들러에 사용자 정의 <strong>메타데이터</strong>를 첨부할 수 있는 기능을 제공합니다.</p>
<p>예를 들어 <code>Reflector#createDecorator</code> 메서드를 사용하여 핸들러에 메타데이터를 첨부할 <code>@Roles()</code> 데코레이터를 만들어봅시다. <code>Reflector</code>는 프레임워크에서 기본적으로 제공되며 <code>@nestjs/core</code> 패키지에서 노출됩니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//roles.decorator.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Reflector</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">Roles</span> <span class="o">=</span> <span class="nx">Reflector</span><span class="p">.</span><span class="nx">createDecorator</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;();</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>Roles</code> decorator here is a function that takes a single argument of type <code>string[]</code>.</p>
<p>Now, to use this decorator, we simply annotate the handler with it:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@Post</span><span class="p">()</span>
<span class="kd">@Roles</span><span class="p">([</span><span class="s1">&#39;admin&#39;</span><span class="p">])</span>
<span class="kr">async</span> <span class="nx">create</span><span class="p">(</span><span class="kd">@Body</span><span class="p">()</span> <span class="nx">createCatDto</span>: <span class="kt">CreateCatDto</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">catsService</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">createCatDto</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>여기서는 <code>create()</code> 메서드에 <code>Roles</code> 데코레이터 메타데이터를 첨부했습니다. 이는 해당 라우트에는 <code>admin</code> 역할을 가진 사용자만 액세스할 수 있어야 함을 나타냅니다.</p>
<p>대신에 <code>Reflector#createDecorator</code> 메서드 대신 내장된 <code>@SetMetadata()</code> 데코레이터를 사용할 수도 있습니다. <a href="https://docs.nestjs.com/fundamentals/execution-context#low-level-approach" target="_blank" rel="noopener noreffer">여기</a>에서 더 자세히 알아보세요.</p>
<p>​</p>
<h3 id="putting-it-all-togetherhttpsdocsnestjscomguardsputting-it-all-together">Putting it all together<a href="https://docs.nestjs.com/guards#putting-it-all-together" target="_blank" rel="noopener noreffer">#</a></h3>
<p>이제 <code>RolesGuard</code>와 함께 이를 연결해 보겠습니다. 현재 <code>RolesGuard</code>는 모든 경우에 <code>true</code>를 반환하여 모든 요청을 진행시킵니다. 우리는 현재 사용자에게 할당된 <strong>역할을 현재 처리 중인 라우트에서 필요로 하는 실제 역할과 비교하여</strong> 반환 값을 조건부로 만들고 싶습니다. 라우트의 역할(사용자 정의 메타데이터)에 액세스하려면 다시 <code>Reflector</code> 도우미 클래스를 사용하겠습니다. 아래와 같이:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//roles.guard.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">CanActivate</span><span class="p">,</span> <span class="nx">ExecutionContext</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Reflector</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Roles</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;./roles.decorator&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">RolesGuard</span> <span class="kr">implements</span> <span class="nx">CanActivate</span> <span class="p">{</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">reflector</span>: <span class="kt">Reflector</span><span class="p">)</span> <span class="p">{}</span>

  <span class="nx">canActivate</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">roles</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">reflector</span><span class="p">.</span><span class="kr">get</span><span class="p">(</span><span class="nx">Roles</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">getHandler</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">roles</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">().</span><span class="nx">getRequest</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">matchRoles</span><span class="p">(</span><span class="nx">roles</span><span class="p">,</span> <span class="nx">user</span><span class="p">.</span><span class="nx">roles</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>Node.js 세계에서는 흔히 권한이 부여된 사용자를 <code>request</code> 객체에 첨부하는 것이 일반적입니다. 따라서 위의 샘플 코드에서는 <code>request.user</code>가 사용자 인스턴스와 허용된 역할을 포함하고 있다고 가정하고 있습니다. 여러분의 앱에서는 이러한 연관성을 사용자 정의 <strong>인증 가드</strong>나 미들웨어에서 설정할 것으로 예상됩니다. 이 주제에 대한 자세한 정보는 <a href="https://docs.nestjs.com/security/authentication" target="_blank" rel="noopener noreffer">이 장</a>을 참조하세요.</p>
</blockquote>
<div class="details admonition warning open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-exclamation-triangle fa-fw"></i>WARNING<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">matchRoles() 함수 내의 로직은 필요에 따라 간단하거나 복잡하게 구성할 수 있습니다. 이 예제의 주요 목적은 가드가 요청/응답 주기에 어떻게 적합한지를 보여주는 것입니다.</div>
        </div>
    </div>
<p><code>Reflector</code>를 컨텍스트에 맞게 활용하는 방법에 대한 자세한 내용은 <strong>Execution context</strong> 장의 <a href="https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata" target="_blank" rel="noopener noreffer">Reflection and metadata</a> 섹션을 참조하십시오.</p>
<p>권한이 부족한 사용자가 엔드포인트를 요청하면 Nest는 자동으로 다음과 같은 응답을 반환합니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;statusCode&#34;</span><span class="p">:</span> <span class="mi">403</span><span class="p">,</span>
  <span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Forbidden resource&#34;</span><span class="p">,</span>
  <span class="nt">&#34;error&#34;</span><span class="p">:</span> <span class="s2">&#34;Forbidden&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that behind the scenes, 가드가 <code>false</code>를 반환하면 프레임워크가 <code>ForbiddenException</code>을 throw합니다. 다른 오류 응답을 반환하려면 자신만의 특정 예외를 던져야 합니다. 예를 들면:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="k">throw</span> <span class="k">new</span> <span class="nx">UnauthorizedException</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>가드에서 throw된 예외는 <a href="https://docs.nestjs.com/exception-filters" target="_blank" rel="noopener noreffer">예외 레이어</a> 에서 처리됩니다.(전역 예외 필터 및 현재 컨텍스트에 적용된 모든 예외 필터)</p>
<blockquote>
<p><strong>HINT</strong>
If you are looking for a real-world example on how to implement authorization, check <a href="https://docs.nestjs.com/security/authorization" target="_blank" rel="noopener noreffer">this chapter</a>.</p>
</blockquote>
<p>​</p>
<p>​</p>
<h2 id="interceptors">Interceptors</h2>
<blockquote>
<p>인터셉터는 요청과 응답 처리의 중간에 위치하여, 해당 요청 및 응답을 수정하거나 변형할 수 있는 클래스입니다. 인터셉터는 특정 기능을 추상화하고 재사용 가능한 비즈니스 로직을 캡슐화하는 데 사용됩니다.</p>
<p>인터셉터는 주로 다음과 같은 작업을 수행할 수 있습니다:</p>
<ol>
<li><strong>전처리 및 후처리 작업</strong>: 요청이나 응답을 처리하기 전이나 후에 특정 작업을 수행할 수 있습니다. 예를 들어, 데이터 로깅, 트래킹, 또는 요청/응답 수정 등이 가능합니다.</li>
<li><strong>예외 처리</strong>: 요청 또는 응답 중에 예외가 발생하면 인터셉터에서 해당 예외를 처리하고 특정한 형태로 응답을 조작할 수 있습니다.</li>
<li><strong>캐싱</strong>: 일부 요청의 결과를 캐싱하여 성능을 향상시킬 수 있습니다.</li>
<li><strong>트랜스포메이션</strong>: 요청이나 응답을 필요에 따라 변환하거나 가공할 수 있습니다.</li>
<li><strong>권한 검사</strong>: 특정한 권한을 가진 사용자만이 특정한 요청에 접근할 수 있도록 제어할 수 있습니다.</li>
</ol>
<p>인터셉터는 모듈, 컨트롤러, 메서드 수준에서 적용될 수 있으며, 각각의 인터셉터는 특정한 용도에 맞게 설계될 수 있습니다.</p>
</blockquote>
<p>인터셉터는 <code>@Injectable()</code> 데코레이터로 주석이 달린 클래스이며 <code>NestInterceptor</code> 인터페이스를 구현하는 클래스입니다.</p>
<p>인터셉터는 <a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener noreffer">Aspect Oriented Programming</a> (AOP) 기법에서 영감을 받은 유용한 기능을 제공합니다. 이를 통해 다음과 같은 작업이 가능해집니다:</p>
<ul>
<li>메서드 실행 전/후에 추가 로직 바인딩</li>
<li>함수에서 반환된 결과를 변환</li>
<li>함수에서 발생한 예외를 변환</li>
<li>기본 함수 동작 확장</li>
<li>특정 조건에 따라 함수 완전히 재정의 (예: 캐싱 목적)</li>
</ul>
<p>​</p>
<h3 id="basicshttpsdocsnestjscominterceptorsbasics">Basics<a href="https://docs.nestjs.com/interceptors#basics" target="_blank" rel="noopener noreffer">#</a></h3>
<p>각 인터셉터는 두 개의 인자를 받는 <code>intercept()</code> 메소드를 구현합니다. 첫 번째 인자는 <code>ExecutionContext</code> 인스턴스로 <a href="https://docs.nestjs.com/guards" target="_blank" rel="noopener noreffer">가드</a>에서 사용되는 것과 동일한 객체입니다. <code>ExecutionContext</code>는 <code>ArgumentsHost</code>에서 상속됩니다. 우리는 이전에 예외 필터 챕터에서 <code>ArgumentsHost</code>를 보았습니다. 거기에서 원래 핸들러에 전달된 인자를 래핑하고 응용 프로그램의 유형에 따라 다른 인자 배열을 포함한다는 것을 알았습니다. 이 주제에 대한 자세한 내용은 <a href="https://docs.nestjs.com/exception-filters#arguments-host" target="_blank" rel="noopener noreffer">예외 필터</a>를 참조할 수 있습니다.</p>
<p>​</p>
<h3 id="execution-contexthttpsdocsnestjscominterceptorsexecution-context">Execution context<a href="https://docs.nestjs.com/interceptors#execution-context" target="_blank" rel="noopener noreffer">#</a></h3>
<p><code>ExecutionContext</code>는 <code>ArgumentsHost</code>를 확장함으로써 현재 실행 프로세스에 대한 추가적인 세부 정보를 제공하는 여러 개의 헬퍼 메서드를 추가합니다. 이러한 세부 정보는 더 일반적인 인터셉터를 작성할 때 도움이 될 수 있으며, 이 인터셉터는 다양한 컨트롤러, 메서드 및 실행 컨텍스트에서 작동할 수 있습니다. <code>ExecutionContext</code>에 대한 더 자세한 내용은 <a href="https://docs.nestjs.com/fundamentals/execution-context" target="_blank" rel="noopener noreffer">여기</a>에서 확인할 수 있습니다.</p>
<p>​</p>
<h3 id="call-handlerhttpsdocsnestjscominterceptorscall-handler">Call handler<a href="https://docs.nestjs.com/interceptors#call-handler" target="_blank" rel="noopener noreffer">#</a></h3>
<p>두 번째 인수는 <code>CallHandler</code>입니다. <code>CallHandler</code> 인터페이스는 <code>interceptor</code>에서 라우트 핸들러 메서드를 어느 시점에서든 호출할 수 있도록 <code>handle()</code> 메서드를 구현합니다. <code>intercept()</code> 메서드에서 <code>handle()</code> 메서드를 호출하지 않으면 라우트 핸들러 메서드가 전혀 실행되지 않습니다.</p>
<p>이 접근 방식은 <code>intercept()</code> 메서드가 요청/응답 스트림을 효과적으로 <strong>랩</strong>한다는 것을 의미합니다. 그리고 최종 라우트 핸들러 실행 <strong>전후</strong>에 사용자 정의 로직을 사용하고 싶을 수도 있습니다. <code>intercept()</code> 메서드에서 <code>handle()</code>을 호출하기 <strong>전에</strong> 코드를 작성하는 것은 명확하지만, 이후에 어떻게 영향을 미칠 수 있을까요? <code>handle()</code> 메서드는 <code>Observable</code>을 반환하므로 <a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener noreffer">RxJS</a> 연산자를 사용하여 응답을 추가로 조작할 수 있습니다. <strong>Aspect Oriented Programming</strong> 용어를 사용하면 라우트 핸들러를 호출하는 것(즉, <code>handle()</code>을 호출하는 것)은 <a href="https://en.wikipedia.org/wiki/Pointcut" target="_blank" rel="noopener noreffer">Pointcut</a>이라고 하며, 여기에 추가로직이 삽입되는 지점을 나타냅니다.</p>
<p>예를 들어, 들어오는 <code>POST /cats</code> 요청이 있습니다. 이 요청은 <code>CatsController</code> 내에 정의된 <code>create()</code> 핸들러를 대상으로 합니다. <code>handle()</code> 메서드를 호출하지 않는 인터셉터가 코드 중간 어디에서든(along the way) 사용되면 <code>create()</code> 메서드가 실행되지 않습니다. <code>handle()</code>이 호출되면 (그리고 그 <code>Observable</code>이 반환된 후에), <code>create()</code> 핸들러가 트리거됩니다. 그리고 <code>Observable</code>을 통해 수신한 응답 스트림을 사용하여 추가 작업을 수행하고 최종 결과를 호출자에게 반환할 수 있습니다.</p>
<p>​</p>
<h3 id="aspect-interceptionhttpsdocsnestjscominterceptorsaspect-interception">Aspect interception<a href="https://docs.nestjs.com/interceptors#aspect-interception" target="_blank" rel="noopener noreffer">#</a></h3>
<p>첫 번째 사용 사례는 인터셉터를 사용하여 사용자 상호 작용을 기록하는 것입니다. 예를 들어 사용자 호출을 저장하거나 이벤트를 비동기적으로 디스패치하거나 타임스탬프를 계산하는 등의 상호 작용을 기록하는 간단한 <code>LoggingInterceptor</code>를 아래에 표시합니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//logging.interceptor.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">NestInterceptor</span><span class="p">,</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">CallHandler</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">tap</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs/operators&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">LoggingInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Before...&#39;</span><span class="p">);</span>

    <span class="kr">const</span> <span class="nx">now</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">next</span>
      <span class="p">.</span><span class="nx">handle</span><span class="p">()</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span>
        <span class="nx">tap</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`After... </span><span class="si">${</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">now</span><span class="si">}</span><span class="sb">ms`</span><span class="p">)),</span>
      <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>The <code>NestInterceptor&lt;T, R&gt;</code> is a generic interface in which <code>T</code> indicates the type of an <code>Observable&lt;T&gt;</code> (supporting the response stream), and <code>R</code> is the type of the value wrapped by <code>Observable&lt;R&gt;</code>.</p>
</blockquote>
<blockquote>
<p><strong>NOTICE</strong></p>
<p>인터셉터는 컨트롤러, 프로바이더, 가드 등과 마찬가지로 <code>constructor</code>를 통해 <strong>의존성을 주입</strong>할 수 있습니다.</p>
</blockquote>
<p><code>handle()</code>가 RxJS <code>Observable</code>을 반환하기 때문에 우리는 스트림을 조작하기 위해 다양한 오퍼레이터를 선택할 수 있습니다. 위의 예제에서는 <code>tap()</code> 오퍼레이터를 사용했는데, 이는 우리의 익명 로깅 함수를 옵저버블 스트림이 정상적이거나 예외적으로 종료될 때 호출하지만 그 외에는 응답 주기에 간섭하지 않습니다.</p>
<p>​</p>
<h3 id="binding-interceptorshttpsdocsnestjscominterceptorsbinding-interceptors">Binding interceptors<a href="https://docs.nestjs.com/interceptors#binding-interceptors" target="_blank" rel="noopener noreffer">#</a></h3>
<p>인터셉터를 설정하기 위해서는 <code>@nestjs/common</code> 패키지에서 가져온 <code>@UseInterceptors()</code> 데코레이터를 사용합니다. <a href="https://docs.nestjs.com/pipes" target="_blank" rel="noopener noreffer">파이프</a>와 <a href="https://docs.nestjs.com/guards" target="_blank" rel="noopener noreffer">가드</a>와 마찬가지로 인터셉터는 컨트롤러 범위, 메서드 범위 또는 글로벌 범위로 설정할 수 있습니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@UseInterceptors</span><span class="p">(</span><span class="nx">LoggingInterceptor</span><span class="p">)</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>The <code>@UseInterceptors()</code> decorator is imported from the <code>@nestjs/common</code> package.</p>
</blockquote>
<p>위의 구조를 사용하면 <code>CatsController</code>에 정의된 각 라우트 핸들러는 <code>LoggingInterceptor</code>를 사용합니다. 누군가 <code>GET /cats</code> 엔드포인트를 호출하면 표준 출력에서 다음과 같은 출력을 볼 수 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd">Before...
After... 1ms
</code></pre></td></tr></table>
</div>
</div><p>앞서 언급한 대로 <code>LoggingInterceptor</code> 타입을 전달하여 (인스턴스 대신에) 프레임워크에 인스턴스화 책임을 맡기고 의존성 주입을 활성화했습니다. 파이프, 가드, 예외 필터와 마찬가지로 현장에서 직접 인스턴스를 전달할 수도 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//cats.controller.ts
</span><span class="c1"></span>
<span class="kd">@UseInterceptors</span><span class="p">(</span><span class="k">new</span> <span class="nx">LoggingInterceptor</span><span class="p">())</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CatsController</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>앞서 언급했듯이 위의 구성은 이 인터셉터를 이 컨트롤러에서 선언된 모든 핸들러에 첨부합니다. 인터셉터의 범위를 단일 메서드로 제한하려면 데코레이터를 <strong>메서드 레벨</strong>에서 적용하면 됩니다.</p>
<p>전역 인터셉터를 설정하려면 Nest 애플리케이션 인스턴스의 <code>useGlobalInterceptors()</code> 메서드를 사용합니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//main.ts
</span><span class="c1"></span>
<span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">NestFactory</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">AppModule</span><span class="p">);</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">useGlobalInterceptors</span><span class="p">(</span><span class="k">new</span> <span class="nx">LoggingInterceptor</span><span class="p">());</span>
</code></pre></td></tr></table>
</div>
</div><p>전역 인터셉터는 전체 애플리케이션에서 모든 컨트롤러와 라우트 핸들러에 사용됩니다. 의존성 주입 측면에서 위 예제와 같이 외부에서 <code>useGlobalInterceptors()</code>를 사용하여 등록한 전역 인터셉터는 어떤 모듈의 컨텍스트에서도 의존성을 주입할 수 없습니다. 이 문제를 해결하기 위해 다음 구성을 사용하여 <strong>모듈에서 직접</strong> 인터셉터를 설정할 수 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//app.module.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Module</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">APP_INTERCEPTOR</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/core&#39;</span><span class="p">;</span>

<span class="kd">@Module</span><span class="p">({</span>
  <span class="nx">providers</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">provide</span>: <span class="kt">APP_INTERCEPTOR</span><span class="p">,</span>
      <span class="nx">useClass</span>: <span class="kt">LoggingInterceptor</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">],</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">AppModule</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>이 접근 방식을 사용하여 인터셉터에 대한 의존성 주입을 수행할 때, 이 구성이 적용된 모듈과 관계없이 해당 인터셉터는 사실상 전역적입니다. 어디에서 이 작업을 수행해야 할까요? 위의 예제에서 나온대로 인터셉터가 정의된 모듈을 선택하세요. 또한, <code>useClass</code>는 사용자 정의 제공자 등록을 다루는 유일한 방법이 아닙니다. 더 자세한 내용은 <a href="https://docs.nestjs.com/fundamentals/custom-providers" target="_blank" rel="noopener noreffer">여기</a>에서 알아보세요.</p>
</blockquote>
<p>​</p>
<h3 id="response-mappinghttpsdocsnestjscominterceptorsresponse-mapping">Response mapping<a href="https://docs.nestjs.com/interceptors#response-mapping" target="_blank" rel="noopener noreffer">#</a></h3>
<p>우리는 이미 <code>handle()</code>이 Observable을 반환한다는 것을 알고 있습니다. 이 스트림에는 route handler에서 반환된 값이 포함되어 있으므로 RxJS의 <code>map()</code> 연산자를 사용하여 쉽게 변형할 수 있습니다.</p>
<div class="details admonition warning open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-exclamation-triangle fa-fw"></i>WARNING<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">매핑 기능은 라이브러리별 응답 전략과 함께 작동하지 않습니다 (<code>@Res()</code> 객체를 직접 사용하는 것은 금지).</div>
        </div>
    </div>
<p>다음은 <code>TransformInterceptor</code>를 만들어보겠습니다. 이 인터셉터는 간단한 방식으로 각 응답을 수정하여 프로세스를 보여줍니다. RxJS의 <code>map()</code> 연산자를 사용하여 응답 객체를 새로 생성된 객체의 <code>data</code> 속성에 할당하고, 이 새로운 객체를 클라이언트에 반환합니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//transform.interceptor.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">NestInterceptor</span><span class="p">,</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">CallHandler</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">map</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs/operators&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">Response</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="nx">data</span>: <span class="kt">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">TransformInterceptor</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">Response</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">Response</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">handle</span><span class="p">().</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="nx">data</span> <span class="p">})));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>Nest 인터셉터는 동기 및 비동기 <code>intercept()</code> 메서드와 함께 작동합니다. 필요한 경우 메서드를 <code>async</code>로 전환할 수 있습니다.</p>
</blockquote>
<p>위의 구성으로 누군가 <code>GET /cats</code> 엔드포인트를 호출하면, 응답은 다음과 같을 것입니다 (루트 핸들러가 빈 배열 <code>[]</code>을 반환하는 경우를 가정합니다):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;data&#34;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>인터셉터는 전체 애플리케이션에 걸쳐 발생하는 요구 사항에 대한 재사용 가능한 솔루션을 만드는 데 큰 가치가 있습니다. 예를 들어 <code>null</code> 값을 빈 문자열 <code>''</code>로 변환해야 하는 경우를 상상해보세요. 한 줄의 코드로 이를 수행하고 인터셉터를 전역으로 바인딩하여 각 등록된 핸들러에서 자동으로 사용하도록 설정할 수 있습니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">NestInterceptor</span><span class="p">,</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">CallHandler</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">map</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs/operators&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">ExcludeNullInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span>
      <span class="p">.</span><span class="nx">handle</span><span class="p">()</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">?</span> <span class="s1">&#39;&#39;</span> <span class="o">:</span> <span class="nx">value</span> <span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="exception-mappinghttpsdocsnestjscominterceptorsexception-mapping">Exception mapping<a href="https://docs.nestjs.com/interceptors#exception-mapping" target="_blank" rel="noopener noreffer">#</a></h3>
<p>또 다른 흥미로운 사용 사례는 RxJS의 <code>catchError()</code> 연산자를 활용하여 던져진 예외를 재정의하는 것입니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//errors.interceptor.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span>
  <span class="nx">Injectable</span><span class="p">,</span>
  <span class="nx">NestInterceptor</span><span class="p">,</span>
  <span class="nx">ExecutionContext</span><span class="p">,</span>
  <span class="nx">BadGatewayException</span><span class="p">,</span>
  <span class="nx">CallHandler</span><span class="p">,</span>
<span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">throwError</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">catchError</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs/operators&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">ErrorsInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span>
      <span class="p">.</span><span class="nx">handle</span><span class="p">()</span>
      <span class="p">.</span><span class="nx">pipe</span><span class="p">(</span>
        <span class="nx">catchError</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="nx">throwError</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">BadGatewayException</span><span class="p">())),</span>
      <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="stream-overridinghttpsdocsnestjscominterceptorsstream-overriding">Stream overriding<a href="https://docs.nestjs.com/interceptors#stream-overriding" target="_blank" rel="noopener noreffer">#</a></h3>
<p>핸들러 호출을 완전히 방지하고 대신에 다른 값을 반환하는 이유가 몇 가지 있습니다. 명백한 예로 응답 시간을 개선하기 위해 캐시를 구현하는 것이 있습니다. 캐시에서 응답을 반환하는 간단한 <strong>캐시 인터셉터</strong>를 살펴보겠습니다. 현실적인 예제에서는 TTL, 캐시 무효화, 캐시 크기 등과 같은 다른 요소도 고려해야 합니다. 하지만 이것은 이 토론의 범위를 벗어납니다. 여기서는 주요 컨셉을 보여주는 기본적인 예제를 제공하겠습니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//cache.interceptor.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">NestInterceptor</span><span class="p">,</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">CallHandler</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="k">of</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">CacheInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">isCached</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isCached</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">of</span><span class="p">([]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">handle</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>우리의 <code>CacheInterceptor</code>에는 하드코딩된 <code>isCached</code> 변수와 하드코딩된 응답 <code>[]</code>이 있습니다. 주목해야 할 중요한 점은 RxJS의 <code>of()</code> 연산자에 의해 여기서 생성된 새로운 스트림을 반환하므로 라우트 핸들러는 <strong>전혀 호출되지 않을 것</strong>입니다. <code>CacheInterceptor</code>를 사용하는 엔드포인트를 호출하면 응답(하드코딩된 빈 배열)이 즉시 반환됩니다. 일반적인 솔루션을 만들려면 <code>Reflector</code>를 활용하여 사용자 정의 데코레이터를 만들 수 있습니다. <code>Reflector</code>는 <a href="https://docs.nestjs.com/guards" target="_blank" rel="noopener noreffer">guards</a> 챕터에서 잘 설명되어 있습니다.</p>
<p>​</p>
<h3 id="more-operatorshttpsdocsnestjscominterceptorsmore-operators">More operators<a href="https://docs.nestjs.com/interceptors#more-operators" target="_blank" rel="noopener noreffer">#</a></h3>
<p>RxJS 연산자를 사용하여 스트림을 조작할 수 있는 가능성은 많은 기능을 제공합니다. 또 다른 일반적인 사용 사례를 살펴보겠습니다. 엔드포인트가 일정 시간이 지나서 아무것도 반환하지 않는 경우에, 에러를 반환 하고 싶을 것입니다. 다음 구성은 이를 가능하게 합니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//timeout.interceptor.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Injectable</span><span class="p">,</span> <span class="nx">NestInterceptor</span><span class="p">,</span> <span class="nx">ExecutionContext</span><span class="p">,</span> <span class="nx">CallHandler</span><span class="p">,</span> <span class="nx">RequestTimeoutException</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">throwError</span><span class="p">,</span> <span class="nx">TimeoutError</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">catchError</span><span class="p">,</span> <span class="nx">timeout</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;rxjs/operators&#39;</span><span class="p">;</span>

<span class="kd">@Injectable</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">TimeoutInterceptor</span> <span class="kr">implements</span> <span class="nx">NestInterceptor</span> <span class="p">{</span>
  <span class="nx">intercept</span><span class="p">(</span><span class="nx">context</span>: <span class="kt">ExecutionContext</span><span class="p">,</span> <span class="nx">next</span>: <span class="kt">CallHandler</span><span class="p">)</span><span class="o">:</span> <span class="nx">Observable</span><span class="p">&lt;</span><span class="nt">any</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">.</span><span class="nx">handle</span><span class="p">().</span><span class="nx">pipe</span><span class="p">(</span>
      <span class="nx">timeout</span><span class="p">(</span><span class="mi">5000</span><span class="p">),</span>
      <span class="nx">catchError</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="k">instanceof</span> <span class="nx">TimeoutError</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">throwError</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">RequestTimeoutException</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">throwError</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">err</span><span class="p">);</span>
      <span class="p">}),</span>
    <span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>5초 후에 요청 처리가 취소됩니다. <code>RequestTimeoutException</code>을 throw하기 전에 사용자 지정 논리를 추가할 수도 있습니다(예: 리소스 해제).</p>
<p>​</p>
<p>​</p>
<h2 id="custom-route-decorators">Custom route decorators</h2>
<p>Nest는 <strong>데코레이터</strong>라는 언어 기능을 중심으로 구축되었습니다. 데코레이터는 많은 일반적으로 사용되는 프로그래밍 언어에서 잘 알려진 개념이지만 JavaScript 세계에서는 여전히 비교적 새로운 개념입니다. 데코레이터 작동 방식을 더 잘 이해하기 위해 <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank" rel="noopener noreffer">이 기사</a>를 읽는 것이 좋습니다. 여기에 간단한 정의가 있습니다:</p>
<blockquote>
<p>ES2016(ES7) 데코레이터는 함수를 반환하는 표현식으로, 대상(target), 이름(name), 및 속성 기술자(property descriptor)를 인수로 받을 수 있습니다. 데코레이터를 적용하려면 데코레이터를 <code>@</code> 문자로 접두사로 붙이고 이를 꾸며주려는 대상의 맨 위에 배치하면 됩니다. 데코레이터는 클래스, 메서드 또는 속성에 대해 정의할 수 있습니다.</p>
</blockquote>
<p>​</p>
<h3 id="param-decoratorshttpsdocsnestjscomcustom-decoratorsparam-decorators">Param decorators<a href="https://docs.nestjs.com/custom-decorators#param-decorators" target="_blank" rel="noopener noreffer">#</a></h3>
<p>Nest는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 <strong>파라미터 데코레이터</strong> 세트를 제공합니다. 아래는 제공되는 데코레이터와 해당하는 일반적인 Express (또는 Fastify) 객체의 목록입니다.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Request(), @Req()</code></td>
<td><code>req</code></td>
</tr>
<tr>
<td><code>@Response(), @Res()</code></td>
<td><code>res</code></td>
</tr>
<tr>
<td><code>@Next()</code></td>
<td><code>next</code></td>
</tr>
<tr>
<td><code>@Session()</code></td>
<td><code>req.session</code></td>
</tr>
<tr>
<td><code>@Param(param?: string)</code></td>
<td><code>req.params</code> / <code>req.params[param]</code></td>
</tr>
<tr>
<td><code>@Body(param?: string)</code></td>
<td><code>req.body</code> / <code>req.body[param]</code></td>
</tr>
<tr>
<td><code>@Query(param?: string)</code></td>
<td><code>req.query</code> / <code>req.query[param]</code></td>
</tr>
<tr>
<td><code>@Headers(param?: string)</code></td>
<td><code>req.headers</code> / <code>req.headers[param]</code></td>
</tr>
<tr>
<td><code>@Ip()</code></td>
<td><code>req.ip</code></td>
</tr>
<tr>
<td><code>@HostParam()</code></td>
<td><code>req.hosts</code></td>
</tr>
</tbody>
</table>
<p>추가로 사용자는 자신만의 <strong>커스텀 데코레이터</strong>를 만들 수도 있습니다. 왜 이것이 유용할까요?</p>
<p>node.js 세상에서는 요청 개체에 속성을 첨부하는 것이 일반적인 방법입니다. 그런 다음 각 라우터 핸들러에서 다음과 같은 코드를 사용하여 속성을 수동으로 추출합니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>코드를 더 읽기 쉽고 깔끔하게 만들기 위해 @User() 데코레이터를 만들고 모든 컨트롤러에서 코드를 재사용할 수 있습니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//user.decorator.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">createParamDecorator</span><span class="p">,</span> <span class="nx">ExecutionContext</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">createParamDecorator</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">data</span>: <span class="kt">unknown</span><span class="p">,</span> <span class="nx">ctx</span>: <span class="kt">ExecutionContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">().</span><span class="nx">getRequest</span><span class="p">();</span>
    <span class="k">return</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, you can simply use it wherever it fits your requirements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findOne</span><span class="p">(</span><span class="kd">@User</span><span class="p">()</span> <span class="nx">user</span>: <span class="kt">UserEntity</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>​</p>
<h3 id="passing-datahttpsdocsnestjscomcustom-decoratorspassing-data">Passing data<a href="https://docs.nestjs.com/custom-decorators#passing-data" target="_blank" rel="noopener noreffer">#</a></h3>
<p>데코레이터의 동작이 어떤 조건에 따라 달라질 때 <code>data</code> 매개변수를 사용하여 데코레이터 팩토리 함수에 인수를 전달할 수 있습니다. 이러한 경우 중 하나는 요청 객체에서 키별로 속성을 추출하는 사용자 정의 데코레이터입니다. 예를 들어 <a href="https://docs.nestjs.com/techniques/authentication#implementing-passport-strategies" target="_blank" rel="noopener noreffer">인증 레이어</a>가 요청을 유효성 검사하고 사용자 엔터티를 요청 객체에 첨부하는 경우, 인증된 요청에 대한 사용자 엔터티는 다음과 같을 수 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">101</span><span class="p">,</span>
  <span class="nt">&#34;firstName&#34;</span><span class="p">:</span> <span class="s2">&#34;Alan&#34;</span><span class="p">,</span>
  <span class="nt">&#34;lastName&#34;</span><span class="p">:</span> <span class="s2">&#34;Turing&#34;</span><span class="p">,</span>
  <span class="nt">&#34;email&#34;</span><span class="p">:</span> <span class="s2">&#34;alan@email.com&#34;</span><span class="p">,</span>
  <span class="nt">&#34;roles&#34;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&#34;admin&#34;</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>해당 예제에서는 키로 속성 이름을 받아 해당 값이 있으면 반환하고 (없으면 <code>undefined</code> 반환하거나 <code>user</code> 객체가 생성되지 않은 경우도 해당), 사용자 엔터티의 특정 속성을 추출하는 데코레이터를 정의합니다.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//user.decorator.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">createParamDecorator</span><span class="p">,</span> <span class="nx">ExecutionContext</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">createParamDecorator</span><span class="p">(</span>
  <span class="p">(</span><span class="nx">data</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">ctx</span>: <span class="kt">ExecutionContext</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">switchToHttp</span><span class="p">().</span><span class="nx">getRequest</span><span class="p">();</span>
    <span class="kr">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">user</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">data</span> <span class="o">?</span> <span class="nx">user</span><span class="o">?</span><span class="p">.[</span><span class="nx">data</span><span class="p">]</span> <span class="o">:</span> <span class="nx">user</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>다음은 컨트롤러에서 <code>@User()</code> 데코레이터를 사용하여 특정 속성에 액세스하는 방법의 예시입니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findOne</span><span class="p">(</span><span class="kd">@User</span><span class="p">(</span><span class="s1">&#39;firstName&#39;</span><span class="p">)</span> <span class="nx">firstName</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Hello </span><span class="si">${</span><span class="nx">firstName</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>같은 데코레이터를 다른 키와 함께 사용하여 다양한 속성에 액세스할 수 있습니다. <code>user</code> 객체가 깊거나 복잡한 경우, 이렇게 함으로써 더 쉽고 가독성 있는 요청 핸들러를 구현할 수 있습니다.</p>
<blockquote>
<p><strong>HINT</strong></p>
<p>TypeScript 사용자들을 위해 <code>createParamDecorator&lt;T&gt;()</code>가 제네릭임을 주목하세요. 이는 명시적으로 타입 안전성을 강제할 수 있음을 의미합니다. 예를 들어 <code>createParamDecorator&lt;string&gt;((data, ctx) =&gt; ...)</code>와 같이 사용할 수 있습니다. 또는 팩토리 함수에서 매개변수 타입을 지정할 수도 있습니다. 예를 들어 <code>createParamDecorator((data: string, ctx) =&gt; ...)</code>와 같이 사용할 수 있습니다. 둘 다 생략하는 경우 <code>data</code>의 타입은 <code>any</code>가 됩니다.</p>
</blockquote>
<p>​</p>
<h3 id="working-with-pipeshttpsdocsnestjscomcustom-decoratorsworking-with-pipes">Working with pipes<a href="https://docs.nestjs.com/custom-decorators#working-with-pipes" target="_blank" rel="noopener noreffer">#</a></h3>
<p>Nest는 사용자 정의된 매개 변수 데코레이터를 내장된 것들 (<code>@Body()</code>, <code>@Param()</code> 및 <code>@Query()</code>)과 동일한 방식으로 처리합니다. 이는 사용자 정의 주석이 달린 매개 변수에 대해서도 파이프가 실행된다는 것을 의미합니다 (우리의 예제에서는 <code>user</code> 인자). 더 나아가 직접 사용자 정의 데코레이터에 파이프를 적용할 수도 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Get</span><span class="p">()</span>
<span class="kr">async</span> <span class="nx">findOne</span><span class="p">(</span>
  <span class="kd">@User</span><span class="p">(</span><span class="k">new</span> <span class="nx">ValidationPipe</span><span class="p">({</span> <span class="nx">validateCustomDecorators</span>: <span class="kt">true</span> <span class="p">}))</span>
  <span class="nx">user</span>: <span class="kt">UserEntity</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>HINT</strong></p>
<p>주의: <code>validateCustomDecorators</code> 옵션을 true로 설정해야 합니다. <code>ValidationPipe</code>은 기본적으로 사용자 정의 데코레이터로 주석이 달린 인수를 유효성 검사하지 않습니다.</p>
</blockquote>
<p>​</p>
<h3 id="decorator-compositionhttpsdocsnestjscomcustom-decoratorsdecorator-composition">Decorator composition<a href="https://docs.nestjs.com/custom-decorators#decorator-composition" target="_blank" rel="noopener noreffer">#</a></h3>
<p>Nest는 여러 데코레이터를 결합하는 데 사용할 수 있는 도우미 메서드를 제공합니다. 예를 들어 인증과 관련된 모든 데코레이터를 하나의 데코레이터로 결합하려면 다음 구조를 사용할 수 있습니다:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="c1">//auth.decorator.ts
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">applyDecorators</span> <span class="p">}</span> <span class="kr">from</span> <span class="s1">&#39;@nestjs/common&#39;</span><span class="p">;</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">Auth</span><span class="p">(...</span><span class="nx">roles</span>: <span class="kt">Role</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">applyDecorators</span><span class="p">(</span>
    <span class="nx">SetMetadata</span><span class="p">(</span><span class="s1">&#39;roles&#39;</span><span class="p">,</span> <span class="nx">roles</span><span class="p">),</span>
    <span class="nx">UseGuards</span><span class="p">(</span><span class="nx">AuthGuard</span><span class="p">,</span> <span class="nx">RolesGuard</span><span class="p">),</span>
    <span class="nx">ApiBearerAuth</span><span class="p">(),</span>
    <span class="nx">ApiUnauthorizedResponse</span><span class="p">({</span> <span class="nx">description</span><span class="o">:</span> <span class="s1">&#39;Unauthorized&#39;</span> <span class="p">}),</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>You can then use this custom <code>@Auth()</code> decorator as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="kd">@Get</span><span class="p">(</span><span class="s1">&#39;users&#39;</span><span class="p">)</span>
<span class="kd">@Auth</span><span class="p">(</span><span class="s1">&#39;admin&#39;</span><span class="p">)</span>
<span class="nx">findAllUsers() {</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>이렇게 하면 한 번의 선언으로 네 개의 데코레이터가 모두 적용됩니다.</p>
<blockquote>
<p><strong>WARNING</strong></p>
<p><code>@nestjs/swagger</code> 패키지의 <code>@ApiHideProperty()</code> 데코레이터는 합성 가능하지 않으며 <code>applyDecorators</code> 함수와 제대로 작동하지 않을 것입니다.</p>
</blockquote>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
<p>​</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-01-14</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/nest-official_03_guards-interceptors-custom_decorators/index.md" target="_blank">Read Markdown</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/nest/">Nest</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/nest-official_02_modules-middleware-exception_filters-pipes/" class="prev" rel="prev" title="Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)"><i class="fas fa-angle-left fa-fw"></i>Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)</a>
            <a href="/decorator/" class="next" rel="next" title="why use a decorator? And what&#39;s the benefit?">why use a decorator? And what&#39;s the benefit?<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.87.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">colinder</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script type="text/javascript" src="https://colinder-github-io.disqus.com/embed.js" defer></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript" src="/lib/cookieconsent/cookieconsent.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":-1},"comment":{},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
