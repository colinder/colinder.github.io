[{"categories":["programmers"],"content":"​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:0","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"타겟 넘버 numbers = [1, 1, 1, 1, 1] target = 3 # return = 5 from itertools import product l = [(-number, number)for number in numbers] s = list(map(sum, product(*l))) print(s.count(target)) ## 미쳤다. product().. ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:1","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"K번째 수 array = [1, 5, 2, 6, 3, 7, 4] commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]] def solution(array, commands): answer = [] for _ in commands: i, j, k = _ q = array[i-1: j] q.sort() answer.append(q[k-1]) return answer print(solution(array, commands)) ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:2","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"다리를 지나는 트럭 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 from collections import deque truck_weights = deque(truck_weights) bridge = deque([0 for _ in range(bridge_length)]) time = 0 bridge_weight = 0 #현재 다리를 건너고 있는 무게 # bridge = [0, 0] while(len(bridge)) != 0 out = bridge.popleft() bridge_weight -= out time += 1 if truck_weights: if bridge_weight + truck_weights[0] \u003c= weight: left = truck_weights.popleft() bridge_weight += left bridge.append(left) else: bridge.append(0) ## 다리가 지나는 위치를 bridge로 표현하고 디큐를 이용해 속도를 올린다. ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:3","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SW Expert Academy"],"content":"D4_11316_주기 찾기 for T in range(int(input())): s, p, q, m = map(int, input().split()) V = s visited = [0]*m i = 1 while True: V = (p*V + q) % m i += 1 if visited[V] != 0: result = i - visited[V] break visited[V] = i print(f'#{T+1} {result}') # 한 번 나왔던 숫자의 '위치 정보(i)'를 # visited에 저장해 두었다가 # 한 번이라도 방문했던 숫자가 나왔을 때 # 저장해주었던 '위치 정보'의 차리를 계산해 준다. # 코딩중. # 만약 [6,8,6,4,3,5,4,3,5,4,3,5...] 경우가 있을 수 있나? 는 고민으로 # 시간을 썼으나. # 문제 조건 중 # 슈도랜덤 제너레이터의 주기란, # 어떤 정수 n0 이상인 '모든 n에 대해' An+p = An을 만족하는 가장 작은 자연수 p # 라는 내용을 보고, 반복되는 수의 등장은 동일 배열 순환의 시작이라고 파악해야 했다. ​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11445_무한 사전 for T in range(int(input())): P = input().rstrip() Q = input().rstrip() if P + \"a\" != Q: result = \"Y\" else: result = \"N\" print(f'#{T+1} {result}') # 왜 D3 인가. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11387_몬스터 사냥 for T in range(int(input())): D, L, N = map(int, input().split()) result = 0 for i in range(N): result += D * (1 + L*i/100) print(f'#{T+1} {int(result)}') ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11285_다트 게임 table = [20, 40, 60, 80, 100, 120, 140, 160, 180, 200] value = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] for T in range(int(input())): result = 0 for i in range(int(input())): x, y = map(int, input().split()) dis = (x**2 + y**2)**0.5 for i, v in zip(table, value): if dis \u003c= i: result += v break print(f'#{T+1} {result}') # (오답 : 10000개의 테스트케이스 중 4344개가 맞았습니다.) # 제한시간 초과가 발생하였습니다. ## python으론 안되나...... ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11315_오목 판정 def check(x, y): global result # 가로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+i][y+j] if total == 5: result = \"YES\" return # 세로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+j][y+i] if total == 5: result = \"YES\" return # 좌상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+i] if total == 5: result = \"YES\" return # 우상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+4-i] if total == 5: result = \"YES\" return for T in range(int(input())): N = int(input()) arr = [] # 돌이 있으면 1, 없으면 0 for _ in range(N): C = input() NC = [] for i in C: if i == \".\": NC.append(0) else: NC.append(1) arr.append(NC) result = \"NO\" for x in range(N-4): for y in range(N-4): check(x, y) print(f'#{T+1} {result}') # 스마트해 보이진 않는다. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["Python"],"content":"​ Python Library 😀 ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"Idea # 모두 '거짓'이 들어있는 리스트는 '거짓'으로 볼 수 있지 않을까? # 라고 생각해봤다. a = [False, False, False] if a == False: print(\"거짓\") else: print(\"오류\") # \u003e\u003e\u003e 오류 # 안된다. 생각을 말아라..ㅎㅎ ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"raise 예외(‘에러메시지’) # python에서는 의도적으로 오류를 일으킬 수 있는데 # 이를 해주는 것이 raise 메서드. try: x = 2 if x % 3 != 0: raise Exception('3의 배수가 아닙니다.') print(\"입력된 값\", x) except Exception as e: print('예외가 발생했습니다.', e) \u003e\u003e\u003e 예외가 발생했습니다. 3의 배수가 아닙니다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"filter() VS find() ## filter(function, iterable) # 배열의 `모든 요소`에 접근하여 조건에 맞는 `값`을 찾는다. # ex) def func(x): if x \u003e 0: return x else: return None list(filter(func, range(-5,10))) \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # ex) [ i for i in range(-5,10) if i \u003e 0 ] \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # find(sub[, start[, end]]) # 배열을 순회하면서 찾으려 하는 값의 `index`를 반환 해준다. # ex) a = 'hello' a.find('o') # find 함수 \u003e\u003e\u003e 4 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:3","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"index() VS find() ## 공통점 # 두 함수 모두 찾으려 하는 값의 `index`를 반환 해준다. # ex) \u003e\u003e\u003e 'oxoxoxoxox'.find('x') # find 함수 1 \u003e\u003e\u003e 'oxoxoxoxox'.index('x') # index 함수 1 # 문자 'o'가 첫번째 위치한 자리를 출력 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o') # find 함수 4 \u003e\u003e\u003e a.index('o') # index 함수 4 # 또 (value, start, end) 형태로 문자를 찾는 시작점과 종료점을 지정할 수 있다. # 문자열중 2번째 위치부터 처음 'x'가 위치한 자리 \u003e\u003e\u003e 'oxoxoxoxox'.index('x', 2) 3 # a변수에서 1번째~3번째 사이에 문자 'o'가 위치한 자리 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o', 1, 3) -1 # find함수는 찾는 값이 없을 때 -1을 출력한다. 이게 차이점. ## 차이점 # 찾으려는 값이 없는 경우 find()는 '-1'을 반환 / index()는 'ValueError' 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:4","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"deque # deque는 기본적으로 리스트를 변형(ex. pop() ...)하며 코딩할 때 # 속도가 빠르기 때문에 사용한다. # 주로 popleft()를 사용하지만, 유용한 기능이 더 있다. ## 1. rotate from collections import deque q = deque([1,2,3,4,5,6]) q.rotate(3) print(q) # deque([4, 5, 6, 1, 2, 3]) # 주로 리스트의 끝이 붙어 있는 원순열 문제를 해결하는데 편리하다. # 다만 속도가 어떤지는 잘 모르겠다. ## 2. deque는 슬라이싱이 되지 않는다. # 굳이 해야 한다면 아래를 참고 deque_slice = collections.deque(itertools.islice(my_deque, 10, 20)) # deque는 # index()는 '사용가능'하고 find()는 '사용불가'하다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:5","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"q[len(q)-1] VS q[-1] 속도 비교 import time start = time.time() # 시작 시간 저장 ... ... print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. # 왜..? ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:6","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"isalpha(), isdigit() # 알파벳이냐?, 숫자형이냐? 를 참, 거짓 형태로 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:7","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sys.setrecursionlimit(최대 재귀 깊이 설정) # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:8","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sorted() sorted는 여러 그룹의 값이 주어진 경우 ## 순차적으로 증감을 비교해 준다. # ex) A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] A = sorted(A) print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ## 만약 주어진 두번째 인자들을 기준으로 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: L[1]) print(B) # [(1, -1), (2, 2), (1, 2), (3, 3), (0, 4)] ## 두번째 인자 우선 기준 후 첫번째 인자 기준 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: (L[1], L[0])) print(B) # [(1, -1), (1, 2), (2, 2), (3, 3), (0, 4)] ## set자료형을 sorted 하면 자동으로 list type으로 변환된다. a = {\"a\",\"b\",\"C\"} print(\"a의 타입: \",type(a)) # a의 타입: \u003cclass 'set'\u003e b = sorted(a) print(\"b의 타입: \", type(b)) # b의 타입: \u003cclass 'list'\u003e ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:9","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"from collections import Counter 주어지는 컨테이너(ex 리스트 자료형, string)에 동일한 값의 갯수를 파악 from collections import Counter MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() print(MoResult) #[(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() 함수 # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:10","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import sys 빠른 속도로 입력받기 위한 라이브러리 imput VS sys.stdin.readline() # python의 대표적인 입력 함수 imput() # 단, 백준에는 더 빠른 방법이 초기에 설명되어있다. import sys sys.stdin.readline() # 단 위와 같이 입력 받은 경우, 마지막에 개행 문자까지 입력되어 뒤에 # 추가 함수(rstrip())를 붙여 사용하는 것이 보통이다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:11","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"정규표현식 일대일 매칭되는 문자 정규표현식 안에서, 바로 다음 절에서 설명하는 메타문자를 제외한 모든 문자 하나는 일반 문자열 하나와 매칭된다. 예를 들어, a는 a와 매칭되고, 가는 ‘가’와 매칭되는 식이다. 당연히 a가 ‘b’ 또는 ‘가’와 매칭되지는 않는다. 어떤 프로그래밍 언어의 정규표현식이든 메타문자(특수한 기능을 하는 문자)라는 것이 존재한다. 파이썬 re 모듈의 메타문자는 총 12개로 다음과 같은 것들이 있다. $()*+.?[^{| 이들 메타문자는 각각의 문자 하나에 매칭되지 않는다. 예를 들어 일반 문자인 a는 문자 ‘a’에 매칭하지만, 여는 소괄호 (는 문자 ‘(‘와 매칭하지 않는다. 그럼 찾고자 하는 문자열에 소괄호가 있으면 어떻게 할까? 위의 문자들의 앞에 백슬래시 \\를 붙여 주면 일반 문자처럼 한 글자에 매칭된다. 예를 들어 \\(는 문자 ‘(‘와 매칭된다. ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:12","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"find(찾을문자, 찾기시작할위치) - 찾는 값의 인덱스를 반환 s = '가나다라 마바사아 자차마타 파하' print(s.find('마')) # s에서 첫'마'의 인덱스를 반환 print(s.find('마', 3)) # s[3:]부터 첫'마'의 인덱스를 반환 (전체 범위 기준) print(s.find('가', 2)) # s[2:]부터 첫'가'의 인덱스를 반환 (없으면 -1 반환) 5 5 -1 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:13","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"startsWith(찾을문자, 찾기시작위치, 찾기종료위치) str = \"this is string\"; print(str.startswith('this')) # str맨앞이 'this'로시작하는지 검사 print(str.startswith('is', 2, 4)) # str[2:4]에서 맨앞이 'is'인지 검사 print(str.startswith('this', 3, 4)) # str[3:4]에서 맨앞이 'this'인지 검사 True True False ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:14","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import itertools (효율적인 반복을 위한 함수) ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"permutations(자료, 만들순열길이) n개의 원소를 사용해서 순서를 정하여 r개의 배열로 나타내는 것 =\u003e 순열 공식 : nPr = n!/(n-r)! import itertools a = [1,2,3] permute = itertools.permutations(a,2) print(list(permute)) a = \"abc\" permute = itertools.permutations(a,2) print(list(permute)) [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"combinations(조합) n개의 원소를 사용해서 순서의 관계없이 r개의 배열로 나타내는 것 =\u003e 조합 공식 : nCr=nPr/r! import itertools a = [1,2,3] permute = itertools.combinations(a, 2) print(list(permute)) a = \"abc\" permute = itertools.combinations(a, 2) print(list(permute)) [(1, 2), (1, 3), (2, 3)] [('a', 'b'), ('a', 'c'), ('b', 'c')] ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:0","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"2630_색종이 만들기 import sys def DFS(x, y, N): global W, B color = arr[x][y] for cx in range(x, x+N): for cy in range(y, y+N): if arr[cx][cy] != color: DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) return # 이걸 안해주면 쓸모 없는 DFS에 더 들어가게 된다. if color == 0: W += 1 return else: B += 1 return N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] W, B = 0, 0 DFS(0, 0, N) print(W) print(B) # 분할한 구역에도 동일한 규칙을 적용할 수 있는 # 알고리즘을 만드는 것이 기본 같다. ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:1","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"1992_쿼드트리 import sys def DFS(x, y, N): global result check = arr[x][y] for i in range(x, x+N): for j in range(y, y+N): if check != arr[i][j]: result += \"(\" DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) result += \")\" return if check == 0: result += \"0\" else: result += \"1\" N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] result = \"\" DFS(0, 0, N) print(result) ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:2","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"5052_전화번호 목록 import sys for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) Numbers = [] for _ in range(N): Numbers.append(sys.stdin.readline().rstrip()) Numbers.sort() result = \"YES\" for i in range(len(Numbers)-1): if Numbers[i+1].find(Numbers[i], 0, len(Numbers[i])) != -1: result = 'NO' break print(result) # 흠.. 다른 사람들은 트리로 풀었나..? # 이게 왜 트리에 있지... ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"9372_상근이의 여행 import sys from collections import deque def BFS(i): q = deque([i]) visited = [True] + [False] * N flight = -1 while q: x = q.popleft() if visited[x] == False: visited[x] = True flight += 1 for j in range(len(tree[x])): if visited[tree[x][j]] == False: q.append(tree[x][j]) return flight for T in range(int(sys.stdin.readline().rstrip())): N, M = map(int, sys.stdin.readline().split()) tree = [[] for _ in range((N+1))] for _ in range(M): a, b = map(int, sys.stdin.readline().split()) tree[a].append(b) tree[b].append(a) print(BFS(1)) ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1991_트리 순회 class Node: def __init__(self, data, L, R): self.data = data self.left = L self.right = R def preorder(node): # 전위 순회 print(node.data, end=\"\") if node.left != \".\": preorder(tree[node.left]) if node.right != \".\": preorder(tree[node.right]) def inorder(node): # 중위 순회 if node.left != \".\": inorder(tree[node.left]) print(node.data, end=\"\") if node.right != \".\": inorder(tree[node.right]) def postorder(node): # 후위 순회 if node.left != \".\": postorder(tree[node.left]) if node.right != \".\": postorder(tree[node.right]) print(node.data, end=\"\") N = int(input()) tree = {} for _ in range(N) : data, L, R = input().split() tree[data] = Node(data, L, R) preorder(tree['A']) print() inorder(tree['A']) print() postorder(tree['A']) # 트리 구조에 대한 이해가 부족하다. # 트리문제를 많이 풀어봐야 겠다. # 해보니 복잡?하지는 않은데 익숙하지 않은 느낌이다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"11725_트리의 부모 찾기 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N-1): S, E = map(int, sys.stdin.readline().split()) tree[S].append(E) tree[E].append(S) q = deque([1]) visited = [True, True] + [False for _ in range(N)] result = [[] for _ in range(N+1)] while len(q): parent = q.popleft() for child in tree[parent]: if not visited[child]: visited[child] = True result[child].append(parent) q.append(child) for j in range(2, len(result)): print(result[j][0]) # heap을 사용하는 건가 고민했으나, 아니었고, # 1이 root node인 것을 알고 있으니. # 각각의 node에 연결되어있는 모든 node들을 기록했다가. # 1부터 BFS로 한 단계씩 내려가면, 코딩상 pop한 것이 # 부모 node가 된다. # 채점 속도가 느려서 런타임 오류 걸릴까봐 조마조마했다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1967_트리의 지름 import sys from collections import deque def BFS(value, step): q = deque() q.append(value) visited = [-1 for _ in range(N+1)] visited[value] = 0 while q: x = q.popleft() for c, w in tree[x]: if visited[c] == -1: visited[c] = visited[x] + w q.append(c) if step == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for i in range(N-1): P, C, V = map(int, input().split()) tree[P].append([C, V]) tree[C].append([P, V]) print(BFS(BFS(1, 1), 2)) # DFS로 지저분하게 구현했으나 말 그대로 # 너무 지저분해서 검색의 도움을 받음. # root인 1에서 가장 멀리 있는 노드를 고르고 # 그 노드에서 가장 멀리 있는 노드를 고르는 # 알고리즘으로 구현. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:3","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1167_트리의 지름 import sys from collections import deque sys.setrecursionlimit(10**9) def BFS(i, mode): q = deque() q.append(i) visited = [-1 for _ in range(N+1)] visited[i] = 0 while q: x = q.popleft() for C, W in tree[x]: if visited[C] == -1: visited[C] = visited[x] + W q.append(C) if mode == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N): info = list(map(int, sys.stdin.readline().split())) for i in range(1, len(info)-1, 2): tree[info[0]].append([info[i], info[i+1]]) print(BFS(BFS(i, 1), 2)) ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:4","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_3143_가장 빠른 문자열 타이핑 for T in range(int(input())): A, B = input().split() result = len(A) - (A.count(B)*(len(B)-1)) print(f'#{T+1} {result}') # 왜 D4 인가. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_10966_물놀이를 가자 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] for T in range(int(input())): N, M = map(int, input().split()) arr = [input() for _ in range(N)] visited = [[-1 for _ in range(M)] for _ in range(N)] q = deque([]) for i in range(N): for j in range(M): if arr[i][j] == \"W\": q.append([i,j]) visited[i][j] = 0 total = 0 while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0\u003c= cx \u003cN and 0\u003c= cy \u003cM and visited[cx][cy] == -1: visited[cx][cy] = visited[x][y] + 1 q.append([cx, cy]) total += visited[cx][cy] print(f'#{T+1} {total}') # 오랜만에 다중 시작점 BFS ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11592_크루즈 컨트롤 for T in range(int(input())): D, N = map(int, input().split()) # D: 총 거리 S = [] for _ in range(N): k, s = map(int, input().split()) # k : 위치 / s : 속도 S.append((D-k) / s) a = max(S) print(f'#{T+1} {D/a}') # D2 난이도... ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11545_틱택톰 def check(): # 가로 판단 for i in range(4): if '.' not in arr[i] and 'O' not in arr[i]: return 'X won' if '.' not in arr[i] and 'X' not in arr[i]: return 'O won' # 세로 판단을 위한 리스트 생성 col = [arr[j][i] for j in range(4)] if '.' not in col and 'O' not in col: return 'X won' if '.' not in col and 'X' not in col: return 'O won' # 우상단 대각선 판단 rUp = [arr[i][i] for i in range(4)] if '.' not in rUp and 'O' not in rUp: return 'X won' elif '.' not in rUp and 'X' not in rUp: return 'O won' # 좌상단 대각선 판단 lUP = [arr[i][3-i] for i in range(4)] if '.' not in lUP and 'O' not in lUP: return 'X won' elif '.' not in lUP and 'X' not in lUP: return 'O won' # 그밖의 경우. for i in range(4): for j in range(4): if arr[i][j] == '.': return 'Game has not completed' return 'Draw' N = int(input()) for T in range(N): arr = [list(input()) for _ in range(4)] if T \u003c N-1: _ = input() print(f'#{T+1} {check()}') # T의 숫자를 고려하는 것에 애먹었으나, # 문제에 T는 최대 1개로 설정. # 즉, T의 숫자를 별도로 카운트 하지 않아도 됨. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:0","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15649_N과 M (1) N, M = map(int, input().split()) def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() visited[i] = False num_list = [i + 1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:1","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15650_N과 M (2) import sys def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() for j in range(i+1, N): visited[j] = False N, M = map(int, sys.stdin.readline().split()) num_list = [i+1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:2","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1258_행렬찾기 def check(x, y): dx, dy = 0, 0 while x + dx \u003c N and arr[x+dx][y]: dx += 1 while y + dy \u003c N and arr[x][y+dy]: dy += 1 result.append([dx*dy, dx, dy]) for i in range(x, x+dx): for j in range(y, y+dy): arr[i][j] = 0 for T in range(int(input())): N = int(input()) arr = [list(map(int, input().split())) for _ in range(N)] result = [] for i in range(N): for j in range(N): if arr[i][j] != 0: check(i, j) aws = sorted(result, key=lambda x: [x[0], x[1]]) print(f'#{T+1} {len(aws)}', *[str(i[1]) + ' ' + str(i[2]) for i in aws]) # DFS로 구현해보려 했는데. # 내가 원하는 위치값을 반환하고 바로 종료시키는 것이 # 불가능해서. 최소한의 값인 가로 세로 이동값만을 뽑아 # 정리하였다. # 마지막에 정렬이 더 복잡했다.. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1249_보급로 from collections import deque dx = [0,1,0,-1] dy = [1,0,-1,0] for T in range(int(input())): N = int(input()) arr = [list(map(int, input())) for _ in range(N)] visited = [[float('inf') for _ in range(N)] for _ in range(N)] visited[0][0] = arr[0][0] q = deque([[0, 0]]) while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0 \u003c= cx \u003c N and 0 \u003c= cy \u003c N: Sum = visited[x][y] + arr[cx][cy] if visited[cx][cy] \u003e Sum: visited[cx][cy] = Sum q.append([cx, cy]) print(f'#{T+1} {visited[N-1][N-1]}') # DFS로 구현해보려 했지만, 특정 위치에 왔을 때 종료를 # 구현하는데 어려움이 있어, BFS로 바꾸어 구현. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1238_Contact from collections import deque for T in range(10): N, S = map(int, input().split()) node = list(map(int, input().split())) arr = [[] for _ in range(N)] for i in range(0, N, 2): arr[node[i]].append(node[i+1]) visited = [0] * (N+1) visited[S] = 1 q = deque([S]) while q: v = q.popleft() step = visited[v] for i in arr[v]: if visited[i] == 0: q.append(i) visited[i] = step + 1 for j in range(N+1): if visited[j] == step: result = j print(f'#{T+1} {result}') ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_4261_빠른 휴대전화 키패드 anycall = {'2':\"abc\", '3': \"def\", '4':\"ghi\", '5':\"jkl\", '6':\"mno\", '7':\"pqrs\", '8':\"tuv\", '9':\"wxyz\"} for T in range(int(input())): S, N = map(int, input().split()) words = list(input().split()) result = 0 for x in range(len(words)): count = 0 for i, j in enumerate(str(S)): a = words[x][i] b = anycall[j] if words[x][i] in anycall[j]: count += 1 else: break if count == len(str(S)): result += 1 else: count = 0 print(f'#{T+1} {result}') # 비교적 쉬운 문제. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"1021_회전하는 큐 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = deque([i for i in range(1, N+1)]) poplist = deque(list(map(int, sys.stdin.readline().split()))) count = 0 while poplist: try: if arr[0] == poplist[0]: arr.popleft() poplist.popleft() L = len(arr) a = abs(arr.index(arr[0]) - arr.index(poplist[0])) b = L - a if a \u003c b: arr.rotate(-a) count += a elif a \u003e= b: arr.rotate(b) count += b except IndexError: break print(count) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"5430_AC import sys from collections import deque for T in range(int(sys.stdin.readline().rstrip())): P = sys.stdin.readline().rstrip() N = int(sys.stdin.readline().rstrip()) ## 다양하게 input 받는 거 고민하기 좋다. arr = deque(list(sys.stdin.readline().rstrip()[1:-1].split(\",\"))) if N == 0 or len(arr) == 0: arr = deque([]) reverse = False error = False for i in P: if i == \"R\": reverse = not reverse elif i == \"D\": if len(arr) == 0: error = True break if reverse: arr.pop() else: arr.popleft() if error: print(\"error\") else: if reverse: arr.reverse() print(\"[\", end=\"\") print(\",\".join(arr), end=\"\") print(\"]\") ## reverse() 여러번 돌리면 시간초과 뜬다. # flag = True # for i in P: # if i == \"R\": # arr.reverse() # else: # if len(arr) != 0: # arr.popleft() # else: # print(\"error\") # flag = False # break # if flag: # if len(arr) != 0: # print(\"[\", end=\"\") # print(\",\".join(arr), end=\"\") # print(\"]\") # else: # print('error') ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"10866_덱 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque() for i in range(N): command = sys.stdin.readline().split() if command[0] == \"push_front\": q.appendleft(command[1]) elif command[0] == \"push_back\": q.append(command[1]) elif command[0] == \"pop_front\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"pop_back\": if q: print(q.pop()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"18258_큐 2 import sys from collections import deque # import time N = int(sys.stdin.readline().rstrip()) # start = time.time() # 시작 시간 저장 q = deque() for _ in range(N): command = sys.stdin.readline().split() if command[0] == \"push\": q.append(command[1]) elif command[0] == \"pop\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) # print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"2164_카드2 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque([i+1 for i in range(N)]) while len(q) != 1: q.popleft() q.append(q.popleft()) print(q[0]) ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"11866_요세푸스 문제 0 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) q = deque([i+1 for i in range(N)]) result = [] while q: q.rotate(-K+1) result.append(q.popleft()) print(\"\u003c\", end=\"\") for i in range(N): if i != N-1: print(result[i], end=\", \") else: print(result[i], end=\"\") print(\"\u003e\") ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"1966_프린터 큐 import sys from collections import deque for T in range(int(input())): N, M = map(int, sys.stdin.readline().split()) q = deque(map(int, sys.stdin.readline().split())) idx = deque([0 for i in range(N)]) idx[M] = 1 count = 0 while True: if q[0] == max(q): count += 1 if idx[0] == 1: print(count) break else: q.popleft() idx.popleft() else: q.append(q.popleft()) idx.append(idx.popleft()) # 큐를 사용하는 알고리즘을 고민하는데 # 아주 좋은 문제!! ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:4","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:0","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"4949_균형잡힌 세상 import sys while True: text = sys.stdin.readline().rstrip() if text == \".\": break stack =[] result = \"yes\" for i in text: if i.isalpha() or i == \" \": continue elif i == \"(\" or i == \"[\": stack.append(i) elif i == \")\": if not stack or stack[-1] != \"(\": result = \"no\" break else: stack.pop() elif i == \"]\": if not stack or stack[-1] != \"[\": result = \"no\" break else: stack.pop() if not stack: print(result) else: print('no') ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:1","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"10828_스택 import sys stack = [] commands = [] for i in range(int(sys.stdin.readline().rstrip())): commands.append(sys.stdin.readline().rstrip().split()) for command in commands: if command[0] == \"push\": stack.append(int(command[1])) elif command[0] == \"pop\": if stack: print(stack.pop()) else: print(-1) elif command[0] == \"size\": print(len(stack)) elif command[0] == \"empty\": if stack: print(0) else: print(1) elif command[0] == \"top\": if stack: print(stack[len(stack)-1]) else: print(-1) ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:2","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"1874_스택 수열 import sys N = int(sys.stdin.readline().rstrip()) Numbers = [i for i in range(1, N+1)] Sequence = [] for i in range(N): v = int(sys.stdin.readline().rstrip()) Sequence.append(v) result = \"\" stack = [] ans = [] for i in range(N): if stack and stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" elif not Numbers: while stack: ans.append(stack.pop()) break elif Numbers[0] \u003c= Sequence[i]: try: while Numbers[0] \u003c= Sequence[i]: stack.append(Numbers.pop(0)) result += \"+\" ans.append(stack.pop()) result += \"-\" except IndexError: if stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" continue if ans == Sequence: for i in result: print(i) else: print(\"NO\") # 뭔가 좀 지저분해보이지만.. # 입력받은 수열의 요소 마다 검증을 하고 싶었고 # 각 요소마다 진행사항을 등록하고 싶었다. # 예를 들어) 수열의 첫 번재 '4'가 나오기 위해선. # 1,2,3,4가 스택에 들어갔다가 마지막 4가 출력되면 된다. # 이런 과정을 코딩하고 싶었다. # 인터넷에 있는 까리한 코딩과 비교해봤는데. # 다행이 내 코드가 속도면에서 우위를 점했다. # 메모리는 졌음. ㅎ ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:3","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"17298_오큰수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) NGE = [-1] * N stack = [0] i = 1 while stack and i \u003c N: while stack and arr[stack[-1]] \u003c arr[i]: NGE[stack[-1]]= arr[i] stack.pop() stack.append(i) i += 1 print(*NGE) # stack에 arr의 인덱스를 저장(비교 기준 설정) # i로 비교할 인덱스를 지정해 비교 # stack에 0 저장 # i = 1 즉, arr[1] = 5를 stack에 저장되어있는 # 인덱스값(arr[0])과 비교 NGE라면 arr[i]을 NGE에 저장 # 이게 왜 빠른건지 잘 모르겠다. ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:4","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:0","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1037_약수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) Max = max(arr) Min = min(arr) print(Max*Min) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:1","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1934_최소공배수 import sys def GCD(a, b): while b != 0: m = a % b a = b b = m return a for T in range(int(sys.stdin.readline().rstrip())): A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:2","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"2609_최대공약수와 최소공배수 import sys def GCD(a, b): #최대공약수(유클리드 호제법) while b != 0: m = a % b a = b b = m return a A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(gcd) print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:3","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"5086_배수와 약수 import sys while True: a, b = map(int, sys.stdin.readline().split()) if a == 0 and b == 0: break if b % a == 0: print(\"factor\") elif a % b == 0: print(\"multiple\") elif a % b != 0 and b % a != 0: print(\"neither\") ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:4","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:0","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1931_회의실 배정 import sys N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] schedule = sorted(arr, key=lambda x: (x[1], x[0])) count, end = 0, 0 for s, f in schedule: if s \u003e= end: count += 1 end = f print(count) # 왠지 정렬을 잘하면 계산이 쉬울 것 같아서. # 시작시간과 종료시간을 정렬해 계산했는데 # 1. 종료시간, 2. 시작시간 순위로 정렬해야 했다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:1","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"11399_ATM import sys N = int(sys.stdin.readline().rstrip()) TT = list(map(int, sys.stdin.readline().split())) TT = sorted(TT) result = 0 for i, v in zip(range(N, -1, -1), TT): result += i*v print(result) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:2","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1541_잃어버린 괄호 import sys text = list(sys.stdin.readline().rstrip().split('-')) Nums = [] for N in text: n = sum(list(map(int, N.split(\"+\")))) Nums.append(n) result = 0 for i in range(len(Nums)): if i != 0: result -= Nums[i] else: result += Nums[i] print(result) # 55-50+40 경우 결국 - 뒤에 +는 모두 묶어주면 된다. # 예를 들어 55-50+40-30+49 경우 # 55-(50+40)-(30+49) 가 정답이 된다. # 즉 55 / 50+40 / 30+49 로 나누고 # 첫 인자를 제외한 나머지의 합을 빼주면 된다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:3","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"13305_주유소 import sys N = int(sys.stdin.readline().rstrip()) distance = list(map(int, sys.stdin.readline().split())) #d 2 3 1 price = list(map(int, sys.stdin.readline().split())) #p 5 2 4 1 total = 0 Min = sys.maxsize for i in range(N-1): if i == 0: total += price[0]*distance[0] Min = min(Min, price[0]) else: Min = min(Min, price[i]) total += Min*distance[i] print(total) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:4","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1226_미로1 dx = [0,1, 0, -1] dy = [1,0, -1, 0 ] def IsSafe(x, y): if 0\u003c= x \u003c 16 and 0 \u003c= y \u003c 16: return True def DFS(x, y): global result visited[x][y] = 1 if arr[x][y] == 3: result = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] != 1: DFS(nx, ny) def Find_Start(): for i in range(16): for j in range(16): if arr[i][j] == 2: return i, j for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(16)] visited = [[0 for _ in range(16)] for _ in range(16)] x, y = Find_Start() result = 0 DFS(x, y) print(f'#{T+1} {result}') # 재귀를 사용할 시 return은 불편한 점이 많다. # 하여 특정 조건에서의 값이 필요한 경우. # 변수를 설정해서 그 값을 바꾸는 편이 간편하다. # 다만 런타임에 조심해야 한다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1227_미로2 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] def IsSafe(x, y): if 0\u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(100)] visited = [[0 for _ in range(100)] for _ in range(100)] result = 0 q = deque([[1, 1]]) while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if arr[nx][ny] == 3: result = 1 break if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] == 0: q.append([nx, ny]) if result: break print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1231_중위순회 def DFS(i): global result if i \u003c= N: DFS(i*2) result += words[i] DFS(i*2+1) for T in range(10): N = int(input()) words = [0] * (N+1) for i in range(N): command = input().split() words[int(command[0])] = command[1] result = \"\" DFS(1) print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_5643_키 순서 def DFSF(x, i): for j in arrF[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSF(x, j) def DFSB(x, i): for j in arrB[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSB(x, j) for T in range(int(input())): N = int(input()) M = int(input()) arrF = [[] for _ in range(N+1)] arrB = [[] for _ in range(N+1)] arr = [[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(M): a, b = map(int, input().split()) arrF[a].append(b) arrB[b].append(a) for i in range(1, N+1): x = i DFSF(x, i) DFSB(x, i) count = 0 for i in arr: if sum(i) == N-1: count += 1 print(f'#{T+1} {count}') # 화살표 방향대로의 F # 화살표 반대방향의 B # 앞으로 진행시(F방향) 알 수 있는 위치를 arr에 저장하고 # 반대로 진행시(B방향) 알 수 있는 위치를 arr에 저장했을 때 # 다른 노드의 위치를 모두 확인할 수 있는 노드만이 본인의 위치를 # 알 수 있게 된다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1218_괄호 짝짓기 def Pair_bracket(): for i in range(L): if q[i] in check: ni = i - 1 while True: if q[ni] == 0: ni -= 1 else: break a = q[ni] b = check[q[i]] if a == b: q[i] = 0 q[ni] = 0 else: return 0 return 1 check = {\")\" :\"(\", \"]\":\"[\", \"}\":\"{\", \"\u003e\":\"\u003c\"} for T in range(10): L = int(input()) q = list(input()) print(f'#{T+1} {Pair_bracket()}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1219_길찾기 from collections import deque def BFS(): visited[0] = 1 while q: a = q.popleft() if a == 99: return 1 if visited[a] == 0: for i in range(len(arr[a])): q.append(arr[a][i]) visited[a] = 1 return 0 for _ in range(10): T, N = map(int, input().split()) arr = [[] for _ in range(100)] route = list(map(int, input().split())) visited = [0 for _ in range(100)] for i in range(0, N*2, 2): arr[route[i]].append(route[i+1]) q = deque() for i in range(len(arr[0])): q.append(arr[0][i]) print(f'#{T} {BFS()}') # 빈 2차원 리스트 만드는 법 # [[] * 100] 은 안됨 # [[] for _ in range(N)] 으로 생성 ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1222_계산기1 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. total = 0 for i in text: if i == \"+\": continue total += int(i) print(f'#{T+1} {total}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1223_계산기2 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. aws = [] idx = [] for i in range(L): if i in idx: continue if text[i] in \"0123456789\": aws.append(int(text[i])) elif text[i] == \"*\": aws[-1] = aws[-1]*int(text[i+1]) idx.append(i+1) print(f'#{T+1} {sum(aws)}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:0","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["BEAKJOON"],"content":"1918_후위 표기식 import sys from collections import deque text = sys.stdin.readline().rstrip() # 후위 표기법 알고리즘 operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = deque() result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() print(result) ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:1","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6959_이상한 나라의 덧셈게임 for T in range(int(input())): N = input() result = [\"A\", \"B\"] turn = 1 while len(N) \u003e 1: N = str(int(N[0]) + int(N[1])) + N[2:] turn += 1 print(f'#{T+1} {result[turn%2]}') # 단순 산수 ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_4613_러시아 국기 같은 깃발 for T in range(int(input())): N, M = map(int, input().split()) a = [input() for _ in range(N)] result = N * M for i in range(1, N - 1): for j in range(1, N - i): count = 0 for x in range(N): if 0 \u003c= x \u003c i: count += M - a[x].count('W') elif i \u003c= x \u003c i + j: count += M - a[x].count('B') else: count += M - a[x].count('R') if result \u003e count: result = count print(f'#{T+1} {result}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6109_추억의 2048게임 from collections import deque def turn(): tmp = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): tmp[i][j] = arr[N-1-j][i] return tmp def push(): for y in range(N): q = deque([]) for x in range(N): if arr[x][y] != 0: q.append(arr[x][y]) arr[x][y] = 0 i = 0 while q: if len(q) \u003e= 2: a, b = q.popleft(), q.popleft() if a == b: arr[i][y] = a+b else: arr[i][y] = a q.appendleft(b) i += 1 else: arr[i][y] = q.popleft() direction = {'up': (0, 0), 'left': (1, 3), 'down': (2, 2), 'right': (3, 1)} for T in range(int(input())): N, S = input().split() N = int(N) arr = [list(map(int, input().split())) for _ in range(N)] Front, Back = direction[S] for i in range(Front): arr = turn() push() for i in range(Back): arr = turn() print(f'#{T+1}') for i in arr: print(*i) # 하... 너무 오래 걸렸다. # 방향 전환이 싫어서 U, D, R, L를 # 각각 구현해봤으나.. 실패하고. # 수정해야 할 것도 너무 많아지고.. # 방향 전환 구현하니까.. 이리 저리 돌리는 숫자 # 생각하는데 또 오래 걸리고...ㅎ ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_1211_Ladder2 dx = [0, 0, 1] dy = [1, -1, 0] def IsSafe(x, y): if 0 \u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True def DFS(x, y): global distance if x == 99: return distance visited[x][y] = 1 for i in range(3): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and arr[nx][ny] == 1 and visited[nx][ny] == 0: distance += 1 DFS(nx, ny) return distance # 런타임 오류 방지로 재귀를 빠져나올 때 무조건 리턴. for _ in range(10): T = int(input()) arr = [list(map(int, input().split())) for _ in range(100)] Min = 10000 Midx = 0 for y in range(100): if arr[0][y] == 1: visited = [[0]* 100 for _ in range(100)] distance = 0 v = DFS(0, y) if v \u003c= Min: Min = v Midx = y print(f'#{T} {Midx}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2156_포도주 시식 N = int(input()) wine = [0 for _ in range(N)] total = [0 for _ in range(N)] for i in range(N): wine[i] = int(input()) if N == 1: total[0] = wine[0] else: total[0] = wine[0] total[1] = wine[0] + wine[1] for i in range(2, N): total[i] = max(total[i-1], total[i-2] + wine[i], total[i-3] + wine[i] + wine[i-1]) print(total[N-1]) # N == 1인 경우를 생각하지 않았을 땐 런타임 오류에 걸렸었다. # 그리고 그걸 생각하는데 오래 걸렸다. ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2565_전깃줄 n = int(input()) line = [list(map(int, input().split())) for _ in range(n)] line.sort(key=lambda x: x[0]) # 앞 숫자 기준, 오름차순 정리 arr = [0] * 501 for s, e in line: arr[e] = max(arr[:e]) + 1 print(n - max(arr)) # dp를 활용해 e에 겹쳐지지 않은 줄의 수를 기록 # s는 오름차순으로 정렬해 검증함으로 겹쳐지는 것을 # 신경 쓰지 않아도 ok ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"10844_쉬운 계단 수 # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"9251_LCS # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"1912_연속합 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) result = [arr[0]] for i in range(N-1): result.append(max(result[i]+arr[i+1], arr[i+1])) print(max(result)) # dp 연습하기 좋은 문제 ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"9184_신나는 함수 실행 def w(a,b,c): if a \u003c= 0 or b \u003c= 0 or c \u003c= 0: return 1 if a \u003e 20 or b \u003e 20 or c \u003e 20: return w(20, 20, 20) if dp[a][b][c]: return dp[a][b][c] if a \u003c b and b \u003c c: dp[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) return dp[a][b][c] dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return dp[a][b][c] dp = [[[0]*21 for _ in range(21)] for _ in range(21)] while True: a, b, c = map(int, input().split()) if a == -1 and b == -1 and c == -1: break print(f'w({a}, {b}, {c}) = {w(a, b, c)}') # 갑자기 난이도가 높아진듯.. # 3차원 dp까지는 어찌저찌 고안했으나 # if dp[a][b][c]: # return dp[a][b][c] # 를 어디에 넣어야 할지 고민하는데 # 시간을 소요. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11053_가장 긴 증가하는 부분 수열 n = int(input()) a = list(map(int, input().split())) dp = [0 for i in range(n)] for i in range(n): for j in range(i): if a[i] \u003e a[j] and dp[i] \u003c dp[j]: dp[i] = dp[j] dp[i] += 1 print(max(dp)) ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11054_가장 긴 바이토닉 부분 수열 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) idp = [0 for _ in range(N)] ddp = [0 for _ in range(N)] result = [0 for _ in range(N)] for i in range(N): for j in range(i): if arr[i] \u003e arr[j] and idp[i] \u003c idp[j]: idp[i] = idp[j] idp[i] += 1 for i in range(N-1, -1, -1): for j in range(N-1, i, -1): if arr[i] \u003e arr[j] and ddp[i] \u003c ddp[j]: ddp[i] = ddp[j] ddp[i] += 1 result[i] = ddp[i] + idp[i] -1 print(max(result)) # 11053을 풀어본 뒤에 도전하면 할만하다. # range()를 거꾸로 돌리는데 살짝 애를 먹음. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5678_[Professional] 팰린드롬 for T in range(int(input())): S = \" \" + input() L = len(S) result = 1 for i in range(2, L): for j in range(L-i): if S[j+1:j+i+1] == S[j+i:j:-1]: result = i print(f'#{T+1} {result}') # 슬라이싱을 잘 고민 하면 쉽게 해결 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5672_[Professional] 올해의 조련사 for T in range(int(input())): q = [] n = \"\" for N in range(int(input())): q.append(input()) S = 0 L = N while S != L: if q[S] \u003c q[L]: n += q[S] S += 1 elif q[S] \u003e q[L]: n += q[L] L -= 1 else: W = int((L-S)//2) for i in range(W): flag = True c = q[S+i+1] d = q[L-(i+1)] if c == d: continue elif c \u003c d: n += q[S] S += 1 flag = False break elif c \u003e d: n += q[L] L -= 1 flag = False break if flag: n += q[S] S += 1 n += q[L] print(f'#{T+1} {n}') # 조건은 다 쉬웠으나, 검사하는 횟수?에 착각을해 # 생각보다 시간이 많이 걸린 문제 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7465_창용 마을 무리의 개수 def DFS(x): visited[x] = 1 for i in range(1, N+1): if arr[x][i] == 1 and visited[i] == 0: DFS(i) for T in range(int(input())): N, M = map(int, input().split()) arr = [[0 for _ in range(N+1)] for _ in range(N+1)] visited = [0 for _ in range(N+1)] for i in range(M): x, y = map(int, input().split()) arr[x][y] = 1 arr[y][x] = 1 count = 0 for i in range(1, N+1): if visited[i] == 0: DFS(i) count += 1 print(f'#{T+1} {count}') # 양방향입니다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7701_염라대왕의 이름 정렬 for T in range(int(input())): N = int(input()) S = set() for i in range(N): s = input() S.add(s) A = sorted(S, key=lambda x: (len(x), x)) print(f'#{T+1}') for j in A: print(j) # set 자료형도 sorted를 진행하면 # 자동으로 list type으로 변한다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10761_신뢰 from collections import deque for T in range(int(input())): command = deque(input().split()) N = command.popleft() B = deque() O = deque() order = deque() while command: i = command.popleft() if i == \"B\": B.append(int(command.popleft())) order.append(\"B\") else: O.append(int(command.popleft())) order.append(\"O\") count = 0 b, o = 1, 1 while True: if not order: break count += 1 BP = \"안눌림\" if B: if B[0] \u003e b: b += 1 elif B[0] == b and order[0] == \"B\": B.popleft() order.popleft() BP = \"눌림\" elif B[0] \u003c b: b -= 1 if O: if O[0] \u003e o: o += 1 elif O[0] == o and order[0] == \"O\" and BP == \"안눌림\": O.popleft() order.popleft() elif O[0] \u003c o: o -= 1 print(f'#{T+1} {count}') # 주어진 순서대로 버튼을 눌러야 한다!!! # 첫번째 테스트의 경우 O에 1이 있으나, B2가 눌리기를 기다려야 한다. # order 리스트가 필요한 이유 ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10804_문자열의 거울상 for T in range(int(input())): S = input() L = len(S) result = \"\" for i in range(L-1, -1, -1): if S[i] == \"b\": result += \"d\" elif S[i] == \"d\": result += \"b\" elif S[i] == \"q\": result += \"p\" else: result += \"q\" print(f'#{T+1} {result}') ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10912_외로운 문자 from collections import Counter for T in range(int(input())): S = Counter(input()).most_common() R = \"\" for i in S: if i[1] % 2 == 1: R += i[0] result = sorted(R) if len(result) == 0: print(f'#{T+1} Good') else: result2 = \"\" for i in result: result2 += i print(f\"#{T+1} {result2}\") # Counter와 .most_common 은 유용하다. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10965_제곱수 만들기 P = [2] for i in range(3,3162,2): for q in P: if i % q == 0: break else: P.append(i) ans = [] for T in range(int(input())): N = int(input()) result, n = 1, N for v in P: count = 0 if n == 1 or v \u003e N: break while n % v == 0: n //= v count += 1 if count % 2 != 0: result *= v if n \u003e 1: result *= n ans.append(f'#{T+1} {result}') for i in ans: print(i) # 에라토스테네스 체를 이용해 소수를 구했고 # root(10000001**0.5) 보다 큰 소수의 경우 # 소인수 분해를 하고 나서도 n != 1 수 있다. # 하여 소인수분해를 마치고도 n \u003e 1면 # result에 곱해주었다. # 속도와 n이 root보다 큰 경우가 있다는 것을 깨닫는데 # 오랜시간이 걸렸던 문제. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:0","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"2178_미로탐색 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 1 and visited[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N, M = map(int, sys.stdin.readline().split()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0]*(M) for _ in range(N)] q = deque([[0, 0]]) BFS() print(arr[N-1][M-1]) # pop을 사용하는데 리스트형태의 자료인 경우 # x, y = [1, 2]의 모습으로도 추출이 가능 ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:1","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"7576_토마토 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 def result(): global Max for x in range(N): for y in range(M): if arr[x][y] == 0: print(-1) return if arr[x][y] \u003e Max: Max = arr[x][y] print(Max-1) return dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] M, N = map(int, sys.stdin.readline().split()) # M: 6, N: 4 arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] q = deque() for x in range(N): for y in range(M): if arr[x][y] == 1: q.append([x, y]) BFS() Max = 0 result() # 어떻게 하면 출발점이 2개 이상일 때 # 두 지점에서 동시에 출발해 토마토가 익는 것을 # 판단할 수 있을까에 대한 고민이 1시간.. # 초기 코딩 # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() # 한 시간 후... # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:2","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"1697_숨바꼭질 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) arr = [0] * 30 q = deque([N]) def BFS(): while q: v = q.popleft() if v == K: return print(arr[v]) for i in [v-1, v+1, v*2]: if 0 \u003c= i \u003c 30 and arr[i] == 0: arr[i] = arr[v] + 1 q.append(i) BFS() # 긴 방문 리스트를 만들어 놓고 # 수빈이가 기준점에서 부터 갈 수 있는 장소의 걸음수를 등록한다. # ex) # 위지 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 걸음1: 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 # 걸음2: 0 0 0 2 1 2 0 0 0 2 0 0 0 0 0 0 0 5(기준)에서 갈 수 있는 위치 # 걸음3: 0 0 3 2 1 2 0 3 0 2 0 0 0 0 0 0 0 4(기준)에서 갈 수 있는 위치 # 걸음4: 0 0 3 2 1 2 3 3 0 2 0 3 0 0 0 0 0 6(기준)에서 갈 수 있는 위치 # 걸음5: 0 0 3 2 1 2 3 3 3 2 3 0 0 0 0 0 0 ..3 10(기준)에서 갈 수 있는 위치 # 요런 식으로 진행하면 된다. ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:3","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:0","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1260_DFS와 BFS import sys from collections import deque def DFS(V): print(V, end=' ') DFSv[V] = 1 for i in range(1, N+1): if DFSv[i] == 0 and tree[V][i] == 1: DFS(i) return def BFS(V): q = deque([V]) BFSv[V] = 1 while q: p = q.popleft() print(p, end=\" \") for i in range(1, N+1): if BFSv[i] == 0 and tree[p][i] == 1: q.append(i) BFSv[i] = 1 return N,M,V = map(int, sys.stdin.readline().split()) tree = [[0]*(N+1) for _ in range(N+1)] DFSv = [0 for _ in range(N+1)] BFSv = [0 for _ in range(N+1)] for _ in range(M): S, E = map(int, sys.stdin.readline().split()) tree[S][E] = 1 tree[E][S] = 1 DFS(V) print() BFS(V) # 기초가 제일 중요하다. # 혹시 DFS, BFS가 막힐 땐 이 문제를 다시 풀어보자 ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:1","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2606_바이러스 import sys C = int(sys.stdin.readline().rstrip()) No = int(sys.stdin.readline().rstrip()) arr = [[0 for _ in range(C+1)] for _ in range(C+1)] vistied = [0 for _ in range(C+1)] count = 1 for _ in range(No): S, E = map(int, sys.stdin.readline().split()) arr[S][E] = 1 arr[E][S] = 1 def DFS(V): global count vistied[V] = 1 for i in range(1, C+1): if vistied[i] == 0 and arr[V][i] == 1: vistied[i] = 1 count += 1 DFS(i) DFS(count) print(count-1) ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:2","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2667_단지번호붙이기 import sys def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c N: return True def DFS(x, y, c): global count visited[x][y] = 1 if arr[x][y] == 1: count += 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy, c) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0 for _ in range(N)] for _ in range(N)] result = [] count = 0 # AP 단지안에 건물 숫자 for x in range(N): for y in range(N): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y, count) result.append(count) count = 0 result.sort() print(len(result)) for i in result: print(i) # DFS의 나만의 규칙 # 1. 새로운 노드에 접근하자마자 방문을 표시한다. # 2. isSafe를 만들어 범위를 확인한다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:3","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1012_유기농 배추 import sys # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def DFS(x, y): visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] result = [] for T in range(int(sys.stdin.readline().rstrip())): M, N, K = map(int, sys.stdin.readline().split()) # M 가로, N 세로, K 배추갯수 arr = [[0 for _ in range(M)] for _ in range(N)] visited = [[0]*(M) for _ in range(N)] for i in range(K): y, x = map(int, sys.stdin.readline().split()) arr[x][y] = 1 count = 0 for x in range(N): for y in range(M): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y) count += 1 result.append(count) for i in result: print(i) # 초기 풀이는 런타임 에러가 발생했다. # 하여 결과값을 모았다가 출력하면 속도 증가가 가능하기에 # result = []에 답을 모았다가 출력해보았지만, # 런타임 에러 발생.. # 검색해보니 # sys.setrecursionlimit(50000) 이런 것이 있다는 것을 봤고 # 추가해주니 통과 되었다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:4","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:0","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10989_수 정렬하기3 import sys # 시간 초과 # from collections import deque # # result = deque() # for T in range(int(sys.stdin.readline().rstrip())): # n = int(sys.stdin.readline().rstrip()) # if len(result) != 0: # for i in range(len(result)): # if result[i] \u003e n: # result.insert(i, n) # break # else: # result.append(n) # for i in result: # print(i) # 속도엔 DP지. arr = [0] * 10001 for T in range(int(sys.stdin.readline().rstrip())): n = int(sys.stdin.readline().rstrip()) arr[n] += 1 for i in range(10001): if arr[i] != 0: for j in range(arr[i]): print(i) ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:1","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"11650_좌표 정렬하기 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for _ in range(T): x, y = map(int, sys.stdin.readline().split()) L.append((x, y)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][1]}') # sorted는 여러 그룹의 값이 주어진 경우 # 순차적으로 증감을 비교해 준다. # ex) # A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] # A = sorted(A) # print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:2","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"2108_통계학 import sys from collections import deque, Counter result = deque() T = int(sys.stdin.readline().rstrip()) for _ in range(T): result.append(int(sys.stdin.readline().rstrip())) result = sorted(result) def Am(): return round(sum(result)/T) def Me(): return result[int(T//2)] def Mo(): MoResult = Counter(result).most_common() # MoResult = [(-2, 1), (1, 1), (2, 1), (3, 1), (8, 1)] if len(MoResult) \u003e 1: if MoResult[0][1] == MoResult[1][1]: return MoResult[1][0] else: return MoResult[0][0] else: return MoResult[0][0] def Ra(): return result[-1] - result[0] print(Am()) print(Me()) print(Mo()) print(Ra()) # Counter 함수와 더 익숙해지면 좋을 것 같다. # ex) # from collections import Counter # MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() # print(MoResult) # [(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:3","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10814_나이순 정렬 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for i in range(T): age, name = sys.stdin.readline().split() L.append((int(age), i, name)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][2]}') ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:4","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:0","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"2798_블랙잭 import sys N, M = map(int, sys.stdin.readline().split()) cards = list(map(int, sys.stdin.readline().split())) result = 0 for i in range(N): for j in range(i+1, N): for x in range(j+1, N): if cards[i] + cards[j] + cards[x] \u003c= M: result = max(result, cards[i] + cards[j] + cards[x]) print(result) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:1","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"7568_덩치 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) # 내가 생각한 무식한 방법... W = deque() H = deque() for _ in range(N): x, y = sys.stdin.readline().split() W.append(x) H.append(y) for i in range(N): w = W.popleft() h = H.popleft() count = 0 for j in range(N-1): if W[j] \u003e w and H[j] \u003e h: count += 1 print(count+1, end=\" \") W.append(w) H.append(h) # 인터넷에 있던 멋진 방법 # li = deque() # for _ in range(N): # x, y = sys.stdin.readline().split() # li.append((x, y)) # for i in li: # count = 0 # for j in li: # if i[0] \u003c j [0] and i[1] \u003c j[1]: # count += 1 # print(count+1, end=\" \") # 하지만 내가 짠 코드가 더 빠르다. ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:2","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1018_체스판 다시 칠하기 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = [ list(sys.stdin.readline().rstrip()) for _ in range(N) ] result = deque() for i in range(N-7): for j in range(M-7): caseW = 0 # 시작(기준)점이 W 일 때 바뀌어야 하는 수 caseB = 0 # 시작(기준)점이 B 일 때 바뀌어야 하는 수 for x in range(i, i+8): for y in range(j, j+8): if (x+y) % 2 == 0: if arr[x][y] == \"B\": caseW += 1 if arr[x][y] == \"W\": caseB += 1 else: if arr[x][y] == \"W\": caseW += 1 if arr[x][y] == \"B\": caseB += 1 result.append(caseW) result.append(caseB) print(min(result)) # 체스판에 시작점이 W로 시작했을 때 바뀌어야 하는 수 # VS 시작점이 B로 시작했을 때 바뀌어야 하는 수를 # 비교해야 한다! ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:3","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1436_영화감독 숌 import sys N = int(sys.stdin.readline().rstrip()) X = 666 while N: if '666' in str(X): N -= 1 X += 1 print(X-1) # 666, 1666, 2666, 3666, 4666, 5666, 6661, 6662, 6663, 6664, 6665, 6667, 6668, 6669, 7666, 8666, 9666, 10666 ..... # 666이 첫 번째 수 인데 그다음 666이 들어간 수를 # 단순히 +1 하면서 찾는 것이다. # 당연히 런타임 오류일 줄 알았으나. 아니었다.(왜 아니지...) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:4","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:0","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10872_팩토리얼 import sys N = int(sys.stdin.readline().rstrip()) def fac(n): if n \u003e 1: return n * fac(n-1) else: return 1 print(fac(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:1","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10870_피보나치 수 5 import sys def fivo(n): if n \u003e= 2: return fivo(n-1) + fivo(n-2) else: return n N = int(sys.stdin.readline().rstrip()) print(fivo(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:2","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"2447_별 찍기 - 10 import sys n = int(sys.stdin.readline().rstrip()) def star(i, j): while(i != 0): if i % 3 == 1 and j % 3 == 1: sys.stdout.write(' ') return i //= 3 j //= 3 sys.stdout.write('*') for i in range(n): for j in range(n): star(i, j) sys.stdout.write('\\n') # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 재귀는 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:3","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"11729_하노이 탑 이동 순서 import sys N = int(sys.stdin.readline().rstrip()) def hanoi(N, s, m, e): if N == 1: print(s, e) else: hanoi(N-1, s, e, m) print(s, e) hanoi(N-1, m, s, e) Sum = 1 for i in range(N - 1): Sum = Sum * 2 + 1 print(Sum) hanoi(N, 1,2,3) # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:4","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:0","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"4948_베르트랑 공준 import sys while True: N = int(sys.stdin.readline().rstrip()) if N == 0: break arr = [0,0] + [1] * ((2*N)-1) rootN = int((2*N)**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, 2*N+1, i): arr[j] = 0 print(sum(arr[N+1:(2*N)+1])) # 입출력에 제한이 있다가 0을 입력 받을 때 까지 # 출력을 해야 하는 조건을 달지 않는 것을 주의! ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:1","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"9020_골드바흐의 추측 import sys # 무식한 방법....(당연히 런타임 에러) # def checkSum(): # dis = 10000 # rx = 0 # ry = 0 # for x in range(N+1): # if arr[x] == 1: # for y in range(x, N+1): # if arr[y] == 1: # if x + y == N: # dif = y - x # if dis \u003e dif: # dis = dif # rx = x # ry = y # return rx, ry for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) # 소수 찾기 arr = [0, 0] + [1]*(N-1) rootN = int(N**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, N+1, i): arr[j] = 0 # 확인해야 하는 값을 줄이기 위해, # a는 중앙에서 부터 1 방향으로 내려가고 # b는 중앙에서 N 까지 올라가며 검증 # 16을 예로 (0, 16) (1, 15) (2, 14) ... # 정대칭된 수를 더하면 16을 만들 수 있다. # 16 만들기로 (3, 13)을 제시할 수도 있지만, # 16의 중심값을 기준으로 비교하는 것이 두 수의 차이를 # 더 줄일 수 있는 방법이었다. a = N//2 b = a while a \u003e 0: if arr[a] and arr[b]: print(a, b) break else: a -= 1 b += 1 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:2","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"3053_택시 기하학 import sys, math n = int(sys.stdin.readline().rstrip()) print(n**2*math.pi) # 유클리드 기하학 print(n**2*2) # 택시 기하학 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:3","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"1002_터렛 for T in range(int(input())): x1, y1, r1, x2, y2, r2 = map(int, input().split()) distance = (((x1 - x2) ** 2) + ((y1 - y2) ** 2)) ** 0.5 if x1 == x2 and y1 == y2: if r1 == r2: print(-1) else: print(0) continue if r1 \u003e distance + r2 or r2 \u003e distance + r1 or distance \u003e r1 + r2: print(0) elif r1 == distance + r2 or r2 == distance + r1 or r1 + r2 == distance: print(1) else: print(2) ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:4","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:0","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"10250_ACM호텔 import sys for T in range(int(sys.stdin.readline().rstrip())): H, W, N = map(int, sys.stdin.readline().split()) quo = str((N // H) + 1) rem = str(N % H) if N % H == 0: quo = str(N//H) rem = str(H) print(rem+quo.zfill(2)) # zfill? # a = \"2\" # b = \"12\" # A = a.zfill(2) # B = b.zfill(2) # print(A) // 02 # print(B) // 12 ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:1","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2775_부녀회장이 될테야 import sys for T in range(int(sys.stdin.readline().rstrip())): floor = int(sys.stdin.readline().rstrip()) ho = int(sys.stdin.readline().rstrip()) floor0 = [_ for _ in range(1,ho+1)] for i in range(floor): for j in range(1, ho): floor0[j] += floor0[j-1] print(floor0[-1]) # 놀랍게도 print(floor0[j])로 제출하면 # 런타임 에러.... 변수를 사용하는 것 보다 # 인덱스로(슬라이싱?)을 사용해 접근하는 것이 더 빠른가보다. ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:2","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2869_달팽이는 올라가고 싶다 import sys A, B, V = map(int, sys.stdin.readline().split()) # 의식의 흐름에 따른 코딩 # day = 1 # posi = 0 # while True: # posi += A # if posi \u003e= V: # break # else: # posi -= B # day += 1 # print(day) # 의식을 차리고 난 후 코딩 print((V - B - 1) // (A - B) + 1) ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:3","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"1011_Fly me to the Alpha Centauri import sys for T in range(int(sys.stdin.readline().rstrip())): x, y = map(int, sys.stdin.readline().split()) distance = y - x if distance \u003c= 3: print(distance) else: sr = int(distance**0.5) if distance == sr**2: print(2*sr - 1) elif sr**2 \u003c distance \u003c= sr**2 + sr: print(2*sr) else: print(2*sr+1) # 일단 손으로 노가다를 해야 # 규칙이 보인다... ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:4","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:0","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"10809_알파벳찾기 import sys word = sys.stdin.readline().rstrip() alphabet = list(range(97,123)) for x in alphabet : print(word.find(chr(x)), end=\" \") # find함수는 조건에 맞는 값의 index를 출력하고 # 찾지 못하는 경우 -1을 출력한다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:1","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2941_크로아티아 알파벳 import sys cro = [\"c=\", \"c-\", \"dz=\", \"d-\", \"lj\", \"nj\", \"s=\", \"z=\"] s = sys.stdin.readline().rstrip() for i in cro: s = s.replace(i, \"*\") print(len(s)) ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:2","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2908_상수 import sys A, B = sys.stdin.readline().split() NA = int(A[::-1]) NB = int(B[::-1]) if NA \u003e NB : print(NA) else: print(NB) # 문자열 슬라이싱을 잘 활용하면 아주아주 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:3","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"1316_그룹 단어 체커 import sys N = int(sys.stdin.readline().rstrip()) for i in range(N): sent = sys.stdin.readline().rstrip() for j in range(1, len(sent)): if sent.find(sent[j-1]) \u003e sent.find(sent[j]): N -= 1 break print(N) # find함수도 잘 알아두면 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:4","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["Computer Science"],"content":"​ Process VS Thread 면접 질문에서 가장 많이 들어본 이야기라고 친구들이 이야기 해줬습니다. 근데 전 아직 자신있게 설명할 정도로 알지 못하기에 알아봅시다! ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:0:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"프로그램(Program)란 무엇인지 우선 알아봅시다. 소프트웨어의 한가지로, 어떤 문제를 해결하기 위하여 그 처리 방법과 순서(a.k.a ALGORITHM)를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체를 뜻합니다. 쉽게 말해, “어떤 작업을 위해 실행할 수 있는 파일”을 뜻합니다. 그리고 그 프로그램을 실행 시키는 주체를 인스턴스라고도 표현합니다. 예들 들어, Excel.exe, kakaotalk.exe 등과 같이 어떤 작업을 위해 실행할 수 있는 (설치 등)파일을 생각해 볼 수 있습니다. ​ ​ Process Process는 프로그램의 인스턴스(독립적인 개체)가 실행되어 메모리에 적재된 것을 말합니다. 조금 다르게 운영체제로부터 시스템 자원을 할당받는 자원의 크기라고도 말할 수 있습니다. 조금 간단하게는 “실행된 프로그램을 의미\"합니다. 앞서 운영체제로부터 할당을 받는다고 설명했는데 CPU의 시간 / 운영되기 위해 필요한 주소 공간 / Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역등이 대상입니다. ​ 즉, 프로그램을 실행하게 되면 CPU의 일정 용량?을 차지하면서 수행하는 주체가 Process입니다. 하여, 프로그램은 하나인데 Process는 여러 개가 동작할 수 있습니다. (==인스턴스가 여러 개) 예를 들어 엑셀을 사용하고 있는데, 새로 만들기로 엑셀창을 하나 더 열 수도 있겠죠? 여기서 엑셀 실행파일이 Program, 엑셀창이 Process입니다. 간단히 1개의 Program으로 2개의 Process를 동작시킨 것입니다. ​ 🙋‍♂️ 이제 프로세스(Process)의 특징에 대하여 좀 더 알아봅시다. 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받습니다. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. BUT 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용하면 가능해집니다. Ex) 파이프, 파일, 소켓통신, mapped file 등을 이용한 통신 방법 이용 ex) 실제로 엑셀의 경우 A엑셀파일, B엑셀파일이 있을 때, B의 특정 셀값을 A에서 불러와 사용할 수 있습니다. 즉, 프로세스간에 통신이 가능합니다. ​ ​ Thread 프로세스(Process) 내에서 실행되는 흐름의 단위으로 프로세스 하나에 자원을 공유하면서 일련의 과정, 여러 개를 동시에 실행시킬 수 있는 것을 말합니다. 기본적으로 하나의 프로세스가 생성되면 하나의 Thread가 같이 생성됩니다. 이를 Main Thread라고 부르며, thread를 추가로 생성하지 않는 한, 모든 프로그램 코드는 Main Thread에서 실행됩니다. ​ Multi Thread 그림을 보면 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유하고 ( Stack만 스레드 별로 가지게 됩니다. ) 하나의 프로세스는 여러 개의 스레드를 가질 수 있는데, 이를 Multi Thread라고 합니다. 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있습니다. ​ 🙋‍♂️ 다른 자원들은 공유하지만 굳이 스택만 분리해서 사용하는 이유는? LIFO(Last In First Out) / 후입 선출이라는 스택의 특성과도 연관이 있습니다. 왜냐하면? Code와 Data, Heap 영역을 공유하는 것에는 큰 문제가 없지만, 스택 영역은 스택이 쌓이면 위에서부터 프로세스가 섞인 채로 순서대로 나오게 되므로 더 복잡해지기 때문에 원활한 실행 흐름을 위해 스택은 따로 독립적으로 존재하게 됩니다. ​ ​ Multi Process 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것. 😆 장점 안정성이 좋음 - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않습니다. 😔 단점 Context Switching(여러 프로세스를 왔다 갔다 하는 것)에서의 오버헤드 Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됩니다. 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 합니다. 프로세스 사이의 어렵고 복잡한 통신 기법(IPC) ​ *오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. ​ ​ ​ 이런 단점들을 보완하기 위해 Multi Thread가 등장하였습니다. Multi Thread 하나의 프로세스 내에서 여러 개의 thread가 동작하는 것을 말합니다. 😆 장점 시스템 효율성이 향상됩니다. 프로세스에서 자원을 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 즉, 시스템의 자원 소모를 줄일 수 있습니다. 시스템 처리량이 증가 됩니다. 스레드 사이에 작업량이 작아 Context Switching이 빠릅니다. 결과적으로 프로그램 응답 시간이 단축됩니다. 프로세스 간 통신 방법에 비해 thread간의 통신 방법이 간단합니다. ✔ 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다. ✔ Context Switching시 스레드는 Stack 영역만 처리하기 때문 😔 단점 여러 개의 스레드를 이용하는 경우, 미묘한 시간차나 잘못된 변수를 공유함으로써 오류가 발생할 가능성이 있습니다. 하여 Thread-Safety하게 구현해야 합니다. ex) 스레드1이 공유 자원 내의 A데이터를 조작하다가, 스레드2에 제어권을 넘겨준 이후 스레드2가 A데이터를 변경한다면 스레드1이 다시 제어권을 받아 남은 작업을 계속할 때 원치 않는 결과가 나올 수 있다. 프로그램 디버깅이 어렵습니다. 단일 프로세스 시스템에서는 효과를 기대하기 어렵습니다. ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:1:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"Thread-Safety 스레드 안전(thread 安全, 영어: thread safety)은 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다. Re-entrancy(재진입성) 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. (동기화 잘 하라.) Mutual exclusion(상호 배제) 공유 자원을 꼭 사용해야 할 경우 해당 자원의 접근을 세마포어 등의 락으로 통제한다. (역시 동기화 잘 하라.ㅎ.) Thread-local storage(스레드 지역 저장소) 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. (글로벌 변수 등의 사용을 남발하지 말라.) Atomic operations(원자 연산) 공유 자원에 접근할 때 원자 연산을 이용하거나 ‘원자적’으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다. (역시 동기화 잘 하라는 건데, python 연산자를 예로 “+=“는 한줄의 코드 임에도 “+“를 한 후에 “=” 연산을 하기 때문에 원자적이라고 할 수 없다고 봅니다.) ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"부록 자바에서 동기화 방법 Synchronized Volatile Atomic Class ​ ​ 👀요약 운영체제는 Process 단위로 메모리를 할당해주고, 같은 프로세스 소속의 Thread는 메모리를 공유합니다. (스레드도 각자의 스택영역을 보유하므로 완전히 공유한다고 보기는 어렵습니다.) ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:1","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D3_3975_승률 비교하기 result = [] for T in range(int(input())): A, B, C, D = map(int, input().split()) if B/A \u003e D/C: result.append(\"BOB\") elif B/A \u003c D/C: result.append(\"ALICE\") else: result.append(\"DRAW\") for t in range(T+1): print(f\"#{t+1} {result[t]}\") # 아니 이게 D3라고? 완전 난이도 설정 실수네. 했다가 런타임 오류 보고 # 왜 그런건지 알았다. # python은 결과를 모았다가 출력하는 게 더 빠르다. ​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D2_5176_이진탐색 def makeTree(n): global count #Tree 범위 제한 if n \u003c= N: #1부터 시작한다고 가정했을 때 왼쪽노드는 현재 인덱스의 2배 makeTree(n*2) #더이상 못가면 값넣기 tree[n] = count #값 넣었으면 증가시키기 count += 1 #우측 노드는 인덱스 2배 + 1 makeTree(n*2 + 1) for T in range(int(input())): N = int(input()) tree = [0 for i in range(N+1)] count = 1 makeTree(1) print(f'#{T+1} {tree[1]} {tree[N//2]}') # 2020하반기 네이버 코테를 풀고 tree에 대하여 깊이있게 공부해봐야겠다고 생각하며 # 다시 처음부터 공부하는데, 미쳤다.ㅎ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["web","django","vue"],"content":"​ REST API Reference [TOC] ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:0:0","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.사용자 API Members Descriptions POST /accounts/signup 회원가입 POST /accounts/login 회원 로그인 POST /accounts/userDetail 회원정보 PUT /accounts/update 회원정보 수정 DELETE /accounts/dropUser 회원탈퇴 GET /accounts/emailAuth 이메일 인증 GET /accounts/emailCheck 이메일 중복 확인 GET /accounts/nicknameCheck 닉네임 중복 확인 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:0","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.1 회원 로그인 POST /accounts/login ​ 회원 로그인 API 입니다. ​ Request parameters Parameter Type Description email String 이메일 password String 비밀번호 ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:1","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.2 회원가입 POST /accounts/signup ​ 회원가입 API 입니다. ​ Request parameters Field Type Description password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail 1.2.1 이메일 중복확인 GET /accounts/emailCheck 회원가입시 이메일 중복확인하는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description result.data String 아이디사용가능 ​ Response (Fail) Field Type Description result.data String 아이디중복 1.2.2닉네임 중복확인 GET /accounts/nicknameCheck 회원가입시 닉네임중복확인하는 API 입니다. ​ Request parameters Field Type Description nickname String 닉네임 ​ Response(Success) Field Type Description result.data String 닉네임사용가능 ​ Response (Fail) Field Type Description result.data String 닉네임중복 1.2.3이메일 인증 GET /accounts/emailAuth 이메일 중복 확인시 이메일을 인증메일을 보내는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description dice int 이메일 인증 코드 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:2","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.3 회원 정보 수정 PUT /accounts/update 회원정보 수정 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 nickname String 닉네임 content String 자기소개 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:3","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.4 회원 정보 POST /accounts/userDetail 회원정보를 조회하는 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:4","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"1.5 회원탈퇴 DELETE /accounts/dropUser 회원 탈퇴 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:5","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.게시물 API Members Descriptions POST /articles/register 글 작성 GET /articles/showArticle 글 상세 조회 PUT /articles/modify 글 수정 DELETE /articles/dropArticle 글 삭제 POST /articles/like 글 좋아요 POST /articles/likedList 좋아요 게시물 리스트 GET /articles/searchArticle 글 검색 POST /articles/getRecommentList 음식점 추천 리스트 GET/articles/list 전체 글 리스트 POST /articles/postedList 사용자가 작성한 글 리스트 GET/articles/postedListByLikes 좋아요순 글 리스트 GET/articles/postedListByHits 조회순 글 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:0","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.1 글 작성 POST /articles/registe 글 작성 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:1","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.2 글 상세 조회 GET /articles/showArticle 글 상세조회하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String 조회 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:2","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.3 글 수정 PUT /articles/modify 글 수정하는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:3","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.4 글 삭제 DELETE /articles/dropArticle 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 삭제 성공 ​ Response (Fail) Field Type Description result.data String 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:4","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.5 글 좋아요 POST /articles/like 글 좋아요 올리거나 내리는 API 입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:5","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.6 좋아요 게시물 리스트 POST /articles/likedList 좋아요 누른 게시물을 리턴해주는 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data List Post객체의 리스트 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:6","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.7 글 검색 GET /articles/searchArticle 글 검색 API 입니다. ​ Request parameters Field Type Description keyword(path) String 검색어 ​ Response(Success) Field Type Description result.data HashMap 해쉬맵으로 검색결과를 리턴 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:7","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.8 음식점 추천 리스트 POST /articles/getRecommentList 음식점 추천 API입니다. ​ Request parameters Field Type Description food String 관련 태그를 ,로 연결하여 보내기 isCafe String 카페도 추천하면 추가 isDrink String 술집도 추천하면 추가 like String 피드백에서 좋아요수가 부족할때 watch String 피드백에서 조회수가 부족할때 star String 피드백에서 별점이 부족할때 ​ Response(Success) Field Type Description 음식 Post 추천하는 음식점 카페 Post 추천하는 카페 술집 Post 추천하느 술집 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:8","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.9 전체 글 리스트 GET /articles/list 전체 글을 받는 API입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:9","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.10 사용자가 작성한 글 리스트 POST /articles/postedList 사용자가 작성한 글의 리스트를 리턴해주는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result List 전체 글의 리스트 ​ Response (Fail) Field Type Description result null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:10","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.11좋아요순 글 리스트 GET /articles/postedListByLikes 좋아요 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:11","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.12 조회순 글 리스트 GET /articles/postedListByHits 조회 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:12","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"2.13 좋아요순 글 리스트 GET /articles/postedListByStarpoint 별점순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:13","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"3.글 임시저장 API Members Descriptions POST /subarticles/register 임시 글 작성 GET /subarticles/detail/{postid} 임시저장 글 상세 조회 GET /subarticles/list/{userid} 유저별 임시 글 리스트 DELETE /subarticles/dropSubarticle 임시 글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:0","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"3.1 임시 글 작성 POST /subarticles/register 임시 글 작성 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:1","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"3.2 임시저장 글 상세 조회 GET /subarticles/detail/{postid} 임시 글 상세조회 API입니다. ​ Request parameters Field Type Description postid int DB에서 관리하는 post id ​ Response(Success) Field Type Description result Post 유저별 임시저장 글 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:2","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"3.3 유저별 임시 글 리스트 GET /subarticles/list/{userid} 유저별 임시 글 리스트 API입니다. ​ Request parameters Field Type Description userid int DB에서 관리하는 user id ​ Response(Success) Field Type Description result List 유저별 임시저장 글의 리스트 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:3","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"3.4 임시 글 삭제 DELETE /subarticles/dropSubarticle 임시 글 삭제 API입니다. 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 임시저장 글 삭제 성공 ​ Response (Fail) Field Type Description result.data String 임시저장 글 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:4","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"4.댓글 API Members Descriptions GET /comments/list/{postid} 해당글의 댓글 전체 리스트 POST /comments/register 댓글 작성 PUT /comments/modify 댓글 수정 DELETE /comments/dropComment 댓글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:0","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"4.1 해당 글의 전체 댓글 GET /comments/list/{postid} 해당 글의 전체 댓글을 받아오는 API입니다. ​ Request parameters Field Type Description postid(path) int 해당 글 id ​ Response(Success) Field Type Description result.data List Comment객체의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:1","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"4.2 댓글 작성 POST /comments/register 댓글 작성하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:2","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"4.3 댓글 수정 PUT /comments/modify 댓글 수정하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:3","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web","django","vue"],"content":"4.4 댓글 삭제 DELETE /comments/dropComment 댓글 삭제하는 API입니다. ​ Request parameters Field Type Description commentId int 댓글의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:4","tags":["Web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3307_최장 증가 부분 수열(LIS) for T in range(int(input())): N = int(input()) arr = list(map(int, input().split())) dp= [1] * N for i in range(1, N): for j in range(i): if arr[j] \u003c arr[i]: dp[i]= max(dp[i], dp[j] + 1) print(f'#{T+1} {max(dp)}') # dp는 쉬운듯 어렵고 어려운듯 쉽다... # LIS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3304_최장 공통 부분 수열(LCS) for T in range(int(input())): A, B = input().split() dp = [[0 for i in range(len(A)+1)] for j in range(len(B)+1)] for i in range(1, len(B)+1): for j in range(1, len(A)+1): if B[i-1] == A[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) print(f'#{T+1} {dp[-1][-1]}') # 아니다. DP는 그냥 겁나 어렵다.. # 각각의 문자 위치를 숫자로 바꾸고 이를 2차원 배열로 만들어서 # 일치하는 문자가 나왔을 때의 숫자를 dp에 기록해서 진행하는데 # 난 A, B의 검사 순서를 B -\u003e A 로 해야 한다는 것을 아주 느리게 깨달았다. # LCS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 for T in range(int(input())): N = int(input()) days = [] for _ in range(N): days.append(int(input())-1) days = days[1:] dp = [1]*(N-1) count = 0 while any(dp): # 👈 dp가 모두 0일 때까지 while을 돌린다. i = dp.index(1) for j in range(i,N-1): if days[j] % days[i] == 0: dp[j] = 0 count += 1 print(f\"#{T+1} {count}\") # 2주기로 정박하는 배가 있다고 할 때, 이 배는 2일 4일 8일 12일에 정박할 수 있다. # 중간에 비어있는 일자가 있더라도 1배가 정박한 것으로 본다. # any() 함수를 써봤는데 좋았다. 푸는데 2시간... 걸렸다...ㅎ. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_10726_이진수 표현 def check2(M): for i in range(N): if M % 2 != 1: return \"OFF\" else: M = M // 2 return \"ON\" for T in range(int(input())): N, M = map(int, input().split()) print(f'#{T+1} {check2(M)}') # 특정 조건에서 더 이상 검색할 필요가 없다면, def를 선언해 사용하는 것이 아주 유용하다. # 처음에는 bin함수를 사용해 slicing을 해서 뭐..뭐.. 어떻게 해보려 했지만 # run time error가 났다. 조금 생각해보니, 굳이 bin을 사용할 것도 없어보였고, # 간단하게 시도했더니 풀렸다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3131_100만 이하의 모든 소수 a = [0, 0] + [1] * 1000000 for i in range(2, 1000000): if a[i] == 1: for j in range(2*i, 1000001, i): a[j] = 0 for i in range(2, 1000000): if a[i] == 1: print(i, end=\" \") # 에라토스테네스의 체 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3233_정삼각형 분할 놀이 for T in range(int(input())): A, B = map(int, input().split()) result = 0 for i in range(int(A//B)): result += 2*(i+1) - 1 print(f'#{T+1} {result}') # A를 B의 길이로 나눈 정삼각형은 맨 위층 부터 2n-1개의 삼각형이 나온다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_1860_진기의 최고급 붕어빵 def check(): global bread for i in range(max(people)+1): if i == 0: pass else: if i % M == 0: bread += K if i in people: if bread \u003c= 0: return 'Impossible' else: bread -= 1 return 'Possible' for T in range(int(input())): N, M, K = map(int, input().split()) people = list(map(int, input().split())) bread = 0 print(f'#{T+1} {check()}') # 특정 조건인 경우 더 이상 확인할 필요가 없기 때문에 즉시 종료가 가능한 def 함수를 # 선언해서 구현했고, 조건중 0초일때 붕어빵 판매가 가능한지 생각 후 해결되었다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_4047_영준이의 카드 카운팅 for T in range(int(input())): counts = {'S': 13, 'D': 13, 'H': 13, 'C' : 13} arr = input() new_arr = [] for i in range(0, len(arr), 3): new_arr.append(arr[i:i+3]) if len(set(new_arr)) != len(new_arr): print(f\"#{T+1} ERROR\") else: for i in new_arr: counts[i[0]] -= 1 print(f\"#{T+1} \", end='') print(*counts.values()) # 엄청 좋은 문제라고 생각한다. 막 어렵진 않으나 다양한 스킬들을 사용해서 # 풀어볼 수 있는 좋은 문제라고 생각한다. # 1. set{}의 활용 / 2. for문 slicing / 3. print안에 end 활용 / 4. set자료 접근 등 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["block_chain"],"content":"​ 🧔프라이빗 블록체인 VS 👨🏻‍🤝‍👨🏻퍼블릭 블록체인 VS 🔒프라이빗 네트워크 VS 🔐퍼블릭 네트워크 Why 이런 질문을? 블록체인 관련 정보를 구글링하다보면, 프라이빗 네트워크, 퍼블릭 네트워크, 프라이빗 블록체인, 퍼블릭 블록체인. 이 4가지의 말을 혼용해서 사용하고 있는 것을 쉽게 볼 수 있다. 여기서 프라이빗 네트워크와 프라이빗 블록체인과 같이 네트워크와 블록체인을 같은 의미로 많이 사용하는데. 과연 이 둘이 같은 것을 의미하는지 알아보았다. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"결론 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:1","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 블록체인=\u003e 사용자의 접근조건을 기준으로 프라이빗과 퍼블릭을 나눔 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:2","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 네트워크=\u003e 서비스 운용형태를 기준으로 프라이빗과 퍼블릭을 나눔 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:3","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🧔프라이빗 블록체인 선택된 참여자만 블록체인에 접근이 가능하며, 선택된 참여자만 블록을 만들 수 있음. 특징 네트워크 구성할 때 인증과 검증 과정을 통해 선택적으로 참여자가 노드를 구성 네트워크를 구성하는 참가자인 노드가 되기 위해서는 운영 주체의 허가가 필요 참여자가 제한되기 때문에 빠른 거래나 처리속도가 필요한 경우와 네트워크 내에서만 정보가 공개되어야 하는 경우에 적합한 형태 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:1:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"👨🏻‍🤝‍👨🏻퍼블릭 블록체인 누구든 블록체인에 접근이 가능하며, 누구나 블록을 만들 수 있음. ex) 비트코인(1세대 블록체인), 이더리움(2세대 블록체인) 특징 모든 참여자에게 거래 내용이 공유 자유롭게 읽고 쓸 수 있지만, 정보를 위변조하는 것이 불가능 거래 처리 용량 제한으로 인한 확장성 부족이나 채굴에 들어가는 전력의 큰 비용 등 문제 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:2:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔒프라이빗 네트워크 운영자의 허가를 받은 인원만 거래 내용을 확인할 수 있음. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:3:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔐퍼블릭 네트워크 누구나 거래내역을 확인할 수 있음. ​ ex) 블록체인 자체에 모두가 접근할 수 있는가? -\u003e 퍼블릭 블록체인이다. 실제 운용하는 형태가 퍼블릭한가? -\u003e 퍼블릭 네트워크이다. 하이퍼렛저 패브릭은 블록체인 자체가 모두가 접근하도록 설계가 되어 있지 않네? -\u003e 프라이빗 블록체인 실제 운용도 프라이빗 하구나! -\u003e 프라이빗 네트워크 이더리움은 최초에 모두가 쓸 수 있게 만들어졌군 -\u003e 퍼블릭 블록체인이네 그렇지만 일단 우리 팀원들끼리만 써야지 -\u003e 프라이빗 네트워크 ​ 내용을 정리하면서 발생했던 의문들. 노드를 생성한다는 것은 어떤 의미인가? 노드? 네트워크를 구성하는 참가자 == 노드 블록을 생성해 네트워크를 구성한다. 한개의 노드만 있더라도 네트워크는 구성되었고, 노드끼리 연결되는 순간에 서로 다른 체인데이터를 가지고 있다면, 합의로직에 따라서 합의가 진행된 후 체인 데이터가 같아진다. 프라이빗 네트워크는 어떻게 구성하는가? 개념적으로는 잘못되었을 수 있지만, 단순히 회원가입시 노드를 만들고 지갑까지 생성해 해쉬(#)값을 추출해 DB에 저장하고, 이후 서비스 사용시 해쉬값이 일치하는 사용자에게만 특정 내용을 보여준다면 프라이빗한 네트워크로 서비스를 제공할 수 있겠다. 블록체인을 생성하는 것이랑 네트워크에 참여하는 것은 별개의 일이 아닌가? 위에 설명한 노드를 만들면 나의 첫 블록인 genesis.json 파일을 만들고 네트워크에 참여하게 된다. 네트워크에 참여 후 addpeer를 통해 네트워크 사용자를 확장해나간다. 즉, 별개의 일이다. ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:4:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 for T in range(int(input())): D, A, B = map(int, input().split()) D = str(D) arr = [0, 0] + [1] * (B - 1) # 에라토스테네스의 체를 활용할껀데 어떤 수까지 검증하면 될까? # 검증해보니 모든 수는 자신의 int(root)까지만 확인하면 배수값인지 확인이 가능했다. rootB = int(B**0.5) #👈 이 아이디어를 얻기까지 오랜시간이 걸렸다. for i in range(2, rootB+1): #👈 if arr[i] == 1: #👈 for j in range(2*i, B+1, i): #👈 에라토스테네스의 체 를 활용 arr[j] = 0 #👈 result = [] for i in range(A, B+1): if arr[i] == 1 and D in str(i): result.append(i) print(f'#{T+1} {len(result)}') ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_1493_수의 새로운 연산 new_number = [(0, 0)] count = 1 while count \u003c= 300: count += 1 for x in range(1, count): y = count - x new_number.append((x, y)) for T in range(int(input())): p, q = map(int, input().split()) x = new_number[p][0] + new_number[q][0] y = new_number[p][1] + new_number[q][1] result = new_number.index((x, y)) print(f'#{T+1} {result}') # 별다른 아이디어는 없었다. 그냥 인덱스별 좌표를 미리 만들어 두고 # 그걸 불러오는 방법을 생각했다. (런타임이 겁났지만, Pass 했다.) ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_10570_제곱 팰린드룸 수 for T in range(int(input())): N = [0]*1001 A, B = map(int, input().split()) for i in range(A, B+1): if str(i) == str(i)[::-1]: if i**0.5 % 1 == 0: if str(int(i**0.5)) == str(int(i**0.5))[::-1]: N[i] = 1 print(f'#{T+1} {N.count(1)}') #그냥 문제에 주어지는 대로 풀었다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_3032_홍준이의 숫자 놀이 def exeu(a, b): global x, y r = [a, b] s = [1, 0] t = [0, 1] while r[-1] != 0: q = int(r[-2] / r[-1]) r.append(r[-2] - q * r[-1]) s.append(s[-2] - q * s[-1]) t.append(t[-2] - q * t[-1]) x = s[-2] y = t[-2] for T in range(int(input())): A, B = map(int, input().split()) exeu(A, B) print(f'#{T+1} {x} {y}') # 확장된 유클리드 알고리즘을 공부하면 된다. # 근데 쉽지 않으니 시간을 가지고 봐야 한다. # 실은 난 아직 이해하지 못했다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_2817_부분 수열의 합 import itertools for T in range(int(input())): N, K = map(int, input().split()) # N: 갯수, K: 목표 합 Nums = list(map(int, input().split())) count = 0 for i in range(1, N+1): boxs = itertools.combinations(Nums, i) for box in boxs: if sum(box) == K: count += 1 print(count) # 하... 라이브러리 쓰자.. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1491_원재의 벽 꾸미기 for T in range(int(input())): N, A, B = map(int, input().split()) result = [] for R in range(1, N+1): for C in range(1, R+1): if R * C \u003e N: break elif R * C \u003c= N: result.append(A * abs(R-C) + B * (N - R*C)) print(f\"#{T+1} {min(result)}\") # A X lR – Cl + B X (N - R X C)에서 # A X lR – Cl =\u003e 양수, B X (N - R X C) =\u003e 양수 만 가능하다. # 또 직사각형 인테리어라고해서 R != C 라고 생각했으나,, # R = C인 경우도 넣어줘야 답이 나왔다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1229_암호문2 for T in range(10): N = int(input()) passwords = list(map(int, input().split())) order = int(input()) cmd = list(input().split()) for i in range(len(cmd)): if cmd[i] == 'I': for j in range(int(cmd[i+2])): passwords.insert(int(cmd[i+1])+j, int(cmd[i+3+j])) elif cmd[i] == 'D': for j in range(int(cmd[i+2])): passwords.pop(int(cmd[i+1])) print('#{}'.format(T+1), end=' ') print(*passwords[0:10]) # 조건 자체는 어렵지 않은데, 다뤄야하는 숫자들이 많아서 결과를 확인하기 어려웠다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_5515_2016년 요일 맞추기 days= [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366] day = 4 for T in range(int(input())): m, d = map(int, input().split()) if m != 1: add_month = days[m-2] elif m == 2: add_month = days[1] else: add_month = 0 result = (day + add_month + (d-1)) % 7 print(f'#{T+1} {result}') # 이건 그냥 했다. ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10505_소득 불균형 for T in range(int(input())): N = int(input()) dp = [0] * 100001 Max = 0 for i in list(map(int, input().split())): dp[i] += 1 Max += i print(f'#{T+1} {sum(dp[:int(Max/N)+1])}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10200_구독자 전쟁 for T in range(int(input())): N, A, B = map(int, input().split()) # 최소값 구하기 if A+B \u003e= N: Min = (A+B)-N if A \u003e= B: Max = B else: Max = A else: Min = 0 if A \u003e= B: Max = B else: Max = A print(f'#{T+1} {Max} {Min}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_3376_파도반 수열 for T in range(int(input())): Padovan = [1, 1, 1, 2] N = int(input()) for i in range(N-4): Padovan.append(Padovan[i+2]+Padovan[i+1]) print(f'#{T+1} {Padovan[N-1]}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_5642_합 T = int(input()) for T in range(T): N = int(input()) Nums = list(map(int, input().split())) result = 0 Sum = 0 flag = 0 for i in range(N): Sum = Sum + Nums[i] if Sum \u003c 0: Sum = 0 elif Sum \u003e result: result = Sum if Nums[i] \u003c 0: flag += 1 if flag == N: result = max(Nums) print(f'#{T+1} {result}') # 모두 음수인 경우를 생각해야 한다... 이거 생각하는데 40분 걸렸따... ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["block_chain"],"content":"​ 🎈가상환경에서 블록체인 채굴 및 기본 시스템 정리 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:0:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"1. geth(Go-ethereum) 설치 블록체인 기술은 중앙집중화된 데이터베이스에 반기를 들고 나온 개념이기 때문에 중앙 서버 이런게 없다. 즉 누구라도 해당 블록체인 네트워크에 참여하고 싶다면 언제라도 블록체인 데이터베이스를 싱크해주는 로컬 프로그램을 다운 받아 실행하면 데이터를 받을 수 있다. 그렇다면 블록체인 네트워크에 참여하고 싶다면 어떻게 해야 할까? 앞서 말한 로컬 프로그램을 다운 받으면 참여가 가능하다. 이 프로그램들 중 하나인 GO 로 짜여진 Go Ethereum(줄여서, geth)을 설치해본다. 작성당시 가장 최신 버전인 1.9.20 for windows로 다운을 받는다. 다운 받고 실행하면 경고창이 뜨는데 추가정보누르고 실행누르고 진행한다. devolop 뭐시기는 선택하지 않았고, next를 누루고 진행한다. 설치가 깔끔히 마무리 되지 않고 경고창이 떴는데, 환경변수 설정해주었다. 검색 → 시스템 환경 변수 편집 → 고급 → 환경 변수 → Path더블클릭 → 새로만들기 → C:\\Program Files\\Geth 추가 cmd 창을 열어(관리자: 명령 프롬프트) geth를 입력해 실행되는지 확인한다._______끝 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:1:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"2. Web3 설치 모든 자료와 정보가 분산화, 분권화된 차세대 네트워크 구조로서, 서버가 없는 혁신적인 인터넷 분산형 웹. web3.js는 JavaScript 기반으로 Dapp 이나 서비스를 구현할 때 매우 유용. (출처: 위키) ​ 이미 Vue_CLI 프로젝트를 구성해 놓은 것이 있어서 Terminal 에서 npm install web3 입력해서 web3를 설치한다. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:2:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"3. VirtualBox 설치 VirtualBox: 하드웨어를 소프트웨어적으로 구현해서 그 위에서 운영체제가 작동하도록하는 기술 Windows hosts 와 All supported platforms 두개를 다운 받는다. Windows hosts: 그냥 next연타하여 설치 All supported platforms을 더블클릭하여 설치를 진행하는데 👍전체 설치는 이 블로그의 설치 동영상을 참고하여 설치를 진행 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:3:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"4. Vagrant 설치 Vagrant는 가상머신을 편리하게 사용할 수 있도록 도와주는 프로그램입니다. 이미 누군가가 Vagrant로 설정해 놓은 가상머신 Box를 간단한 명령어로 손쉽게 설치 할 수 있으며 가상 머신과 호스트 머신과의 환경설정도 쉽게 할 수 있습니다. 다운로드는 여기서 진행. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:4:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"5. Remix IDE 설정 이더리움 스마트 컨트랙트 프레임워크 여기서 진행! ​ 🎈본격적인 블록체인 관련 가상환경 세팅 및 채굴 진행 20.09.01 한 일.. ⛏ 광산에서 일하는 것을 예시로! VirtualBox(🏞): 블록체인 생성 및 채굴을 위한 가상환경을 세팅 (내가 채굴할 산을 고르는 것) Vagrant(🏟): 가상환경에서 노드를 생성하는 등, 블록체인 관련 프레임워크 (광구를 생성하는 것) geth(📜👷‍♂️): 블록체인 노드의 관련 프로그램 (광구에 어떤 사람이 들어오고 어떤 사람을 파견할지 등등) ​ 블록체인 관련 작업을 할 디렉토리 생성 후 Terminal을 열어 vagrant 관련 명령어 실행(이미 설치는 완료) \u003e vagrant version #설치 여부 및 버전 확인 =\u003e 버전 넘버가 보이면 ok \u003e vagrant plugin install vagrant-scp # 호스트 \u0026 가상머신 간 연동 프로그램 설치 \u003e vagrant init # 블록체인 채굴을 위한 기초 세팅 시작 # 해당 명령어를 입력하면 작업하는 디렉토리에 Vagrantfile이 생긴다. vagrant init 후 생기는 Vagrantfile을 수정해 최초의 블록(genesis.json)을 생성해야 한다. # Vagrantfile =\u003e 내용을 수정한다. # -*- mode: ruby -*- # vi: set ft=ruby : # All Vagrant configuration is done below. The \"2\" in Vagrant.configure # configures the configuration version (we support older styles for # backwards compatibility). Please don't change it unless you know what # you're doing. VAGRANT_API_VERSION = \"2\" vms = { 'eth0' =\u003e \"10\", 'eth1' =\u003e \"11\" } Vagrant.configure(VAGRANT_API_VERSION) do |config| config.vm.box = \"ubuntu/bionic64\" vms.each do |key, value| config.vm.define \"#{key}\" do |node| node.vm.network \"private_network\", ip: \"192.168.50.#{value}\" if \"#{key}\" == \"eth0\" node.vm.network \"forwarded_port\", guest: 8545, host: 8545 end node.vm.hostname = \"#{key}\" node.vm.provider \"virtualbox\" do |nodev| nodev.memory = 2048 end end end end # 내가 이해?한 바로는 eth0과 eth1이라는 2개의 노드(광구)를 설정했다. 정도 \u003e vagrant up # 방금 설정한 eth0과 eth1 노드(광구)를 오픈(실행) \u003e vagrant status # 설정되어 있는 두 노드(광구)의 상태를 확인 runing이면 오픈한 상태 ​ 여기 가지 작업을 했다면 vitualbox에 두개의 노드(광구)가 등록되어있는 것을 확인 할 수 있다. ​ 등록된 노두(광구) 중에서 eth0을 먼저 설정해보자 지금까지 진행한 폴더에서 Terminal을 열고 vagrant 명령어로 노드(광구)를 설정해준다. 기본적은 vagrant 명령어 명령어 설명 vagrant up 상태확인할가상머신이름 가상머신 기동 vagrant status 상태확인할가상머신이름 가상머신 상태 확인 vagrant ssh 접속할가상머신이름 가상머신에 접속 vagrant halt 멈출가상머신이름 가상머신 정지 vagrant suspend 가상머신 휴면 vagrant resume 가상머신 휴면에서 복원 vagrant reload 가상머신 재시동 vagrant destroy 가상머신 제거 *모든 명령어가 vagrant up 상태확인할가상머신이름 과 같이 사용 가능하다. ​ 이제 노드(광구)를 열었으니 접속해보자 =\u003e vagrant ssh 접속할가상머신이름 ​ geth를 설치해준다. *Geth 설치 (Go-ethereum client) # vagrant@eth0:~$ 가상머신에서 수행 \u003e sudo apt-get update \u003e sudo apt-get install software-properties-common \u003e sudo add-apt-repository -y ppa:ethereum/ethereum \u003e sudo apt-get install ethereum #여기까지 순서대로 설치하면 geth설치는 완료. # 프라이빗 이더리움를 관리할 폴더 생성 \u003e mkdir -p dev/eth_localdata #-p는 mkdir 옵션사항 =\u003e 중간경로도 다 만들어라 \u003e mkdir database \u003e cd database # 프라이빗 이더리움을 위한 genesis.json블록파일(블록들을 연결하기 위한 최초의 블럭) 생성 \u003e vi genesis.json # genesis.json를 만들겠다. # genesis.json의 내용 등록 (예시) i → 입력 활성화 → 아래 내용입력 후 → esc → ZZ(저장하고 종료) { \"config\": { \"chainId\": 5245, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0xdeadbeefdeadbeef\", \"difficulty\": \"0x40\", \"gasLimit\": \"9999999\", \"alloc\": {}, \"extraData\": \"\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\": \"0x00\" } # genesis.json 저장 후 \u003e cd .. 다시 root폴더로 이동한다. ​ 나의 최초의 블록(genesis.json)을 만들었다면 등록(초기화)해줘야 한다. =\u003e ✨geth를 사용하여 진행 \u003e geth init #이 명령어로 등록(초기화)을 할 수 있는데... # 위의 --datadir을 참고하여 \u003e geth --datadir ~/dev/eth_localdata init ~/database/genesis.json # ~/database 위치에 있는 genesis.json을 등록(초기화)하고 등록 후 생기는 관련 자료는 ~/dev/eth_localdata에 모아놓겠다는 뜻 ​ 이제 노드(광구)를 관리할 계정(🙋‍♂️사람)도 등록해준다. \u003e geth account new # 이 명령어를 입력하면 아이디는 자동으로 생성되고 비밀번호만 설정할 수 있게 진행된다. # 계정이 잘 만들어 진 것인지 확인하기 위해서는 \u003e geth account list ​ 이제 노드(광구)에 어떤 사람들이 들어올 수 있는지와 입장하는 명령어들을 살펴보자. 어떤식으로 입력(설정)하는 지는 여기를 참고하여 진행하였다. # eth0의 노드(광구) 입장 명령어 \u003e geth console # 다만 보통의 경우 아래와 같이 노드(eth0)에 다양한 주소 및 설정을 붙이고 진행한다. \u003e geth --networkid 5245 --port 30303 --maxpeers 2 --datadir ~/dev/eth_localdata --rpcaddr 0.0.0.0 --nodiscover --nousb console \u003e\u003e ~/eth0.log # 일단 이걸로 채굴 성공 geth --datadir ~/dev/eth_localdata --nodiscover --nousb --networkid 5245 console # 맨 마지막에 2\u003e\u003e ~/eth0.log를 붙이면, 진행기록을 root주소에 eth0.log를 만들어 저장한다.란 뜻. # 진행 도중 ERROR 모음 Failed to enumerate USB devices =\u003e --nousb 추가해주면 사라짐. ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"Transaction eth0 안에 account[0] 이랑 account[1] 이 있고 coinbase는 accounts[0] 인 상황에서 account[0]에서 채굴한걸 account[1]로 보낼 것이다. =\u003e 이를 트랜잭션(Transaction) 한다고 한다. 트랜잭션을 위해서는 먼저 계정들의 잠금 해제가 필요하다. EOS계정을 만들면 기본적으로 잠금 상태인데, # 잠금해제 command 로 해제가 가능하다. (이더를 보내는 EOS계정만 잠금을 풀어주면 된다.) personal.unlockAccount(eth.accounts[0]) #기본적인 세팅, 입력 후 비밀번호 입력 계정 잠금 해제(잠금 해제 유효시간 기본 - 300초) personal.unlockAccount(eth.accounts[0], \"inputpassword\") #비밀번호가 입력되어 계정 잠금 해제(비밀번호 입력 필요X) personal.unlockAccount(eth.accounts[0], \"inputpassword\", 0) #계정 잠금 해제(0 - Geth 프로세스 종료되기 전까지 해제) ​ 이제 트랜잭션이 있는지 확인해보자. (eth.pendingTransactions =\u003e 트랜잭션 확인) 입력한 transaction이 없으니 비어있다. ​ 이제 송금(Transaction) 해보자. eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10, \"ether\")}) # eth.accounts[0]에서 eth.accounts[1]로 web3단위로 10이더를 보내겠다.는 뜻. 색이 이쁘니 성공적으로 명령을 처리 한 것 같다. 하지만 accounts[1]계정에 돈이 들어오지 않았다. ​ 트랜잭션은 등록된게 확인된다. 왜 진행은 안됬을까…. 하지만 accounts[1]계정에 돈이 들어오지 않았다. *blockNumber: null로 accounts[0]에서 보낸 트랜잭션이 accounts[1]의 블록에 포함되지 않음을 알 수 있다. ​ 송금 확인(sendTransaction으로 트랜잭션을 발행해도 처리안됨 =\u003e 블록체인에서는 블록 안에 그 트랜잭션이 포함될 때 트랜잭션 내용이 실행) ✨ 간단히 트랜잭션을 등록하고 miner.start() command로 채굴을 시작하는 경우(블록 활성화?)에 트랜잭션이 반영된다! \u003e miner.start(1) # 이걸로 잠시 채굴을 켰다가. \u003e miner.stop() # 으로 채굴을 꺼주고 \u003e eth.pendingTransactions # 으로 트랜잭션 내용을 다시 확인해주면 비어있는 것을 볼 수 있다. ​ 그리고 # EOS계정(accounts[1])의 잔액을 확인해보면 \u003e eth.getBalance(eth.accounts[1]) \u003e web3.fromWei(eth.getBalance(eth.accounts[1]), \"ether\") #둘다 확인 가능하며 송금이 잘 진행된 것을 볼 수 있다. 여기까지 진행하면서, 두 블로그를 매우 많이 참고했고, 도움이 되었어서 소개한다. Mr.Latte - [Go Ethereum 사용 법] Allg - [Geth 설치 및 테스트 네트워크에서 송금하기] ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:1","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1149_RGB거리 N = int(input()) RGB = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(RGB)): RGB[i][0] = RGB[i][0] + min(RGB[i-1][1], RGB[i-1][2]) RGB[i][1] = RGB[i][1] + min(RGB[i-1][0], RGB[i-1][2]) RGB[i][2] = RGB[i][2] + min(RGB[i-1][0], RGB[i-1][1]) print(min(RGB[i][0], RGB[i][1], RGB[i][2])) # 2시간이 넘게 고민한 결과... # 문제 속 조건3 \"\"i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\"\"을 이해하는데 시간이 걸렸다. # 조건3에 따르면 N=3인 경우, i = 2가 되고, 결국 1번, 3번 집의 색과 2번 집의 색이 다르면 된다. # 난 이걸.. 1번집과 3번집의 색이 달라야 한다고 잘못 이해해서 시간을 버렸다.ㅎ ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1932_정수삼각형 N = int(input()) tree = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(tree)): f = len(tree[i]) for j in range(f): if j == 0: tree[i][j] = tree[i][j] + tree[i-1][j] elif j == f-1: tree[i][j] = tree[i][j] + tree[i-1][j-1] else: tree[i][j] = tree[i][j] + max(tree[i-1][j-1], tree[i-1][j]) print(max(tree[i])) # 이전 문제를 풀고선 그리 어렵지않게 풀었다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"2579_계단오르기 # 1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다. # 2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다. # 3. 마지막 도착 계단은 반드시 밟아야 한다. N = int(input()) # stairs = [int(input()) for _ in range(N)] # 이렇게 정보를 받으면 느리다.... stairs = [0 for _ in range(301)] for i in range(N): stairs[i] = int(input()) total = [0 for _ in range(301)] total[0] = stairs[0] total[1] = stairs[0] + stairs[1] total[2] = max(stairs[1] + stairs[2], stairs[0] + stairs[2]) # 마지막 계단을 반드시 밟아야 하니까. \u003c0: 안밟음, 1: 밟음\u003e for i in range(3, N): total[i] = max( total[i-3]+stairs[i-1]+stairs[i], # 1 0 1 1(마지막계단)의 경우 total[i-2]+stairs[i] # 1 0 1(마지막계단)의 경우 ) print(total[N-1]) ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1463_1로 만들기 x = int(input()) x_map = [0 for i in range(x+1)] visited = [0 for i in range(10**6)] x_map[x] = 1 count = 0 while x_map[1] == 0: count += 1 for i in range(1, x+1): if x_map[i] == count: if i % 3 == 0 and visited[i//3] == 0: x_map[i//3] = count+1 visited[i//3] = 1 if i % 2 == 0 and visited[i//2] == 0: x_map[i//2] = count+1 visited[i//2] = 1 if x_map[i-1] == 0 and visited[i-1] == 0: x_map[i-1] = count+1 visited[i-1] = 1 print(x_map[1]-1) # 코딩하면서는 너무 바보 같은 방법인가.. 했지만, 통과됬으니 뭐.. 만족한다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1003_피보나치 함수 def Fibonacci(N): if N \u003c 3: print(zero[N], one[N]) else: f = 1 s = 2 for i in range(N-2): zero.append(zero[f] + zero[s]) one.append(one[f] + one[s]) f += 1 s += 1 print(zero[N], one[N]) for T in range(int(input())): N = int(input()) zero = [1, 0, 1] one = [0, 1, 1] Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1904_01타일 def Fibonacci(N): result: 0 f = 0 s = 1 for i in range(1, N+3): if i == 1: result = f elif i == 2: result = s else: result = f+s f = s % 15746 s = result % 15746 print(result % 15746) Fibonacci(int(input())) # 문제를 먼저 손으로 플어보니 결국 피보나치 수열이 답이었는데 # 15746의 나머지가 답이어서 그런지 '시간 초과'가 발생했다. # 때문에 '왜맞틀?'로 고민하다 검색해보니 결과값을 15746의 나머지로 더한다는 # 방법을 보고 이를 참고했다. (솔직이 아직 이게 왜 더 빠른지 잘 모르겠다.) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"2748_피보나치의 수2 def Fibonacci(N): Fibo = [0, 1] f = 0 s = 1 for i in range(3, N+2): Fibo.append(Fibo[f] + Fibo[s]) f += 1 s += 1 print(Fibo[N]) N = int(input()) Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"9461_파도반 수열 for T in range(int(input())): N = int(input()) Padovan = [1, 1, 1] f = 0 s = 1 for i in range(N-3): Padovan.append(Padovan[f] + Padovan[s]) f += 1 s += 1 print(Padovan[N-1]) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["django","vue"],"content":"​ Naming Convention 정해진 규정은 없으나, 많은 개발자들이 암묵적으로 지키고 있는 이름짓는 방법. ​ snake_case 🐍 # _ == snake some_var = 5 my_awesome = 3 ​ camelCase 🐪 # 낙타등이 솟아 있는 모습 someVar = 5 pyAwesome = 3 ​ UpperCamelCase 🐪🐪 # 낙타얼굴과 등이 중간에 솟아 있는 모습 (파스칼식(Pascal case)이라고도 불린다.) SomeVar = 5 PyAwesome = 3 ​ Kebab-Case 🥙 # 케밥이 꼬챙이에 꽂힌 모습에서 생긴 방법(이라는데 난 생김새는 잘 모르겠다.ㅎ) main-login = 5 feed-content = 1 ​ ","date":"2020-08-02","objectID":"https://colinder.github.io/namingconvention/:0:0","tags":["django","vue"],"title":"Naming Convention","uri":"https://colinder.github.io/namingconvention/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4466_최대 성적표 만들기 for T in range(int(input())): N, K = map(int, input().split()) score = list(map(int, input().split())) score.sort(reverse=True) result = 0 for i in range(K): result += score[i] print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4406_모음이 보이지 않는 사람 for T in range(int(input())): sent = input() result = '' for i in sent: if i not in 'aeiou': result += i print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4299_태혁이의 사랑은 타이밍 for T in range(int(input())): D, H, M = map(int, input().split()) result = D*1440 + H*60 + M if result \u003e= 16511: print(f'#{T+1} {result-16511}') else: print(f'#{T+1} -1') ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4676_늘어지는 소리 만들기 for T in range(int(input())): sent = list(input()) # wow H = int(input()) po = sorted(list(map(int, input().split()))) # 2 3 2 for i in range(H): a = po[i]+i sent.insert(a,'-') print('#{} {}'.format(T+1, ''.join(sent))) # 단순 산수로 해결 ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4615_재미있는 오셀로 게임 dx = [0, 1, 1, 1, 0, -1, -1, -1] dy = [1, 1, 0, -1, -1, -1, 0, 1] def dfs(x, y, i ,stone): if board[x][y] == 0: return 0 elif board[x][y] == stone: return 1 else: if dfs(x+dx[i], y+dy[i], i, stone): board[x][y] = stone return 1 else: return 0 for T in range(int(input())): N, M = map(int, input().split()) command = [list(map(int, input().split())) for _ in range(M)] board = [[0]*(N+2) for _ in range(N+2)] board[N//2+1][N//2+1] = 2 board[N//2][N//2] = 2 board[N//2][N//2+1] = 1 board[N//2+1][N//2] = 1 for x, y, stone in command: for i in range(8): board[x][y] = stone dfs(x+dx[i], y+dy[i], i, stone) B = 0 W = 0 for i in range(N): for j in range(N): if board[i+1][j+1] == 1: B += 1 elif board[i+1][j+1] == 2: W += 1 print(f'#{T+1} {B} {W}') # dfs를 연습해볼 수 있는 좋은 문제라고 생각한다. # 추가적인 조건이 있어 dfs를 많이 사용해보지 못한 나는 해결하는데 오랜 시간이 걸렸다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4579_세상의 모든 팰린드롬 2 for T in range(int(input())): arr = input() result = 'Exist' for i in range(len(arr) // 2): if arr[i] == '*' or arr[-1 - i] == '*': result = 'Exist' break if arr[i] != arr[-1 - i]: result = 'Not exist' break print(f'#{T+1} {result}') # *이 등장하기 전까지 대칭을 이루고 있다면 무조건 'Exist'이고, # 만약 *가 없다면, 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4522_세상의 모든 팰린드롬 for T in range(int(input())): arr = list(map(str, input())) result = 'Exist' for i in range(len(arr)): if arr[i] == '?': arr[i] = arr[-i - 1] if arr != arr[::-1]: result = 'Not exist' print(f'#{T+1} {result}') # ?가 등장하면 무조건 해당 index의 반대쪽이 대칭을 이룬다고 생각할 수 있으니까, # ?의 index 반대쪽을 동일하게 변경해주고 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_5162_두가지 빵의 딜레마 for T in range(int(input())): A, B, C = map(int, input().split()) N = min(A, B) print(\"#{} {}\".format(T+1, int(C/N))) # 단순 산수로 해결 ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4789_성공적인 공연 기획 for T in range(int(input())): P = list(map(int, map(str, input()))) need = P[0] count = 0 for i in range(1, len(P)): if need \u003e= i: need += P[i] else: count += i - need need = i + P[i] print(f'#{T+1} {count}') # 문제를 이해하는 것이 Point였다. # 먼저 str로 input을 받아 개별 숫자로 나누고 바로 int 변경하여 인자를 받음. # # \"i번째 글자가 의미하는 바는 기립 박수를 하고 있는 사람이 i-1명 이상일 때 기립 박수를 하는 사람의 수\" # Test case3의 경우 (09) 9는 큰 의미 없이 2번째 글자임으로 기립박수를 하고 있는 사람이 1명일 이상일 때 기립박수를 친다. # 즉 index만 가지고 조건을 판단 하면 된다! ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4751_다솔이의 다이아몬드 장식 T= int(input()) for tc in range(T): text = input() n= len(text) for i in range(5): if i == 0 : print('..#.'*n+'.') elif i == 1 : print('.#'*(n*2)+'.') elif i == 2 : print('#',end='') for a in range(len(text)) : print(('.{}.#'.format(text[a])), end=\"\") elif i == 3 : print() print('.#'*(n*2)+'.') elif i == 4 : print('..#.' * n + '.') # 단순 작업이었으나, 반복되는 곳의 기준을 어디로 할 것인가를 잘 지정해야 함. ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5431_민석이의 과제 체크하기 for T in range(int(input())): N, K = map(int, input().split()) P = list(map(int, input().split())) result = [] for i in range(1,N+1): if i not in P: result.append(str(i)) print('#{} {}'.format(T+1, ' '.join(result))) # 제출한 수강생 리스트를 만들고(P) 이를 for로 돌리며 검증 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5356_의석이의 세로로 말해요 for T in range(int(input())): sent = [list(str(input())) for _ in range(5)] #입력받은 요소의 길이를 알아내야 한다. max = 0 for n in range(5): long = len(sent[n]) if long \u003e= max: max = long result = '' for i in range(max): for j in range(5): try: if sent[j][i] != \"\": result += sent[j][i] except IndexError: pass print(f'다시 풀이 #{T+1} {result}') # 입력받은 5개의 단어 중 가자 긴 단어의 길이를 저장하고(long) # long 길이 만큼 순회를 하면서 5개의 단어에 index로 접근하고 index값이 비어있지 않으면 result에 추가 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5293_이진 문자열 복원 for T in range(int(input())): A, B, C, D = map(int, input().split()) if B == 0 and C == 0 and A != 0 and D != 0: result = 'impossible' elif abs(B - C) \u003e 1: result = 'impossible' else: if B == 0 and C == 0: if A != 0: result = '0' * (A + 1) else: result = '1' * (D + 1) elif B \u003c C: result = '1' * D + '10' * C + '0' * A elif B \u003e C: result = '0' * A + '01' * B + '1' * D else: result = '0' * A + '01' * B + '1' * D + '0' print('#{} {}'.format(T+1, result)) # 하드코딩...ㅎㅎ ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5215_햄버거 다이어트 for T in range(int(input())): N, maxKcal = map(int, input().split()) Sum = [0] * (10**4 + 1) for _ in range(N): Point, Kcal = map(int, input().split()) for idx in range(maxKcal, Kcal + 1, -1): if Sum[idx] \u003c Sum[idx - Kcal] + Point: Sum[idx] = Sum[idx - Kcal] + Point print(f'#{T+1} {Sum[maxKcal]}') ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5948_새샘이의 7-3-5 게임 for T in range(int(input())): N = list(map(int, input().split())) result = set() for i in range(5): for j in range(i+1, 6): for x in range(j+1, 7): result.add(N[i]+N[j]+N[x]) result = list(result) result.sort() print('#{} {}'.format(T+1, result[-5])) # 3수의 합을 정리하는데 set으로 중복을 제거하는 방법으로 result set을 정리 # set은 순서가 없기 때문에 result를 다시 list로 정리하고 .sort를 이용해 순서대로 나열 후 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5789_현주의 상자 바꾸기 for T in range(int(input())): N, Q = map(int, input().split()) arr = ['0' for _ in range(N)] for i in range(1, Q+1): L, R = map(int, input().split()) for _ in range(L-1, R): arr[_] = str(i) print('#{} {}'.format(T+1, ' '.join(arr))) # arr이라는 0이 적힌 상자 리스트를 생성 # index L~R에 _의 숫자를 입력(출력하기 쉽게 str형태로 입력) # join을 써서 str형태의 list인자를 붙여서 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5688_세제곱근을 찾아라 for T in range(int(input())): N = round(int(input())**(1/3), 2) print(\"#{} {}\".format(T+1, int(N) if int(N) == N else -1)) # 출력 방식에 조건을 넣어서 시도해봄 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5549_홀수일까 짝수일까 for T in range(int(input())): N = int(input()) print('#{} {}'.format(T+1, 'Even' if N%2 == 0 else 'Odd')) # 출력 방식에 조건을 넣어서 시도해봄 ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6190_정곤이의 단조 증가하는 수 for T in range(int(input())): N = int(input()) L = list(map(int, input().split())) result = -1 for i in range(N-1): for j in range(i+1, N): num = str(L[i]*L[j]) if len(num) \u003e 1 and '0' not in num and result \u003c int(num) and list(num) == sorted(num): result = int(num) print(f'#{T+1} {result}') # 단조증가하는 지를 검증하는 방법으로 sorted를 썼는데 이를 활용하기 위해서는 str형태로 변경해야 검증이 가능하다. # 한자리 숫자는 단조증가하는 수가 아니다. # 중간에 0이 있다면 볼 필요도 없이 단조증가수가 아니기 때문에 처리 속도 증가가 가능하다. ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6057_그래프의 삼각형 for T in range(int(input())): N, M = map(int,input().split()) # N: 정점, M: 간선 arr = [[0]*(N+1) for n in range(N+1)] # part1 for _ in range(M): X, Y = map(int,input().split()) arr[X][Y] = 1 arr[Y][X] = 1 # part2 result = 0 for i in range(1, N+1): for j in range(i+1, N+1): if arr[i][j] == 1: for r in range(j+1, N+1): if arr[j][r] == 1 and arr[r][i] == 1: result += 1 print(f\"#{T+1} {result}\") # part1에서 삼각형의 정점의 정보를 담는 arr을 만들고 # part2에서 만들어진 배열을 돌며 정점의 정보를 발견(1)하면 해당 정점을 기준으로 삼각형이 되는지 검증 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6019_기차 사이의 파리 for T in range(int(input())): D, A, B, F = map(int,input().split()) t = D / (B+A) print('#{} {}'.format(T+1, F*t)) #단순 수학으로 해결 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_5986_새샘이와 세 소수 for T in range(int(input())): N = int(input()) # part1 PN = set() for i in range(2, N+1): for j in range(2, i+1): if i % j == 0: break PN.add(j) PN =list(PN) pn = PN.sort(reverse=True) # part2 count = 0 for i in range(len(PN)): for j in range(i,len(PN)): for k in range(j,len(PN)): if N == PN[i]+PN[j]+PN[k]: count += 1 print('#{} {}'.format(T+1, count)) # part1에서 소수 리스트를 만들고(1과 자기 자신만을 약수로 가지는 수 리스트) # part2에서 세 소수의 합으로 나타낼 경우의 수를 종합. ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_9700_USB 꽂기의 미스터리 for T in range(int(input())): p, q = map(float, input().split()) s1 = (1-p)*q s2 = p*(1-q)*q if s1 \u003c s2: print(f'#{T+1} YES') else: print(f'#{T+1} NO') # 단순 수학을 통해 해결. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_7675_통역사 성경이 for T in range(int(input())): N = int(input()) sent = input() sent = sent.replace('.', ' @').replace('!', ' @').replace('?', ' @').split() #print(sent) result = \"\" count = 0 for i in sent: if i.isalpha() and i == i.capitalize(): count += 1 if i == '@': result += str(count) + ' ' count = 0 print(\"#{} {}\".format(T+1, result)) # 주어지는 문장을 띄어쓰기를 기준으로 나누기 위해 .split()을 사용하고 # 문제에서 주어진 `이름`의 조건이 `첫 알파벳이 대문자이고 나머진 소문자`이기 때문에 # 문자로만 이루어져있는 것인지 .isalpha()로 검증 (VS .isdigit() 주어진 문자열이 숫자인지 검증) # `이름`의 조건이 맞는지 .capitalize()로 검증 # 추가 공부 내용 # upper - 주어진 문자열에서 모든 알파벳들을 대문자로 변환시킨다. # capitalize - 주어진 문자열에서 맨 첫 글자를 대문자로 변환하고 나머지는 소문자로 변환시킨다. # title - 주어진 문자열에서 알파벳 외의 문자(숫자, 특수기호, 띄어쓰기 등)로 나누어져 있는 영단어들의 첫 글자를 모두 대문자로 변환시킨다. # .isalpha()와 .capitalize()를 알고나면 간단해지는 문제. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6692_다솔이의 월급 상자 for T in range(int(input())): tc = int(input()) result = 0 for _ in range(tc): P, X = map(float, input().split()) result += P*X print(f'#{T+1} {result}') # input을 float형으로 받으면서 단순 수학을 사용해 해결 ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6485_삼성시의 버스 노선 for T in range(int(input())): info = [0]*5001 for N in range(int(input())): st, la = map(int, input().split()) for x in range(st, la+1): info[x] +=1 station = [] for P in range(int(input())): station.append(str(info[int(input())])) print('#{} {}'.format(T+1, ' '.join(station))) # info로 정류장의 index를 기록(중복되는 위치를 표기하기 위해 +1 씩 진행) # P개의 버스 정류장을 확인하는데 저장되어있는 info의 정류장 정보를 가져와서 station리스트에 기록 # 주어진 문제에서 만약 범위?를 알려준다면 그만큼의 저장 리스트를 생성하는 것이 빠르다. # 예를 들어 info = [] 보다 info = [0]*5001 로 설정해 사용하는 것이 더 빠른 실행시간을 보여준다. ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"}]