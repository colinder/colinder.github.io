[{"categories":["AI","Activation Function"],"content":"​ Activation Function(활성화 함수) 입력 신호의 총합을 출력신호로 변환하는 함수를 일반적으로 Activation Function이라고 합니다. ​ 아직 잘 모르겠습니다. 하여 인공신경망에 빗대어 이해해보겠습니다. 인공 신경망은 인간의 중추신경계(뇌)속의 뉴런들이 정보를 전달하고 학습하여 결과를 도출해내는 과정을 모방한 학습알고리즘입니다. 여기서 의문점이 생깁니다. 예를 들어 지나가다 귤을 보았는데 맛이 있을지 없을지 어떻게 알 수 있을까요? 저 귤의 데이터를 수집해 봅시다. 타원형, 이쁜 노란색, 푸르른 꼭지 라는 데이터를 눈으로 보고 뇌속의 뉴런들이 이 정보를 분석해 맛있겠다.라는 출력을 불러왔습니다. 입력된 데이터를 어떤 규칙? 방법에 따라 분석하여 출력 데이터로 변환하였는데요. 이 역할을 해주는 것이 Activation Function입니다. ​ ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:0:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"✋ ‘Node와 Layer’가 어떻게 생겼는지 다시 알아봅시다. Node는 뇌속의 뉴런과 같은 역할이고, Node들이 모여 인공신경망의 층이라 불리는 Layer가 됩니다. ​ ​ ​ ​ Features of activation function 활성화 함수는 주로 비선형 함수(곡선 그래프로 표현되는 함수)를 사용합니다. 왜 그럴까요? 선형함수(직선 그래프로 표현되는 함수)를 사용하면 Layer(층)을 깊게 쌓아 학습하는 의미가 줄어들기 때문입니다. 예를 들어 어떤 현상(or 데이터)를 분석(or 학습)하는데 선형(linear)함수 H(x) = ax 활성화 함수로 사용하는 3-Layer 네트워크가 있을 때. 해당 네트워크는 결국 Y(x) = H(H(H(x)))와 동일해집니다. 간단히 Y(x) = a^3x 로도 표현할 수 있습니다. 하나의 Layer( Y(x) = a^3x )로도 3-Layer를 대신할 수 있게 됩니다. 즉, 선형(linear)적인 연산을 갖는 Layer는 몇개를 쌓는다 해도, 결국 하나의 선형적인 연산처리하는 Layer로 대체될 수 있습니다. 또 위의 그림을 보면 파란원(특이점)을 더 많이 만족하는 것은 비선형 함수가 됩니다. 실제 자연환경에서는 선형적이지 않은 복잡한 일(특이점)들이 더 많기 때문에 다양한 조건에 대응하기 위해서 비선형 함수를 사용하는 것입니다. ​ ​ ​ ​ Type of activation function 대표적인 활성화 함수에 대하여 알아보겠습니다. 활성화 함수는 엄청 많습니다. Threshold, Binary step, Sigmoid, Tanh or Hyperbolic tangent, Softmax, ReLU, Leaky ReLU, Parametric ReLU, ETC….. 활성화 함수는 ‘하이퍼 파라미터‘라고 불립니다. 간단히 사용자가 설정해주는 값인데, 결국 정답은 없으며, 우리의 직관? 판단?으로 설정해야하는 값입니다. 막연하지만, 함수의 특징을 안다면 상황에 맞게 최적의 함수를 선택해 사용할 수 있으니 알아보겠습니다. ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 Binary Step function 마치 계단 같이 0을 기준으로 0 or 1로 극명하게 값을 결정됩니다. =\u003e Output은 0 또는 1 0.01도 1로 처리되어 100배의 결과값 차이가 발생합니다. 마치 선형(linear)함수와 비슷해 학습할 내용이 많으면 사용하지 않는 것이 좋습니다. ​ ​ ​ ​ 🤔 너무 극단적인 구분값말고 융통성있는 이진 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:1","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 Sigmoid function 선형함수의 결과를 0 ~ 1까지의 비선형 형태로 변환하는 함수입니다. =\u003e Output은 0~1 사이의 실수 로지스틱, 정규분포 등과 같이 이진 분류 문제(1 or 0 /성공 or 실패…)의 확률 표현에 자주 사용됩니다. binary classification의 출력층 노드에서 0~1사이의 값을 만들고 싶을때 사용합니다. ✨인공 신경망이 학습하는 과정에서 저번엔 안 중요했는데, 이번에는 중요하네? 와 같이 학습하는 요소의 가중치를 잘 반영해야 하는데 Sigmoid는 원점이 중심이 아닙니다.(Not zero-centered). 평균이 0.5이며 항상 양수를 출력하기 때문에 출력의 가중치합이 입력의 가중치합보다 커질 가능성이 높아집니다. 이것을 편향 이동(bias shift)이라고 하는데, 이러한 이유로 각 Layer를 지날 때마다 분산이 계속 커져 가장 높은 Layer에서는 활성화 함수의 출력이 그래프의 극값인 0 or 1로 수렴하게 되고 결국 기울기가 0이 되어 버리는 Gradient Vanishing이 일어나게 됩니다. 또 애초에 매우 높거나, 낮은 입력에 대한 예측을 거의 변경하지 않아(크면 무조건1, 작으면 무조건 0) 궁극적으로 신경망이 학습을 거부하게 됩니다. ​ ​ ​ ​ 🤔 Sigmoid보다 가중치를 조금 더 잘 반영하는 이진 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:2","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 Tanh(Hyperbolic tangent) function Hyperbolic Tangent(tanh) 함수는 Sigmoid의 대체제로 사용되는 함수입니다. 매우 유사하게 생겼습니다. 실제로, Hyperbolic Tangent 함수는 확장 된 Sigmoid 함수입니다. 차이점은 출력범위가 0 ≤ Sigmoid ≤ 1이고 -1 ≤ tanh ≤ 1 이라는 점입니다. 원점 중심(zero-centered)이기 때문에, 시그모이드와 달리 편향 이동이 일어나지 않습니다. 하지만, tanh함수 또한 입력의 절대값이 클 경우 -1이나 1로 수렴하게 되므로 Gradient Vanishing가 발생하지만, Sigmoid보다 발생 경향이 적어 효과적으로 사용이 가능합니다. 보통 Sigmoid와 비교하는데 주로 미분한 결과를 보며 설명합니다. 왜 미분한 결과 일까요? ∴ 표현할 수 있는 기울기가 결국 출력될 수 있는 값이기 때문입니다. tanh그래프의 미분계수의 최댓값은 1입니다. sigmoid와 비교하여 최대값이 약 4배가 크고이는 약 4배 더 다양한 분석이 가능하다고 해석할 수 있습니다. ​ ​ ​ ​ 🤔 만약 이진분류가 아닌 다중 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:3","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 Softmax function 세 개 이상으로 분류하는 다중 클래스 분류에서 사용되는 활성화 함수입니다. N개의 class로 분류한다고 가정했을 때 Softmax함수는 들어오는 값들을 확률값으로 바꿔줍니다. 예를 들어 어떤 이미지가 주어지고 이것이 사과인지, 배인지, 귤인지 판단해야 할 때, Softmax함수는 사과일 확률, 배일 확률, 귤일 확률을 출력해줍니다. 즉, Output은 class 별 확률이고 class별 출력값의 총합은 1이 되어야합니다. class별로 확률을 알려주다보니, 출력 노드에서 확률을 확인하고 이를 최종결과로 반영하는 상황에서 많이 사용됩니다. 근데, 위의 Softmax공식을 보니 자연 상수e를 사용하고 있습니다. 왜 ‘자연 상수e’일까요? 그 이유는 크게 2가지가 있습니다. 미분이 쉽습니다. ( == 값을 계산하기 용이하다.) 큰 값은 더 크게, 작은 값은 더 작게 가중치를 주어 확률을 계산합니다. 예로 0.1, 1.0, 2.0의 입력값을 Softmax로 출력해보면 0.03, 0.33, 0.63가 아닌 0.1, 0.2, 0.7이 나옵니다. Softmax는 1과 2가 아닌 e^1 (2.718), e^2 (7.389)로 확률을 계산합니다. 즉 입력값이 커짐에 따라 기울기가 증가하며 더 큰 차이를 만들며, Soft하게 “Max\"한 값을 선정하는데 용이합니다. ​ ​ ​ 🤔 Gradient Vanishing 문제가 없는활성화 함수가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:4","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 ReLU(Rectified Linear Unit) function 가장 많이 사용되는 활성화 함수 중 하나입니다. 음수를 입력하면 0을 출력하고, 양수를 입력하면 입력값을 그대로 반환 =\u003e Output은 0 이상의 실수 tanh함수 대비 약 6배 빠른 속도로 학습이 가능하고, Gradient Vanishing가 발생하지 않습니다. 주로 hidden Layer에 사용됩니다. ReLu의 문제점은 음수 값은 무조건 0으로 처리하기 때문에 학습 능력이 감소한다.는 것에 있습니다. 이를 죽은 렐루(Dying ReLU)라고 합니다. 그리고 이 문제를 완화하기 위해 Leaky ReLu함수가 등장하였습니다. ​ ​ ​ ​ 🤔 ReLU의 음수값을 살린를 학습법이필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:5","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"🔗 Leaky ReLU function 위 그래프에서 공식 αx (x ≤ 0)에서 α는 사용자가 지정하는데 ‘매우 작은 수‘로 지정하며 보통 0.01로 설정합니다. ReLU에서 음수값을 물이 누수(Leaky)되듯이 매우 작게나마 표시해주는 함수입니다. ​ ​ ​ ​ ​ ​ ​ ​ 이밖에도 많은 활성화 함수가 있으니 더 찾아보는 것을 추천합니다. ​ ​ ​ 👀참고 일반적으로는 ELU -\u003e LeakyReLU -\u003e ReLU -\u003e tanh -\u003e sigmoid 순으로 사용한다고 한다. cs231n 강의에서는 ReLU를 먼저 쓰고, 그 다음으로 LeakyReLU나 ELU 같은 ReLU Family를 사용하며, sigmoid는 사용하지 말라고 하고 있습니다. chain rule은 두 함수를 합성한 합성 함수의 도함수(derivative)에 관한 공식입니다. chain rule = 연쇄법칙 = 합성함수의 미분법. 합성 함수 두 개 이상의 함수를 하나의 함수로 결합하여 만들어진 함수. 어떤 함수 속에 또 다른 함수가 들어있고, 그 또 다른 함수 속에 다른 함수가 들어있다. ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:1:6","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["AI","Activation Function"],"content":"참고한 글 https://kejdev.github.io https://wooono.tistory.com/209 https://inhovation97.tistory.com/30 ","date":"2021-06-24","objectID":"https://colinder.github.io/activation-function/:2:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation-function/"},{"categories":["Vue"],"content":"​ A Singularity in vue3. vue2. 버전의 프로젝트 경험만 있었기에 최근에 새롭게 웹 개발 프로젝트를 준비하면서 변화된 Vue3. 버전에 대한 몇 가지 내용들을 정리합니다. ​ ","date":"2021-06-23","objectID":"https://colinder.github.io/09_vue3._global_variable/:0:0","tags":["Vue"],"title":"09_Vue3. global variable","uri":"https://colinder.github.io/09_vue3._global_variable/"},{"categories":["Vue"],"content":"Vue3. 전역 변수(Global Variable) 등록 간단하게 axios를 사용해보려고 했는데 Vue2. 버전과 Vue3. 버전의 main.js 초기 세팅이 달랐습니다. 한참을 헤매다 방법을 찾아 기록으로 남김니다. ​ 1. 프로젝트 생성 후 axios 설치 # 프로젝트 폴더(package.json이 있는 폴더)에서 npm install axios ​ 2. 전역 설정을 위한 main.js 수정 // main.js 초기 모습 import { createApp } from 'vue' import App from './App.vue' import router from './router' createApp(App).use(router).mount('#app') // main.js 변경 import { createApp } from 'vue' import App from './App.vue' import router from './router' import axios from 'axios' //👈 const app = createApp(App) //👈 app.use(router) //👈 app.mount('#app') //👈 app.config.globalProperties.$axios = axios //👈 // 위에서 $axios가 axios를 담은 변수 명. ​ 3. 사용하기 // 사용하려는 .vue 파일에서 methods: { axiosTest: function() { this.$axios.get('https://jsonplaceholder.typicode.com/users/2') //👈 this.변수 형태로 사용 .then(res =\u003e console.log(res)) .catch(error =\u003e console.error(error)) } } ","date":"2021-06-23","objectID":"https://colinder.github.io/09_vue3._global_variable/:1:0","tags":["Vue"],"title":"09_Vue3. global variable","uri":"https://colinder.github.io/09_vue3._global_variable/"},{"categories":["web"],"content":"​ 🎈질문을 받았습니다. 저희는 이전에는 django로 풀스택 개발을 했어요. 개발자님은 django - vue.js로 개발을 하신다고 들었는데, vue는 javaScript 언어고 django는 Python 언어인데 둘이 뭔가 통신? 데이터를 주고 받고 하는 것에 있어서 문제는 없나요? 또 같은 javaScript 언어인 node.js 라는 것으로도 Backend 개발이 가능하다고 봤는데 node.js를 Backend로 개발하는 것이, 같은 javaScript로 개발하니까 더 효율적? 좋은거 아닌가요? ​ ","date":"2021-06-22","objectID":"https://colinder.github.io/django-vs-node.js-%EC%A7%88%EB%AC%B8%EC%9D%84-%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/:0:0","tags":["web"],"title":"Django vs Node.js 질문을 받았습니다.","uri":"https://colinder.github.io/django-vs-node.js-%EC%A7%88%EB%AC%B8%EC%9D%84-%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"},{"categories":["web"],"content":"👨‍💻 하나는 명확히 답을 드릴 수 있는데, 하나는 모르겠네요. 알아보고 말씀드리겠습니다 . ​ Vue는 javaScript고 django는 Python인데 둘이 뭔가 통신? 데이터를 주고 받고 하는 것에 있어서 문제는 없나요? =\u003e 네 없습니다. 아마 기존에 django로 풀스택 개발한 코드를 보면 JSON 아니면, XML이라는 표기법(혹은 문법)으로 frontend와 backend 간에 데이터를 주고 받았을 것입니다. 저는 JSON, XML만 알고 있어서 frontend와 backend간에 데이터 통신을 하는 표기법에 대하여 조사를 해보면 더 많은 방법이 있겠지만, 요새는 거의 JSON만 사용하는 것으로 알고 있습니다. python기반의 django로 웹을 개발하더라도 frontend는 html문법으로 개발하기 때문에 python을 할 줄아는 것이 무의미합니다. 결론으로 frontend와 backend 간에 데이터를 주고 받는 것은 python이 아닌 별도의 표기법(JSON or XML 등)을 따르기 때문에 문제는 없습니다. ​ 같은 javaScript언어를 사용하는 node.js를 활용해 Backend개발을 하는 것이 더 효율적? 좋은거 아닌가요? =\u003e 어느쪽이 더 좋다는 명확한 답을 드리기 어렵습니다. (솔직히 잘 모르겠습니다.) 정확하게는 node.js의 웹개발 프레임워크인 express.js랑 비교해야 할 것 같은데요. 자료를 찾아보니 static site는 node.js가 유리하고, dynamic site는 Django가 유리하다고 합니다. 저는 dynamic site를 CRUD가 필요한 site라고 이해하고 있습니다. 사용자 반응에 따라 다른 화면이 구성되어야 하는 site를 기획한다면, Django는 이부분에 강점이 있습니다. (ex. instargram) 반면 API와 실시간 기능이 필요하다면 이는 static site고 이때는 django보다 속도가 빠른 node.js가 유리합니다. 그런데 개인적으로 본인에게 편한 언어로 개발하는 것이 제일 유리하다고 생각합니다. 이 방법이 결국에는 가장 빠르고 효율적인 개발을 할 수 있을 것이라고 생각하기 때문입니다. (저는 python이 편합니다.ㅎ) 부가적으로 사용자는 이를 고려할 필요가 없습니다. 사용자는 개발자들이 서버에서 처리한 웹페이지를 보기 때문입니다. 또 static site에도 javaScript를 활용해 동적인 처리를 하는 경우도 많아, 칼 처럼 구분지을 필요도 이유도 없을 것 같습니다. ","date":"2021-06-22","objectID":"https://colinder.github.io/django-vs-node.js-%EC%A7%88%EB%AC%B8%EC%9D%84-%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/:0:1","tags":["web"],"title":"Django vs Node.js 질문을 받았습니다.","uri":"https://colinder.github.io/django-vs-node.js-%EC%A7%88%EB%AC%B8%EC%9D%84-%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"​ Collaborative filtering by auto Encoder 협업필터링을 딥러닝 방식의 하나인 오토 인코더로 구현하는데 알아두어야 할 배경지식에 대하여 정리 ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/:0:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Machine learning 기계가 명시적으로 코딩되지 않은 동작을 스스로 학습해 수행하게 하는 연구 분야. 인공지능(AI)의 한 분야로 간주된다. 기계 학습의 핵심은 표현(representation)과 일반화(generalization)에 있다. 표현이란 데이터의 평가이며, 일반화란 아직 알 수 없는 데이터에 대한 처리이다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/:1:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"What’s the difference with ‘Deep learning’? Machine learning은 어떤 문제와 답을 막 던져주면 기계가 계속 풀어내면서 추상적인 원리를 스스로 깨우치고 새로운 문제가 주어져도 스스로 답을 낼 수 있게 하는 것이다. Deep learning은 Machine learning보다 조금 더 편리?한 방법이라고 할 수 있다. Machine learning의 경우 알고리즘에 입력 하기 전 필요한 특징을 사람이 직접 선정해야 한다. 예를 들어 사람의 나이를 추정한다고 하면, 얼굴의 주름 개수, 피부 색상의 균일도, 특정 주름의 짙은 정도, 머리카락의 색깔과 같이 나이를 추정하는 데에 유용한 ‘특징’을 사람이 알려주어야(선택) 특징을 기준으로 기계가 학습한다. Deep learning의 경우에는 ‘특징’을 선정하는 부분까지 기계가 직접 선택해 학습한다. 머신러닝과 달리 사람 얼굴을 찍은 사진을 입력으로 넣어주면, 스스로 어떤 특징이 나이를 추정하는 데에 유용한지 분석한다. 그런 식으로 사람이 좀 더 손을 대 줘야 하던 부분들을 컴퓨터가 더 많이 처리해주는 편리함이 강점이다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/:2:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Collaborative Filtering 많은 사용자들로부터 얻은 기호정보(taste information)에 따라 사용자들의 관심사를 자동적으로 예측하게 해주는 방법이다. 협력 필터링 접근법의 근본적인 가정은 사용자들의 과거의 경향이 미래에서도 그대로 유지 될 것이라는 전제에 있다. 예를 들어, 음악에 관한 협력 필터링 혹은 추천시스템(recommendation system)은 사용자들의 기호(좋음, 싫음)에 대한 부분적인 목록(partial list)을 이용하여 그 사용자의 음악에 대한 기호를 예측하게 된다. 이 시스템은 특정 사용자의 정보에만 국한 된 것이 아니라 많은 사용자들로부터 수집한 정보를 사용한다는 것이 특징이다. 이것이 단순히 투표를 한 수를 기반으로 각 아이템의 관심사에 대한 평균적인 평가로 처리하는 방법과 차별화 된 것이다. 즉 고객들의 선호도와 관심 표현을 바탕으로 선호도, 관심에서 비슷한 패턴을 가진 고객들을 식별해 내는 기법이다. 협업 필터링의 종류에는 Memory-based, Model-based, Hybrid 가 있지만 이중에서 간단하게 구현할 수 있으며, 적당히 합당한 결과를 도출하는 Memory-based 협업 필터링을 사용한다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/:3:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Auto Encoder 오토인코더(Autoencoder)는 아래의 그림과 같이 단순히 입력을 출력으로 복사하는 신경망. Auto Encoder의 신경망 구조는 input과 output이 동일하며 좌우를 대칭으로 구축된 구조이다. 어떻게 보면 간단한 신경망처럼 보이지만 네트워크(hidden layer)에 여러가지 방법으로 제약을 줌으로써 어려운 신경망으로 만들어 사용한다. 예를들어 아래 그림처럼 hidden layer(회색 동그라미)의 뉴런 수를 input layer(입력층)보다 작게해서 데이터를 압축(차원을 축소)한다거나, 입력 데이터에 노이즈(noise)를 추가한 후 원본 입력을 복원할 수 있도록 네트워크를 학습시키는 등 다양한 오토인코더가 있다. 이러한 제약들은 오토인코더가 단순히 입력을 바로 출력으로 복사하지 못하도록 방지하며, 데이터를 효율적으로 표현(representation)하는 방법을 학습하도록 컨트롤한다. ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/:4:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative-filtering-by-auto-encoder/"},{"categories":["web"],"content":"​ form 태그의 고찰 form tag의 inline 요소 중 **‘action’**과 ‘onsubmit’ \u003cform action=\"/oh my god\" onsubmit=\"return test()\"\u003e \u003cinput type=\"submit\" value=\"hahaha\"\u003e \u003c/form\u003e \u003cscript\u003e function test(){ console.log('HHHI') } \u003c/script\u003e submit 형태의 input을 클릭하게 되면, submit이 동작하면서 form의 ‘onsubmit’이 실행 이후 에 form 태그의 ‘action’이 실행 즉, 두가지의 행동이 실행됩니다. ​ 비효율적이지만, 만약 위와 같은 코드에서 나중에 실행되는 action은 동작하지 않게 하고 싶다면. \u003cform action=\"/oh my god\" onsubmit=\"return test()\"\u003e \u003cinput type=\"submit\" value=\"hahaha\"\u003e \u003c/form\u003e \u003cscript\u003e function test(){ console.log('HHHI') return false; //👈 이것을 넣어줘서 action에 false를 전달해 동작을 막음 } \u003c/script\u003e ​ ","date":"2021-06-10","objectID":"https://colinder.github.io/form/:0:0","tags":["html","web","form"],"title":"form 태그","uri":"https://colinder.github.io/form/"},{"categories":["NLP"],"content":"‘NAVER’ HyperCLOVA의 한국어 모델 2021.05.25 NAVER AI NOW reference 내용 중 HyperCLOVA의 자연어 전처리 과정의 토근화 방법에 대하여 정리 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:0:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"데이터 토큰화 자연어 처리를 위한 문장 데이터 토큰화에 대한 NAVER의 처리 방법을 정리해보겠습니다. 말뭉치를 어떻게 구성하고 나눌 것인가에 대한 고민 → 서브워드 토크나이저를 활용. 서브워드는 어떤방식으로 진행할 것인가? → Byte-Pair Encoding (BPE)를 사용 그 중에서도 Morpheme-Aware Byte-Level BPE (형태소 단위 분리)을 사용 Morpheme-Aware Byte-Level BPE는 많은 메모리를 필요로 하여 말뭉치 데이터의 크기를 최적화하는 것이 필요함. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:1:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"서브워드란? 자연어 처리를 하려면 기계가 문장을 끊어 읽을 수 있게 만들어줘야 합니다. 이를 보통 토크나이징(tokenizing)이라고 하며 나눠진 단어나 형태소를 토큰이라고 합니다. 하지만 토큰은 ‘문장’에서 추출한 데이터고 / ‘문장’은 작성한 사람에 따라 구성이 다르기도 하며, 신조어를 사용하는 등 고려해야하는 사항이 많습니다. 특히 Out of Vocabulary(OOV) 미등록 된 단어의 문제는 자연어 처리에 있어서 해결이 어려운 이슈사항입니다. 그리고 이를 보완하기 위해 Subword 방식이 대두되었습니다. 하나의 단어는 더 작은 단위의 의미있는 여러 서브워드들의 조합으로 구성된 경우가 많기 때문에, 하나의 단어를 여러 서브워드로 분리해서 기계어로 변환하기 위한 작업입니다. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:2:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"BPE(Byte Pair Encoding) BPE은 압축 알고리즘으로 연속적으로 가장 많이 등장한 글자의 쌍을 찾아서 하나의 글자로 병합하는 방식을 수행합니다. # dictionary l o w : 5, l o w e r : 2, n e w e s t : 6, w i d e s t : 3 딕셔너리를 참고로 한 초기 단어 집합(vocabulary)을 아래와 같습니다. 간단히 말해 초기 구성은 글자 단위로 분리된 상태입니다. # vocabulary l, o, w, e, r, n, w, s, t, i, d BPE의 특징은 알고리즘의 동작을 몇 회 반복(iteration)할 것인지를 사용자가 정한다는 점입니다. 여기서는 총 10회를 수행한다고 가정합니다. 다시 말해 가장 빈도수가 높은 유니그램의 쌍을 하나의 유니그램으로 통합하는 과정을 총 10회 반복합니다. 위의 딕셔너리에 따르면 빈도수가 현재 가장 높은 유니그램의 쌍은 (e, s)입니다. 1회 - 딕셔너리를 참고로 하였을 때 빈도수가 9로 가장 높은 (e, s)의 쌍을 es로 통합합니다. # dictionary update! l o w : 5, l o w e r : 2, n e w es t : 6, w i d es t : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es 2회 - 빈도수가 9로 가장 높은 (es, t)의 쌍을 est로 통합합니다. # dictionary update! l o w : 5, l o w e r : 2, n e w est : 6, w i d est : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est 3회 - 빈도수가 7로 가장 높은 (l, o)의 쌍을 lo로 통합합니다. # dictionary update! lo w : 5, lo w e r : 2, n e w est : 6, w i d est : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est, lo 이와 같은 방식으로 총 10회 반복하였을 때 얻은 딕셔너리와 단어 집합은 아래와 같습니다. # dictionary update! low : 5, low e r : 2, newest : 6, widest : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est, lo, low, ne, new, newest, wi, wid, widest 출처 https://wikidocs.net/22592 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:3:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"Morpheme-Aware Byte-Level Byte Pair Encoding Byte Pair Encoding을 한국어를 형태소 수준으로 나누어 진행 ex) ‘나는 배가고프다.’ → ‘나’, ‘는’, ‘배’, ‘가’, ‘고’, ‘프’, ‘다’. 로 나누어 Byte Pair Encoding을 진행 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:4:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"서브워드로 나눈 말뭉치의 크기는 얼마나 설정할 것인가? 일반적으로 자연어 말뭉치에 사용된 단어를 빈도순으로 나열했을 경우 지프의 법칙(Zipf’s Law)을 따름. Zipf’s Law : 어떠한 자연어 말뭉치 표현에 나타나는 단어들을 그 사용 빈도가 높은 순서대로 나열하였을 때, 모든 단어의 사용 빈도는 해당 단어의 순위에 반비례한다. 따라서 가장 사용 빈도가 높은 단어는 두 번째 단어보다 빈도가 약 두 배 높으며, 세 번째 단어보다는 빈도가 세 배 높다. 한가지 예로 약 135개 항목의 어휘만으로 브라운 대학 말뭉치의 절반을 나타낼 수 있었다. 1에 따라 네이버는 학습에 사용한 말뭉치 양의 차이에 따른 서브워드 토크나이저의 어위 집합에는 큰 차이가 없을 것으로 판단. 👉 네이버의 경우, 전체 말뭉치와 전체 말뭉치의 1% (20GB)로 서브워드 토크나이저를 실행한 결과를 비교해보니 어휘 집합 구성의 유사함을 확인. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:5:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"성능 평가 - 언어 생성관점 NAVER는 발전한 대규모 모델의 언어생성능력에 비해 기존의 평가 지표(품질: BLEU, ROUGE, METEOR… / 다양성: Self-BLEU, Distinct-N, Unique-N…)들이 여전이 2000년대 초반에 머물러 있다는 점을 파악 ‘생성 문장’과 ‘레퍼런스 문장’의 유사성이 더 이상 문장의 품질을 보장하지 않는다. 학습 어휘에 따라 성능에 차이가 발생함으로 perplexity(ppL)로 비교하는 것은 부적절하다. 펄플렉서티(perplexity)는 언어 모델을 평가하기 위한 내부 평가 지표. ‘perplexed’는 ‘헷갈리는’과 유사한 의미. 여기서 PPL은 ‘헷갈리는 정도’로 레퍼런스들과의 차이를 판별하는 지표로 이해하면 된다. 👉 네이버의 경우, ‘언어의 유창함’을 판별활 수 있는 모델을 만들어 자체적으로 성능을 평가함. ​ ​ 👀요약 NLP관련 자료와 여러 테스트를 해보니 ‘완벽한 토큰화’가 모델 성능에 큰 영향이 없는 것으로 보입니다. 또한 네이버는 작은 양의 데이터라면서 20GB의 자료를 사용해 학습한 결과를 내보였지만, _약 135개 항목의 어휘만으로 브라운 대학 홈페이지 말뭉치의 절반을 나타낼 수 있다._는 결과를 보며 자연어 처리 모델 학습에 많은 양의 토큰이 필요하지 않겠다는 생각이 들었습니다. 다만, 이번에 개발된 네이버의 자연어 처리기술이 한국어에 있어서는 가장 진보되었고 ‘사람다운’ 처리를 보여주는 것 같습니다 만약 일부라도 오픈소스로 풀린다면 시장에 독점적인 기술이 될 것으로 보입니다. ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:6:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["web"],"content":"​ 웹 개발을 위해 인터넷의 레퍼런스들을 참고하다보면, 눈에 띄는 기호가 있습니다. $ 이게 뭘까요.? 검색해보니 제이쿼리라는데 많이 쓰이는 것 같습니다. 이에 알아봅시다! ​ jQuery란? jQuery(제이쿼리)는 HTML의 클라이언트 사이드 조작(ex. 사용자가 어떤 버튼을 누른다. 사용자가 드랍박스에 선택지를 고른다.)을 단순화 하도록 설계된 크로스 플랫폼(여러 종류의 컴퓨터 플랫폼에서 동작할 수 있다는 것)의 자바스크립트 라이브러리다. 존 레식이 2006년 뉴욕 시 바캠프(Barcamp NYC)에서 공식적으로 소개하였다. 출처: 위키백과 최대한 구체적으로 알아보았는데요. 이 내용이 이해되었다면 다음으로 넘어갑시다. *라이브러리(library): 자주 사용하는 코드들을 재사용할 수 있는 형태로 가공해서 프로그래밍 효율을 높여주는 코드들. ​ jQuery를 왜 알아야 할까? 제가 생각하는 이유는 제이쿼리를 사용하면 짧고 단순한 코드로도 웹 페이지에 다양한 효과나 연출을 적용할 수 있기 때문입니다. 다양한 자바스크립트 라이브러리 중에서도 제이쿼리가 사용되는 이유는 다음과 같습니다. 제이쿼리는 주요 웹 브라우저의 구버전을 포함한 대부분의 브라우저에서 지원됩니다. HTML DOM을 손쉽게 조작할 수 있으며, CSS 스타일도 간단히 적용할 수 있습니다. 애니메이션 효과나 대화형 처리를 간단하게 적용해 줍니다. 같은 동작을 하는 프로그램을 더욱 짧은 코드로 구현할 수 있습니다. ✨레퍼런스가 많습니다.✨ 오픈 라이선스를 적용하여 누구나 자유롭게 사용할 수 있습니다. 개인적으로 특히 5번이 마음에 드는데요. 레퍼런스가 많아야 배우기 수월하다고 생각하기 때문입니다. ​ ​ JQuery의 문법 ","date":"2021-04-29","objectID":"https://colinder.github.io/what_is_jquery/:0:0","tags":["web"],"title":"What is jQuery($)?","uri":"https://colinder.github.io/what_is_jquery/"},{"categories":["Django"],"content":"​ Django Overriding Templates 웹개발을 하다보면 재활용되어야 하는 부분. 즉, 변경되지 않아야 하는 부분과, 변해야 하는 부분이 있습니다. (대표적으로 navbar) 그리고 이런 개발의 편의성을 위해 Django는 Overriding 이라는 기술을 제공합니다. ​ 지난 “app\"에 이어 진행 변경되지 않아야 하는 부분은 그림의 ‘배경’이고, 변해야 하는 부분은 그림의 ‘디테일 요소’라고 생각하면 이해가 쉽습니다. / 그럼 변경되지 않아야 하는 부분을 먼저 제작해봅시다. ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:0","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"1. 변경 하지 않을 부분 == 배경 제작 \u003c!-- /templates/base.html 생성 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"background-color: green\"\u003e여기는 base.html Overriding templates\u003c/h1\u003e 👈 {% block body %} 👈 body 시작 위치 {% endblock %} 👈 body 종료 위치 \u003c/body\u003e \u003c/html\u003e ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:1","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"2. 배경을 setting.py에 등록 ## blog/setting.py BASE_DIR = Path(__file__).resolve().parent.parent ... ... TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR / 'templates'], # 👈👈 '/'로 구분합니다. 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] ✨Point 1. TEMPLATES정보를 등록하는데, DIRS(디렉토리)가 BASE_DIR부터 'blog', 'templates' 주소 안에 있다.는 뜻. ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:2","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"3. 변해야 하는 부분 == 디테일 요소 제작 \u003c!-- articles/templates/articles/overriding.html 생성 --\u003e {% extends 'base.html' %} 👈 setting.py에서 등록한 templates인 base.html을 불러오겠다. {% block body %} 👈 base.html의 body 시작위치 \u003cdiv\u003e \u003ch1\u003eOverriding 페이지입니다.\u003c/h1\u003e \u003c/div\u003e {% endblock %} 👈 base.html의 body 종료위치 templates설정이 완료되었으니 이제 url을 연결해주어야 합니다. ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:3","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"4. url 설정 도메인 root주소/overriding으로 접속하면 위에서 구현한 화면이 보이도록 만들어 보겠습니다. ## articles/urls.py from django.urls import path, include from . import views urlpatterns = [ path('', views.main), path('overriding/', views.overriding), # 👈 ] ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:4","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"5. views.py 설정 urls.py에서 views의 overriding함수를 실행한다고 구현했으니 overriding함수를 만들어 봅시다. ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') def overriding(request): # 👈 return render(request, 'articles/overriding.html') # 👈 3.에서 만든 overriding.html을 노출 ​ ​ 완성된 화면은 아래와 같습니다. ​ ​ 👀요약 프로젝트를 진행하다 보면, 생각보다 변하지 않아야 하는 부분과, 변해야 하는 부분의 고려가 간단하진 않습니다. 하지만, templates의 재사용성을 높이는 방식으로 개발하는 것이 편리한 경우가 많이 있으니, 잘 알아보고 기획해서 사용하면 좋습니다. ​ ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:5","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"​ Django_form 이제 여러 html파일을 만들어 여러 화면을 돌아다닐 수 있게 되었습니다. 그렇다면 A화면에서 입력한 정보를 B화면으로 가져가고 싶다면 어떻게 해야 할까요? form테그를 사용하면 됩니다. ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:0","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"👨‍💻 개발해봅시다. 기존에 만들었던 main.html을 활용해 만들어 보겠습니다. ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:1","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"1. form 태그 생성 \u003c!-- articles/templates/articles/main.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003emain 페이지 입니다.\u003c/h1\u003e \u003cform action=\"/articles/output\"\u003e 👈 action = form으로 입력된 정보를 보낼 곳입니다. 제목 : \u003cinput type=\"text\" name=\"title\"\u003e 👈 입력된 text타입 정보를 title이라는 이름으로 할당 내용 : \u003cinput type=\"text\" name=\"content\"\u003e 👈 입력된 text타입 정보를 content라는 이름으로 할당 \u003cbutton type=\"submit\" \u003e 제출 \u003c/button\u003e 👈 button을 누르면 form의 action주소로 이동 \u003c/form\u003e 👈 \u003c/body\u003e \u003c/html\u003e ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:2","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"2. urls.py 설정 위에서 articles/output으로 데이터를 보냈으니 ## articles/urls.py from django.urls import path, include from . import views urlpatterns = [ path('', views.main), path('overriding/', views.overriding), path('articles/output/', views.output), 👈 ] ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:3","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"3. views.py 설정 위에서 articles/output/ 로 접속하면 views의 output함수를 동작시킨다고 선언했으니. ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') def overriding(request): return render(request, 'articles/overriding.html') def output(request): 👈 output함수 선언 title = request.GET.get('title') 👈 output함수의 request에서 title항목 추출 content = request.GET.get('content') 👈 output함수에 request에서 content항목 추출 context = { 👈 추출한 두 요소를 context라는 하나로 묶고 'title':title, 👈 'content':content 👈 } 👈 return render(request, 'articles/output.html', context) 👈 render함수의 마지막 인자로 context 전달. ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:4","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"4. output.html 제작 \u003c!-- articles/templates/articles/output.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eoutput 페이지 입니다.\u003c/h1\u003e \u003ch2\u003e{{title}}\u003c/h2\u003e \u003ch3\u003e{{content}}\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e ​ 완성된 화면은 아래와 같습니다. main.html output.html ​ ​ ​ 👀요약 데이터를 주고 난 후 url을 보면 /?title=\"…\"\u0026content=\"…\"의 형태로 구성된 것을 볼 수 있습니다. 이는 앞으로 많이 보게 될 구성이니 익숙해지면 좋습니다. ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:5","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"​ Django_app 이번에는 생성된 프로젝트에서 1. app을 추가해 등록해보고 2. 서버 접속시 첫 메인 페이지를 제작해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:0:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"뜬금없이 CRUD를 알아보고 갑시다. CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말입니다. 사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신 등) 중 가장 기본이라고 생각되는 기술들입니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"이제 이어서 개발해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:1","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"1. App 생성 지난번에는 프로젝트를 생성하고 setting.py에서 기본 설정만 변경해주었습니다. 이제 app을 생성해봅시다. ## DJ폴더 안에서 django-admin startproject blog / django-admin startproject blog . 두가지 중 ## 후자로 프로젝트를 생성하고 진행하겠습니다. 그러면 폴더 구조가 아래와 같습니다. # DJ # blog # manage.py \u003e python manage.py startapp articles # articles라는 app을 manage.py라는 python파일로 만들겠다. # 입력 후 폴더 구조 # DJ # blog # manage.py # articles 👈👈 ✨Point 1. 명령어는 manage.py가 있는 root폴더안에서 입력해야 합니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:2","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"2. 생성한 app을 프로젝트 폴더(blog)에 등록합니다. ## blog/setting.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'articles', #👈👈 ] 잠시 django의 개발 패턴을 보면 url로 요청을 접수한다는 것을 알 수 있습니다. urls.py로 들어오는 요청을 접수해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:3","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"3. urls.py 등록 ## blog/urls.py \"\"\"blog URL Configuration The `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/3.2/topics/http/urls/ Examples: Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path('', views.home, name='home') Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path('', Home.as_view(), name='home') Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path('blog/', include('blog.urls')) \"\"\" from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('', include('articles.urls')), #👈👈도메인 ''로 접속시 articles.urls로 요청을 보낸다. ] ✨Point 1. 상단에 주석처리되어있는 내용을 읽어보며, 어떻게 url설정을 하는지 파악하는 것이 중요합니다. 이어서 articles 폴더에 urls.py 파일을 만들고 url을 만들어 줍시다. ## articles/urls.py 생성 from django.urls import path from . import views #👈👈 articles 폴더에 있는 views.py폴더 사용할 수 있게 등록. urlpatterns = [ path('', views.main), #👈👈도메인 ''로 접속시 views에 있는 main함수를 동작한다. ] ✨Point 1. blog/urls → articles/urls → articles/views 로 요청을 전달하는 과정을 이해하는 것이 중요합니다. ​ ​ 이제는 views를 설정합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:4","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"3. articles/views.py 세팅 ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') #👈👈 main함수는 render함수를 사용해 인자로 받은 request를 articles/main.html에 담아 사용자에게 보여준다. # 아직 articles/main.html파일이 없습니다. 이제 우리가 사용자에게 응답할 페이지를 만들어야 합니다. ​ ​ 이제 마지막 templates를 설정합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:5","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"4. articles/templates/articles/main.html 생성 ## articles/templates/articles/main.html 생성 # !+tab 하면 html 기본 프레임이 나옵니다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003emain 페이지 입니다.\u003c/h1\u003e #👈👈 \u003c/body\u003e \u003c/html\u003e ​ ​ 완성된 화면은 아래와 같습니다. ​ ​ ​ 👀요약 폴더 구조를 이해하면서 진행합시다! ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:6","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"더 알아보기 1️⃣ urls.py를 통해 요청을 전달할때 왜? include를 사용했을까요? django공식문서에는 아래와 같이 설명합니다. ​ 2️⃣ 왜 templates를 만드는데 articles폴더를 안에 하나 더 만들까요? ∴ 이는 1. templates 상속시 오류를 없게 하기 위함과 2. 대규모 프로젝트의 경우 하나의 app안에 다양한 templates 구성이 있는 경우 관리의 편리성 때문입니다. ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:2:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"참고 했던 글 https://senticoding.tistory.com/77 ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:3:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"Django 개발환경준비 편리함을 추구하기 위해 AWS Cloud9을 사용하여 진행 https://ide.cs50.io/ 주소로 접속하면 진행이 가능하며, 진행을 위해선 Git 아이디가 있어야 한다. Git? : 버전 관리 시스템이며 Git은 소프트웨어를 개발하는 기업의 핵심 자산인 소스코드를 효과적으로 관리할 수 있게 해주는 무료, 공개소프트웨어. git에 대한 내용은 따로 정리해보도록 한다. 로그인까지 마치면 이제 Django 개발 준비 끝. ​ 👏 21.04.18 기준 django : 3.2 V 으로 다시 정리 합니다. 개발은 로컬(내 PC)진행합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:0","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"1. DJango 설치 ## 개발을 진행하려는 폴더에서 \u003e pip install django # 설치가 진행될 것입니다. # 저는 DJ라는 폴더를 생성하고 진행하였습니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:1","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"2. 프로젝트 생성 \u0026 구동 확인 ## 1. 프로젝트 생성 # case 1 \u003e django-admin startproject blog # blog라는 root폴더를 만들고 django프로젝트를 시작 # case 2 \u003e django-admin startproject blog . # . 을 붙이면, root폴더 생성없이 django프로젝트 시작 #========================================================================================# ## 2. 프로젝트 구동 테스트 \u003e cd blog # blog 폴더로 \u003e python manage.py runserver 8080 # 프로젝트 구동 / 8080은 생략가능 ✨Point 1. blog라는 이름(root폴더)은 내가 원하는 프로젝트 명으로 변경이 가능 2. cd blog → django의 명령어는 모두 manage.py가 존재하는 폴더안에서 실행해야 함, 이를 위한 이동 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:2","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"3. 기본 설정(setting.py) 등록 # settings.py # 웹 사용자를 특정하는 부분 ALLOWED_HOSTS = ['*'] # '*' == 모든 사용자가 입장가능 # 프로젝트에 사용되는 APP 및 기능들을 등록 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] ... ... LANGUAGE_CODE = 'ko-KR' #한글로 설정 변경 TIME_ZONE = 'Asia/Seoul' #시간대 서울로 변경 이와 같은 화면이 나오면 Basic Setting 완료입니다. ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:3","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"더 알아보기 1️⃣ python manage.py runserver 8080 입력시 붉은 오류가 보일 수 있습니다. ‘python manage.py migrate’를 진행하라는 말 같은데 해당 내용은 나중에 ‘model’이라는 것을 설정할 때 자세히 보겠습니다. django의 공식문서 역시 지금 단계에서는 아래와 같이 안내합니다. ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:1:0","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"​ Web ? 월드 와이드 웹(World Wide Web)이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미하며, 줄여서 WWW나 W3라고도 부르며, 간단히 웹(Web)이라고 가장 많이 불린다. 인터넷과 같은 의미로 많이 사용되고 있지만, 정확히 말해 웹은 인터넷상의 인기 있는 하나의 서비스일 뿐. Web의 작동방식을 간단히 설명하자면, 요청과 응답. 사용자는 서버에 어떠한 요구사항을 요청하고 서버는 이에 따라 처리결과를 응답한다. 예를들어 사용자가 Login 버튼을 누른 행위는 user가 서버에 로그인 하고 싶다고 요청한 것이며, 서버는 로그인 창을 띄움으로서 user가 로그인할 수 있게 응답한 것입니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:0:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"web Protocal 요청에 대한 응답을 처리할 서버를 만드는 것이 Django ​ Django ? python 기반의 web framework ​ framework? : web 개발시 어려움을 줄이는데 목적이 있는 기능을 통칭 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:1:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"Django의 개발 방식 (MTV) Django의 개발 방식은 MTV(Model, Template, View) 패턴을 따른다. Model: data를 구성 Template: 사용자(User)에서 보여주는 화면을 구성 (HTML로 구현) View: data 처리 및 전달 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:2:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"Django_basic 장고는 하나의 프로젝트 단위로 web을 개발한다. 프로젝트 안에는 여러 app별로 기능을 나누어 구성한다. ​ ex) 회원들 계정을 관리하는 app (accounts) / 게시판을 관리하는 app (articles) 등등 요청은 Url로 접수하고 (ex. 게시판으로 이동하고 싶어 게시판 버튼을 클릭) 접수된 내용을 View에서 처리 (ex. 게시판버튼을 클릭하면 게시판 화면을 사용자에게 보여주게 구성) 처리한 화면을 Template로 꾸며(구성해) 사용자에게 응답 ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:3:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["programmers"],"content":"​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:0","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"타겟 넘버 numbers = [1, 1, 1, 1, 1] target = 3 # return = 5 from itertools import product l = [(-number, number)for number in numbers] s = list(map(sum, product(*l))) print(s.count(target)) ## 미쳤다. product().. ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:1","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"K번째 수 array = [1, 5, 2, 6, 3, 7, 4] commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]] def solution(array, commands): answer = [] for _ in commands: i, j, k = _ q = array[i-1: j] q.sort() answer.append(q[k-1]) return answer print(solution(array, commands)) ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:2","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"다리를 지나는 트럭 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 from collections import deque truck_weights = deque(truck_weights) bridge = deque([0 for _ in range(bridge_length)]) time = 0 bridge_weight = 0 #현재 다리를 건너고 있는 무게 # bridge = [0, 0] while(len(bridge)) != 0 out = bridge.popleft() bridge_weight -= out time += 1 if truck_weights: if bridge_weight + truck_weights[0] \u003c= weight: left = truck_weights.popleft() bridge_weight += left bridge.append(left) else: bridge.append(0) ## 다리가 지나는 위치를 bridge로 표현하고 디큐를 이용해 속도를 올린다. ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:3","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SW Expert Academy"],"content":"D4_11316_주기 찾기 for T in range(int(input())): s, p, q, m = map(int, input().split()) V = s visited = [0]*m i = 1 while True: V = (p*V + q) % m i += 1 if visited[V] != 0: result = i - visited[V] break visited[V] = i print(f'#{T+1} {result}') # 한 번 나왔던 숫자의 '위치 정보(i)'를 # visited에 저장해 두었다가 # 한 번이라도 방문했던 숫자가 나왔을 때 # 저장해주었던 '위치 정보'의 차리를 계산해 준다. # 코딩중. # 만약 [6,8,6,4,3,5,4,3,5,4,3,5...] 경우가 있을 수 있나? 는 고민으로 # 시간을 썼으나. # 문제 조건 중 # 슈도랜덤 제너레이터의 주기란, # 어떤 정수 n0 이상인 '모든 n에 대해' An+p = An을 만족하는 가장 작은 자연수 p # 라는 내용을 보고, 반복되는 수의 등장은 동일 배열 순환의 시작이라고 파악해야 했다. ​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SQLD"],"content":"​ # SQLD 제2 장 데이터 모델과 성능 ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:0:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"제1 절 성능데이터모델링의 개요 성능데이터모델링의 정의 데이터 용량이 커질수록 처리 속도 증가가 필요해진다. 성능 저하의 대표적인 원인 3가지 데이터 모델 구조에 의해 성능 저하 데이터가 대용량이 됨으로 인해 성능 저하 인덱스 특성을 고려하지 않고 생성해 성능 저하 즉, 어떤 작업 유형에 따라 성능향상을 도모해야 하는지 목표를 분명하게 해야 정확한 성능향상 모델링을 할 수 있다. ​ 성능데이터모델링 수행 시점 사전에 할수록 비용이 줄어들며, 특히 분석/설계단계에서 데이터베이스 처리 성능을 향상시킬 수 있는 방법을 고려하면 좋다. ​ 성능데이터모델링 고려사항 데이터 모델링을 할 때 정규화를 정확하게 수행한다. 데이터베이스 용량산정을 수행한다. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다. 용량과 트랜잭션의 유형에 따라, 반정규화를 수행한다. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다. 성능관점에서 데이터 모델을 검증한다. ​ ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:1:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"제2 절 정규화와 성능 정규화를 통한 성능 향상 전략 정규화는 기본적으로 데이터에 대한 중복성을 제거하고, 데이터가 관심사별로 처리되는 경우가 많아 대부분 성능을 향상시키는 특징이 있다. 다만, 성능을 판단할 때 (조회)와 (입력,수정,삭제) 두 부류로 구분하여 고려한다. “엔터티가 많은 경우” 다량의 JOIN이 발생하고 그런 경우 보통 (조회) 성능은 하락하고 / (입력,수정,삭제) 성능은 향상된다. 1차 정규화 : table의 cell값은 원자 값을 가져야한다. == 중복된 값을 제거 or 분할. (row, column 모두) 행(row) 정규화 1차 정규화 전\r student age subject 보리 1 수학, 과학 쌀 2 수학 수수 3 수학 1차 정규화 후\r student age subject 보리 1 수학, 과학 보리 1 과학 쌀 2 수학 수수 3 수학 ​ 열(column) 정규화 ​ ​ 2차 정규화 : 테이블의 부분함수적 종속 제거 == 테이블 값이 완전 함수적 종속인지 확인해야 한다. *완전 함수적 종속 : 기본키가 아닌 컬럼중에 특정 기본키에만 종속하는 부분적 종속이 없는 상태. 1차 정규화가 된 table에서 기본키는 (student, subject). 그 이유는 학생과 과목을 알아야 레코드를 구분할 수 있기 때문이다. 그렇다면 기본키가 아닌 age속성은 student와 subject 두 개의 속성 모두에 종속인지 확인해보면 된다. age속성는 student에만 종속되어있기 때문에 2차 정규화의 조건인 완전함수적 종속에 위배된다. 즉, age 속성은 student 의 이름만 알아도 찾을 수 있는 속성 ​ 2차 정규화 전\r student age subject 보리 1 수학, 과학 보리 1 과학 쌀 2 수학 수수 3 수학 ​ 2차 정규화 후\r*학생 테이블 student age 보리 1 쌀 2 수수 3 *과목 테이블 student subject 보리 수학 보리 과학 쌀 수학 수수 수학 ​ ​ 3차 정규화 : 기본키를 제외한 속성들 간의 이행적 함수 종속이 없는 경우 *이행적 함수 종속 : 기본키를 제외한 다른 속성이 특정 속성을 결정지으면 안된다는 것 ​ 3차 정규화 전\r 학생id 학생이름 생년월일 주소 시 동 구 와 같이 컬럼이 있을 때 “주소“만 알면 “시”, “동”, “구\"도 알 수 있다. 3차 정규화 후\r*학생 테이블 학생id 학생이름 생년월일 주소 *주소 테이블 주소 시 동 구 위 테이블 처럼 주소속성으로 구분지어 정규화 한다. ​ 정규화를 한다고 해서 무조건 (조회)성능이 하락하는 것도 아니다. 성능에 대한 이슈는 어떻게 테이블을 구성할 것이며, 어떤 데이블 들이 있는지 등 고려해야하는 사항이 많다. 즉 함수의 종속성(Functional Dependency)에 근거한 정규화 수행이 필요하다. 함수의 종속성(Functional Dependency) - ex) 2차 정규화 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭. 이때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다. ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:2:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:0:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["SQLD"],"content":"제4 절 관계(Relationship) 관계의 개념 관계의 정의 “인스턴스 사이의 논리적인 연관성으로서 존재의 형태 or 행위로서 서로에게 연관성이 부여된 상태” 관계의 페어링 “관계는 인스턴스가 개별적으로 관계를 가지는 것(페어링)이고, 이것의 집합을 관계로 표현하는 것” “따라서 개별 인스턴스가 각각 다른 종류의 관계를 가지고 있다면, 두 엔터티 사이에 두 개 이상의 관계가 형성될 수 도 있다.” ​ 관계의 분류 ERD : 존재의 의한 관계 / 행위에 의한 관계 UML(Unified Modeling Language) : 연관 관계 / 의존 관계 ​ 관계의 표기법 관계명(Membership) : 관계의 이름을 기록 관계차수 : 엔터티간의 관계에서 참여자의 수를 표현 1:1 1:M M:M 관계선택사양 필수 관계(Mandatory) ex) 지하철은 반드시 문이 닫혀야, 출발할 수 있다. 에서 “문 닫힘” \u0026 “출발” 은 필수참여관계(Mandatory)이다. 선택 관계(Optional) ex) 지하철의 출발을 알리는 안내음성이 나온다. 에서 “안내음성\"은 나오면 좋지만 “출발\"과 필수적인 관계는 아닌 선택적인(Optional) 관계이다. ​ 관계의 정의 및 읽는 방법 관계 체크사항 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가? 두 개의 엔터티 사이에 정보의 조합이 발생하는가? 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가? 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가? 관계 읽기 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다. 대상(Target) 엔터티의 관계참여도 단수, 복수로 읽는다. 관계선택사항과 관계명을 읽는다. ​ ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:1:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["SQLD"],"content":"제5 절 식별자(Identifiers) 식별자(Identifiers) 개념 엔터티를 대표할 수 있는 속성 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다. 식별자는 엔터티내에서 인스턴스들을 구분할 수 있는 구분자다. ​ 식별자의 특징 주식별자 유일성 : 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다. 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. 불변성 : 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다. 존재성 : 주식별자로 지정되면 반드시 값이 들어와야 한다. 외부식별자 참조무결성 제약조건(Referential Integrity)에 따른 특징을 가진다. ​ 식별자의 분류 및 표기법 식별자 분류 주식별자 : 엔터티 내에서 대표성을 가지는 식별자 (대표성이 있어 참조 연결 가능) 보조식별자 : 엔터티 내에서 대표성을 가지지 않는 식별자 (대표성이 있어 참조 연결 불가능) 내부식별자 : 엔터티 내에서 스스로 생성된 식별자 외부식별자 : 타 엔터티와의 관계를 통해 받아오는 식별자 단일식별자 : 하나의 속성으로 구성된 식별자 복합식별자 : 둘 이상의 속성으로 구성된 식별자 본질식별자 : 원래 있던 식별자 (업무에 의해 만들어지는 식별자) 인조식별자 : 새롭게 만든 식별자 (인위적으로 만든 식별자) 식별자 표기법 ​ 주식별자 도출 기준 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다. 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면, 주식별자로 지정하지 않는다. (차라리 새로 생성!) 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다. ​ 식별자관계와 비식별자관계에 따른 식별자 구분 식별자관계 or 비식별자관계의 결정방법 부모엔터티 쪽의 주식별자를 자식엔터티의 속성으로 내려 보낸다. 이때 자식엔터티는 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 써도 되며 ( == 식별자 관계), 단순히 부모와 연결되는 속성으로만 이용 ( == 비식별자 관계) 할 것인지 결정한다. 이때 외부식별자는 Foreign Key 역할을 한다. 식별자 관계 → 부모엔터티로 부터 속성을 받고, 이를 자식엔터티에서 주식별자로 사용 하는 경우 - 식별자 관계 부모로 부터 받은 속성을 자식이 주식별자로 사용하면 / 부모와 자식의 관계는 1:1 A부모 엔터티로부터 받은 속성a와 B부모 엔터티로부터 받은 속성b를 포함하거나 / 스스로 가지고 있는 속성과 함께 주식별자를 구성하면 / 부모와 자식의 관계는 1:M 비식별자 관계 → 부모엔터티로 부터 속성을 받았지만, 자식엔터티에서 주식별자가 아닌 일반 속성으로 사용하는 경우 - 비식별자 관계 식별자 관계로만 설정할 경우 문제점 주식별자의 속성이 지속적으로 증가하는 경우 - 복잡성↑ 하고 오류가능성 유발 비식별자 관계로만 설정할 경우 문제점 상속의 개념이 없어, 쓸데없이 부모엔터티까지 찾아가서 데이터를 관리해야 하는 경우 발생 식별자관계 \u0026 비식별자관계 모델링 비식별자관계 선택 프로세스 → 선택적으로 식별자, 비식별자를 구성 (난이도가 높다.) 식별자와 비식별자관계 비교 식별자와 비식별자를 적용한 데이터 모델 (예시) ​ ​ ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:2:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["git"],"content":"​ Git LFS(Large File Storage) 사용법 Git은 개당 파일에 100MB의 용량 제한이 걸려 있다. (전체 용량 제한은 없다.) 다만, 프로젝트를 하다보면 대용량의 자료나 파일이 생기는 경우가 있다. 이때 용량 제한의 문제를 해소할 수 있는 방법이 LFS이다. LFS는 별도로 설치하여 사용하면 되며, 방법을 정리한다. *주소: https://git-lfs.github.com ​ git LFS을 다운을 받고 설치 합니다. ​ git LFS를 적용할 폴더로 이동해 다음 명령어를 입력합니다. $ git lfs install ​ git LFS로 관리할 파일을 지정해줍니다. // mp4 확장자 모두를 lfs로 관리 $ git lfs track \"*.mp4\" // 특정 파일만 lfs로 관리 (예시) $ git lfs track \"video/hahaha.mp4\" ​ 해당 경로의 설정을 저장할 .gitattributes 파일을 추가 합니다. $ git add .gitattributes ​ 이후로는 평소 git을 사용하는 것처럼 commit / push하면 됩니다. ​ 끝 ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/git_lfslarge-file-storage/:0:0","tags":["git","LFS"],"title":"Git_LFS","uri":"https://colinder.github.io/git_lfslarge-file-storage/"},{"categories":["git"],"content":"🙂부록 *혹시 LFS를 풀고 싶다면 LFS설정한 폴더로 가서 아래 명령어를 입력하면 됩니다. $ git lfs uninstall ​ *또 LFS없이 대용량 파일을 올리려고 하면 오류가 발생하는데, 잘 보면 LFS를 소개 해줍니다. ​ ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/git_lfslarge-file-storage/:1:0","tags":["git","LFS"],"title":"Git_LFS","uri":"https://colinder.github.io/git_lfslarge-file-storage/"},{"categories":["SQLD"],"content":"​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:0:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SQLD"],"content":"제2 절 엔터티(Entity) 엔터티의 개념 실체, 객체 / 실무적으론는 앤터티라고 부른다. 즉 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것 ​ 엔터티와 인스턴스에 대한 내용과 표기법 ​ 엔터티의 특징 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다. 유일한 식별자에 의해 식별이 가능해야 한다. 영속적으로 존재하는 인스턴스의 집합이어야 한다. (반드시 ‘두 개 이상’) 엔터티는 업무에 이용되어야 한다. 엔터티는 반드시 ‘두 개 이상’의 속성을 갖는다. 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다. ​ 엔터티의 분류 우뮤형에 따른 분류 - 유형, 개념, 사건엔터티 발생시점에 따른 분류 - 기본(키), 중심, 행위엔터 스스로 생성할 수 있는지에 따라 - 독립, 의존 엔터티 ​ 엔터티의 명명 현업 업무에서 사용하는 용어를 사용 약어를 가능하면 사용하지 않는다. 단수 명사를 사용 모든 엔티티명은 유일해야 함 엔티티 생성 의미대로 이름을 부여 ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:1:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SQLD"],"content":"제3 절 속성(Attribute) 속성의 개념 업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 즉, 속성이란 의미상 더 이상 분리되지 않으며, 엔터티를 설명하는 요소이며, 인스턴스의 구성요소이다. 엔터티, 인스턴스, 속성, 속성값 엔터티, 인스턴스, 속성, 속성값의 관계 한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다. 한 개의 엔터티는 두 개 이상의 속성을 갖는다. 한 개의 속성은 한 개의 속성값을 갖는다. 속성의 표기법 IE 표기법 Barker 표기법 ​ 속성의 특징 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다. 정규화 이론에 근간하여 정해진 주식별자에 함수 종속성을 가져야 한다. 한 개의 속성은 한 개의 속성값을 갖는다. 만약 한 개의 속성에 여러 속성값을 갖는 다중 값일 경우 별도의 엔터티로 분리하여 관리한다. ​ 속성의 분류 속성의 특성에 따른 분류 기본속성 업무로부터 추출한 모든 속성 설계속성 기본속성 외에 새롭게 만들거나 변형하여 정의한 속성 파생속성 타 속성에 의해 지속적으로 영향을 받아 값이 변하는 성질을 가지고 있는 속성 파생속성은 그 속성이 가지고 있는 계산방법에 대해 반드시 어떤 엔터티에 어떤 속성에 의해 영향을 받는지 정의가 되어야 한다. 파생속성은 꼭 필요한 경우에만 정의하여 업무로직이 속성내부로 스며들지 못하도록 주의해야 한다. 파생속성을 정의한 경우라면 그 값의 정합성을 유지할 수 있도록 해야 한다. 주로 통계관련 엔터티, 배치작업 수행 관련에 사용된다. ​ 엔터티 구성방식에 따른 분류 PK(Prime Key) == 엔터티를 식별할 수 있는 고유한 속성 FK(Foreign Key) == 다른 엔터티와의 관계로, 연결된 속성 일반 속성 == 엔터티에 포함되어 있고, PK, FK가 아닌 속성 추가로 의미를 쪼갤 수 있는지에 따라 단순형, 복합형으로 분류할 수 있다. 한 속성에 한 개의 값 → 단일값(Single Value) 한 속성에 여러 개의 값 → 다중값(Multi Value) ​ 도메인(Domain) 각 속성이 가질 수 있는 값의 범위 (일종의 테이터 타입, 크기, 제약사항등을 지정하는 것) ex) ‘‘학점'‘이라는 ‘‘도메인'‘은 0 \u003c= X \u003c= 4.5  ​ 속성의 명명(Naming) 가급적 현업에서 사용하는 이름을 부여한다. 서술식 속성명은 사용하지 않는다. 약어사용은 자제한다. 전체 데이터모델에서 유일성을 확보하는 것이 좋다. ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:2:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11445_무한 사전 for T in range(int(input())): P = input().rstrip() Q = input().rstrip() if P + \"a\" != Q: result = \"Y\" else: result = \"N\" print(f'#{T+1} {result}') # 왜 D3 인가. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11387_몬스터 사냥 for T in range(int(input())): D, L, N = map(int, input().split()) result = 0 for i in range(N): result += D * (1 + L*i/100) print(f'#{T+1} {int(result)}') ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11285_다트 게임 table = [20, 40, 60, 80, 100, 120, 140, 160, 180, 200] value = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] for T in range(int(input())): result = 0 for i in range(int(input())): x, y = map(int, input().split()) dis = (x**2 + y**2)**0.5 for i, v in zip(table, value): if dis \u003c= i: result += v break print(f'#{T+1} {result}') # (오답 : 10000개의 테스트케이스 중 4344개가 맞았습니다.) # 제한시간 초과가 발생하였습니다. ## python으론 안되나...... ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11315_오목 판정 def check(x, y): global result # 가로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+i][y+j] if total == 5: result = \"YES\" return # 세로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+j][y+i] if total == 5: result = \"YES\" return # 좌상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+i] if total == 5: result = \"YES\" return # 우상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+4-i] if total == 5: result = \"YES\" return for T in range(int(input())): N = int(input()) arr = [] # 돌이 있으면 1, 없으면 0 for _ in range(N): C = input() NC = [] for i in C: if i == \".\": NC.append(0) else: NC.append(1) arr.append(NC) result = \"NO\" for x in range(N-4): for y in range(N-4): check(x, y) print(f'#{T+1} {result}') # 스마트해 보이진 않는다. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SQLD"],"content":"​ SQLD를 준비하면서 공부한 내용을 정리. ​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-21","objectID":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/:0:0","tags":["SQLD"],"title":"01_SQLD_제1 절 데이터 모델링의 이해","uri":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/"},{"categories":["SQLD"],"content":"제1 절 데이터 모델링의 이해 모델링의 이해 모델링의 정의 복잡한 “현실세계\"를 단순화(추상화)시켜 표현 사물 또는 사건에 관한 양상(Aspect)이나 관점(Perspective)을 명확하게 하는 것 특징 3가지 추상화 - 현실세계를 일정한 형식에 맞추어 표현하는 것 단순화 - 복잡한 현실세계를 약속된 규약에 의해 쉽게 이해할 수 있게 표현하는 것 명확화 - 누구나 이해할 수 있도록 명확하게 표기하는 것 모델링의 3가지 관점 데이터 관점 - 업무 \u0026 데이터, 데이터 \u0026 데이터간의 관계가 무엇인지 표기(What, Data) 프로세스 관점 - 업무가 실제하고 있는 일 또는 무엇을 해야하는지 표기(How, Process) (프로세스\u0026데이터) 상관 관점 - 업무 처리 방법에 따라 데이터가 받는 영향을 표기(Interaction) ​ 데이터 모델링의 기본개념 이해 데이터 모델링의 정의 업무상 필요한 데이터를 일정한 표기법으로 표현함으로써 필요한 정보를 용이하게 분석할 수 있고, 정리된 데이터로 개발 및 데이터관리를 용이하게 하기 위함 ∴ 데이터 모델링 자체로서 업무를 설명하고 분석하는 부분에도 매우 중요한 의미가 있음 ​ 데이터 모델링의 중요성 및 유의점 중요성 (중요한 이유) 파급효과 향상, 간결한 표현, 데이터품질 향상 유의점 중복 - 데이터 베이스가 여러 장소에 같은 정보를 저장하지 않도록 유의. 비유연성 - 데이터의 정의를 데이터 사용 프로세스와 분리. 비일관성 ( ≒ 모순) - 연관되어 있는 데이터는 같이 관리될 수 있도록 유의. ​ 데이터 모델링의 3단계 개념적 데이터 모델 - 추상화 수준이 높고, 업무 중심적이며, 포괄적인 수준의 모델링 논리적 데이터 모델 - 모델링하고자하는 업무에 대해 Key, 속성, 관계 등을 구현. (높은 재사용) 물리적 데이터 모델 - 실제 DB에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려해 진행 ​ 프로젝트 생명주기에서 데이터 모델링 이론 : 계획단계 → (분석) 개념적모델링 → (설계) 논리적 모델링 → (구현)물리적 모델링 실제 : 계획단계 → (분석) 개념 + 논리적 모델링 → (설계 \u0026 구현) 물리적 모델링 ​ 데이터 모델링에서 데이터 독립성의 이해 데이터 독립의 필요성 - 유지보수비용 절감, 데이터복잡도 하락, 중복데이터 감소 등. DB의 3단계 구조 데이터 독립성 요소 외부스키마 - 사용자 개개인이 보는(접근하는) DB를 정의 개념스키마 - 모든 사용자 관점을 통합한 조직 전체 DB를 정의. 내부스키마 - 물리적 장치에 데이터가 실제로 저장되는 구조를 정의. * 스키마: 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조 두 영역의 데이터독립성 논리적 독립성 - 개념스키마가 변경되어도 외부스키마에는 영향을 미치지 않도록. 물리적 독립성 - 내부스키마가 변경되어도 외부/개념스키마는 영향을 받지 않도록. ∴ 외부 / 개념 / 내부 스키마의 독립성을 강조하지만, 이들이 분리되어 관리된다는 의미는 아니다. 이를 사상(Mapping)이라고 말하며, “상호 독립적인 개념을 연결시켜주는 다리” 정도로 이해하면 된다. ​ 데이터 모델링의 중요한 세 가지 개념 업무가 관여하는 어떤 것(Thing) 어떤 것이 가지는 성격(Attributes) 업무가 관여하는 어떤 건 간의 관계(Relationships) ​ 데이터 모델 표기법과 ERD의 이해 데이터 모델 표기법 1976년 피터첸이 Entity-Releationship model(E-R Model)이라는 표기법을 만듦 ‘‘엔터티\"라는 것을 사각형으로 표현, 관계를 마름모, 속성을 타원형으로 표현 ERD(Entity Relationship Diagram) 모델링 작업 순서 엔터티를 그린다. → 엔터티를 적절하게 배치한다. → 엔터티간의 관계를 설정한다. → 관계명을 기술한다. → 관계의 참여도를 기술한다. → 관계의 필수여부를 기술한다. ​ 좋은 데이터 모델의 요소 완전성 - 모든 데이터가 데이터 모델에 정의 되어 있어야 한다. 중복배제(정규화) - 하나의 DB 안에 동일한 사실은 반드시 한 번만 기록되어 있어야 한다. 명확한 업무규칙 기술 및 공유 데이터 재사용성 고려 - 데이터가 어플리케이션에 대해 독립적으로 설계되어야만 재사용성↑ 의사소통 - 데이터를 분석하는 과정에서 나오는 규칙들에 대한 이해가 표현되어야 좋다. 통합성 - 중복배제(정규화)를 이루기 위해 데이터 모델들은 통합적으로 관리되어야 한다. ​ *계속 ","date":"2021-03-21","objectID":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/:1:0","tags":["SQLD"],"title":"01_SQLD_제1 절 데이터 모델링의 이해","uri":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/"},{"categories":["Python"],"content":"​ Python Library 😀 ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"Idea # 모두 '거짓'이 들어있는 리스트는 '거짓'으로 볼 수 있지 않을까? # 라고 생각해봤다. a = [False, False, False] if a == False: print(\"거짓\") else: print(\"오류\") # \u003e\u003e\u003e 오류 # 안된다. 생각을 말아라..ㅎㅎ ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"raise 예외(‘에러메시지’) # python에서는 의도적으로 오류를 일으킬 수 있는데 # 이를 해주는 것이 raise 메서드. try: x = 2 if x % 3 != 0: raise Exception('3의 배수가 아닙니다.') print(\"입력된 값\", x) except Exception as e: print('예외가 발생했습니다.', e) \u003e\u003e\u003e 예외가 발생했습니다. 3의 배수가 아닙니다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"filter() VS find() ## filter(function, iterable) # 배열의 `모든 요소`에 접근하여 조건에 맞는 `값`을 찾는다. # ex) def func(x): if x \u003e 0: return x else: return None list(filter(func, range(-5,10))) \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # ex) [ i for i in range(-5,10) if i \u003e 0 ] \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # find(sub[, start[, end]]) # 배열을 순회하면서 찾으려 하는 값의 `index`를 반환 해준다. # ex) a = 'hello' a.find('o') # find 함수 \u003e\u003e\u003e 4 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:3","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"index() VS find() ## 공통점 # 두 함수 모두 찾으려 하는 값의 `index`를 반환 해준다. # ex) \u003e\u003e\u003e 'oxoxoxoxox'.find('x') # find 함수 1 \u003e\u003e\u003e 'oxoxoxoxox'.index('x') # index 함수 1 # 문자 'o'가 첫번째 위치한 자리를 출력 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o') # find 함수 4 \u003e\u003e\u003e a.index('o') # index 함수 4 # 또 (value, start, end) 형태로 문자를 찾는 시작점과 종료점을 지정할 수 있다. # 문자열중 2번째 위치부터 처음 'x'가 위치한 자리 \u003e\u003e\u003e 'oxoxoxoxox'.index('x', 2) 3 # a변수에서 1번째~3번째 사이에 문자 'o'가 위치한 자리 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o', 1, 3) -1 # find함수는 찾는 값이 없을 때 -1을 출력한다. 이게 차이점. ## 차이점 # 찾으려는 값이 없는 경우 find()는 '-1'을 반환 / index()는 'ValueError' 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:4","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"deque # deque는 기본적으로 리스트를 변형(ex. pop() ...)하며 코딩할 때 # 속도가 빠르기 때문에 사용한다. # 주로 popleft()를 사용하지만, 유용한 기능이 더 있다. ## 1. rotate from collections import deque q = deque([1,2,3,4,5,6]) q.rotate(3) print(q) # deque([4, 5, 6, 1, 2, 3]) # 주로 리스트의 끝이 붙어 있는 원순열 문제를 해결하는데 편리하다. # 다만 속도가 어떤지는 잘 모르겠다. ## 2. deque는 슬라이싱이 되지 않는다. # 굳이 해야 한다면 아래를 참고 deque_slice = collections.deque(itertools.islice(my_deque, 10, 20)) # deque는 # index()는 '사용가능'하고 find()는 '사용불가'하다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:5","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"q[len(q)-1] VS q[-1] 속도 비교 import time start = time.time() # 시작 시간 저장 ... ... print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. # 왜..? ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:6","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"isalpha(), isdigit() # 알파벳이냐?, 숫자형이냐? 를 참, 거짓 형태로 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:7","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sys.setrecursionlimit(최대 재귀 깊이 설정) # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:8","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sorted() sorted는 여러 그룹의 값이 주어진 경우 ## 순차적으로 증감을 비교해 준다. # ex) A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] A = sorted(A) print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ## 만약 주어진 두번째 인자들을 기준으로 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: L[1]) print(B) # [(1, -1), (2, 2), (1, 2), (3, 3), (0, 4)] ## 두번째 인자 우선 기준 후 첫번째 인자 기준 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: (L[1], L[0])) print(B) # [(1, -1), (1, 2), (2, 2), (3, 3), (0, 4)] ## set자료형을 sorted 하면 자동으로 list type으로 변환된다. a = {\"a\",\"b\",\"C\"} print(\"a의 타입: \",type(a)) # a의 타입: \u003cclass 'set'\u003e b = sorted(a) print(\"b의 타입: \", type(b)) # b의 타입: \u003cclass 'list'\u003e ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:9","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"from collections import Counter 주어지는 컨테이너(ex 리스트 자료형, string)에 동일한 값의 갯수를 파악 from collections import Counter MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() print(MoResult) #[(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() 함수 # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:10","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import sys 빠른 속도로 입력받기 위한 라이브러리 imput VS sys.stdin.readline() # python의 대표적인 입력 함수 imput() # 단, 백준에는 더 빠른 방법이 초기에 설명되어있다. import sys sys.stdin.readline() # 단 위와 같이 입력 받은 경우, 마지막에 개행 문자까지 입력되어 뒤에 # 추가 함수(rstrip())를 붙여 사용하는 것이 보통이다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:11","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"정규표현식 일대일 매칭되는 문자 정규표현식 안에서, 바로 다음 절에서 설명하는 메타문자를 제외한 모든 문자 하나는 일반 문자열 하나와 매칭된다. 예를 들어, a는 a와 매칭되고, 가는 ‘가’와 매칭되는 식이다. 당연히 a가 ‘b’ 또는 ‘가’와 매칭되지는 않는다. 어떤 프로그래밍 언어의 정규표현식이든 메타문자(특수한 기능을 하는 문자)라는 것이 존재한다. 파이썬 re 모듈의 메타문자는 총 12개로 다음과 같은 것들이 있다. $()*+.?[^{| 이들 메타문자는 각각의 문자 하나에 매칭되지 않는다. 예를 들어 일반 문자인 a는 문자 ‘a’에 매칭하지만, 여는 소괄호 (는 문자 ‘(‘와 매칭하지 않는다. 그럼 찾고자 하는 문자열에 소괄호가 있으면 어떻게 할까? 위의 문자들의 앞에 백슬래시 \\를 붙여 주면 일반 문자처럼 한 글자에 매칭된다. 예를 들어 \\(는 문자 ‘(‘와 매칭된다. ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:12","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"find(찾을문자, 찾기시작할위치) - 찾는 값의 인덱스를 반환 s = '가나다라 마바사아 자차마타 파하' print(s.find('마')) # s에서 첫'마'의 인덱스를 반환 print(s.find('마', 3)) # s[3:]부터 첫'마'의 인덱스를 반환 (전체 범위 기준) print(s.find('가', 2)) # s[2:]부터 첫'가'의 인덱스를 반환 (없으면 -1 반환) 5 5 -1 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:13","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"startsWith(찾을문자, 찾기시작위치, 찾기종료위치) str = \"this is string\"; print(str.startswith('this')) # str맨앞이 'this'로시작하는지 검사 print(str.startswith('is', 2, 4)) # str[2:4]에서 맨앞이 'is'인지 검사 print(str.startswith('this', 3, 4)) # str[3:4]에서 맨앞이 'this'인지 검사 True True False ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:14","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import itertools (효율적인 반복을 위한 함수) ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"permutations(자료, 만들순열길이) n개의 원소를 사용해서 순서를 정하여 r개의 배열로 나타내는 것 =\u003e 순열 공식 : nPr = n!/(n-r)! import itertools a = [1,2,3] permute = itertools.permutations(a,2) print(list(permute)) a = \"abc\" permute = itertools.permutations(a,2) print(list(permute)) [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"combinations(조합) n개의 원소를 사용해서 순서의 관계없이 r개의 배열로 나타내는 것 =\u003e 조합 공식 : nCr=nPr/r! import itertools a = [1,2,3] permute = itertools.combinations(a, 2) print(list(permute)) a = \"abc\" permute = itertools.combinations(a, 2) print(list(permute)) [(1, 2), (1, 3), (2, 3)] [('a', 'b'), ('a', 'c'), ('b', 'c')] ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:0","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"2630_색종이 만들기 import sys def DFS(x, y, N): global W, B color = arr[x][y] for cx in range(x, x+N): for cy in range(y, y+N): if arr[cx][cy] != color: DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) return # 이걸 안해주면 쓸모 없는 DFS에 더 들어가게 된다. if color == 0: W += 1 return else: B += 1 return N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] W, B = 0, 0 DFS(0, 0, N) print(W) print(B) # 분할한 구역에도 동일한 규칙을 적용할 수 있는 # 알고리즘을 만드는 것이 기본 같다. ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:1","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"1992_쿼드트리 import sys def DFS(x, y, N): global result check = arr[x][y] for i in range(x, x+N): for j in range(y, y+N): if check != arr[i][j]: result += \"(\" DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) result += \")\" return if check == 0: result += \"0\" else: result += \"1\" N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] result = \"\" DFS(0, 0, N) print(result) ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:2","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"5052_전화번호 목록 import sys for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) Numbers = [] for _ in range(N): Numbers.append(sys.stdin.readline().rstrip()) Numbers.sort() result = \"YES\" for i in range(len(Numbers)-1): if Numbers[i+1].find(Numbers[i], 0, len(Numbers[i])) != -1: result = 'NO' break print(result) # 흠.. 다른 사람들은 트리로 풀었나..? # 이게 왜 트리에 있지... ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"9372_상근이의 여행 import sys from collections import deque def BFS(i): q = deque([i]) visited = [True] + [False] * N flight = -1 while q: x = q.popleft() if visited[x] == False: visited[x] = True flight += 1 for j in range(len(tree[x])): if visited[tree[x][j]] == False: q.append(tree[x][j]) return flight for T in range(int(sys.stdin.readline().rstrip())): N, M = map(int, sys.stdin.readline().split()) tree = [[] for _ in range((N+1))] for _ in range(M): a, b = map(int, sys.stdin.readline().split()) tree[a].append(b) tree[b].append(a) print(BFS(1)) ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1991_트리 순회 class Node: def __init__(self, data, L, R): self.data = data self.left = L self.right = R def preorder(node): # 전위 순회 print(node.data, end=\"\") if node.left != \".\": preorder(tree[node.left]) if node.right != \".\": preorder(tree[node.right]) def inorder(node): # 중위 순회 if node.left != \".\": inorder(tree[node.left]) print(node.data, end=\"\") if node.right != \".\": inorder(tree[node.right]) def postorder(node): # 후위 순회 if node.left != \".\": postorder(tree[node.left]) if node.right != \".\": postorder(tree[node.right]) print(node.data, end=\"\") N = int(input()) tree = {} for _ in range(N) : data, L, R = input().split() tree[data] = Node(data, L, R) preorder(tree['A']) print() inorder(tree['A']) print() postorder(tree['A']) # 트리 구조에 대한 이해가 부족하다. # 트리문제를 많이 풀어봐야 겠다. # 해보니 복잡?하지는 않은데 익숙하지 않은 느낌이다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"11725_트리의 부모 찾기 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N-1): S, E = map(int, sys.stdin.readline().split()) tree[S].append(E) tree[E].append(S) q = deque([1]) visited = [True, True] + [False for _ in range(N)] result = [[] for _ in range(N+1)] while len(q): parent = q.popleft() for child in tree[parent]: if not visited[child]: visited[child] = True result[child].append(parent) q.append(child) for j in range(2, len(result)): print(result[j][0]) # heap을 사용하는 건가 고민했으나, 아니었고, # 1이 root node인 것을 알고 있으니. # 각각의 node에 연결되어있는 모든 node들을 기록했다가. # 1부터 BFS로 한 단계씩 내려가면, 코딩상 pop한 것이 # 부모 node가 된다. # 채점 속도가 느려서 런타임 오류 걸릴까봐 조마조마했다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1967_트리의 지름 import sys from collections import deque def BFS(value, step): q = deque() q.append(value) visited = [-1 for _ in range(N+1)] visited[value] = 0 while q: x = q.popleft() for c, w in tree[x]: if visited[c] == -1: visited[c] = visited[x] + w q.append(c) if step == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for i in range(N-1): P, C, V = map(int, input().split()) tree[P].append([C, V]) tree[C].append([P, V]) print(BFS(BFS(1, 1), 2)) # DFS로 지저분하게 구현했으나 말 그대로 # 너무 지저분해서 검색의 도움을 받음. # root인 1에서 가장 멀리 있는 노드를 고르고 # 그 노드에서 가장 멀리 있는 노드를 고르는 # 알고리즘으로 구현. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:3","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1167_트리의 지름 import sys from collections import deque sys.setrecursionlimit(10**9) def BFS(i, mode): q = deque() q.append(i) visited = [-1 for _ in range(N+1)] visited[i] = 0 while q: x = q.popleft() for C, W in tree[x]: if visited[C] == -1: visited[C] = visited[x] + W q.append(C) if mode == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N): info = list(map(int, sys.stdin.readline().split())) for i in range(1, len(info)-1, 2): tree[info[0]].append([info[i], info[i+1]]) print(BFS(BFS(i, 1), 2)) ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:4","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_3143_가장 빠른 문자열 타이핑 for T in range(int(input())): A, B = input().split() result = len(A) - (A.count(B)*(len(B)-1)) print(f'#{T+1} {result}') # 왜 D4 인가. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_10966_물놀이를 가자 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] for T in range(int(input())): N, M = map(int, input().split()) arr = [input() for _ in range(N)] visited = [[-1 for _ in range(M)] for _ in range(N)] q = deque([]) for i in range(N): for j in range(M): if arr[i][j] == \"W\": q.append([i,j]) visited[i][j] = 0 total = 0 while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0\u003c= cx \u003cN and 0\u003c= cy \u003cM and visited[cx][cy] == -1: visited[cx][cy] = visited[x][y] + 1 q.append([cx, cy]) total += visited[cx][cy] print(f'#{T+1} {total}') # 오랜만에 다중 시작점 BFS ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11592_크루즈 컨트롤 for T in range(int(input())): D, N = map(int, input().split()) # D: 총 거리 S = [] for _ in range(N): k, s = map(int, input().split()) # k : 위치 / s : 속도 S.append((D-k) / s) a = max(S) print(f'#{T+1} {D/a}') # D2 난이도... ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11545_틱택톰 def check(): # 가로 판단 for i in range(4): if '.' not in arr[i] and 'O' not in arr[i]: return 'X won' if '.' not in arr[i] and 'X' not in arr[i]: return 'O won' # 세로 판단을 위한 리스트 생성 col = [arr[j][i] for j in range(4)] if '.' not in col and 'O' not in col: return 'X won' if '.' not in col and 'X' not in col: return 'O won' # 우상단 대각선 판단 rUp = [arr[i][i] for i in range(4)] if '.' not in rUp and 'O' not in rUp: return 'X won' elif '.' not in rUp and 'X' not in rUp: return 'O won' # 좌상단 대각선 판단 lUP = [arr[i][3-i] for i in range(4)] if '.' not in lUP and 'O' not in lUP: return 'X won' elif '.' not in lUP and 'X' not in lUP: return 'O won' # 그밖의 경우. for i in range(4): for j in range(4): if arr[i][j] == '.': return 'Game has not completed' return 'Draw' N = int(input()) for T in range(N): arr = [list(input()) for _ in range(4)] if T \u003c N-1: _ = input() print(f'#{T+1} {check()}') # T의 숫자를 고려하는 것에 애먹었으나, # 문제에 T는 최대 1개로 설정. # 즉, T의 숫자를 별도로 카운트 하지 않아도 됨. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:0","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15649_N과 M (1) N, M = map(int, input().split()) def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() visited[i] = False num_list = [i + 1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:1","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15650_N과 M (2) import sys def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() for j in range(i+1, N): visited[j] = False N, M = map(int, sys.stdin.readline().split()) num_list = [i+1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:2","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1258_행렬찾기 def check(x, y): dx, dy = 0, 0 while x + dx \u003c N and arr[x+dx][y]: dx += 1 while y + dy \u003c N and arr[x][y+dy]: dy += 1 result.append([dx*dy, dx, dy]) for i in range(x, x+dx): for j in range(y, y+dy): arr[i][j] = 0 for T in range(int(input())): N = int(input()) arr = [list(map(int, input().split())) for _ in range(N)] result = [] for i in range(N): for j in range(N): if arr[i][j] != 0: check(i, j) aws = sorted(result, key=lambda x: [x[0], x[1]]) print(f'#{T+1} {len(aws)}', *[str(i[1]) + ' ' + str(i[2]) for i in aws]) # DFS로 구현해보려 했는데. # 내가 원하는 위치값을 반환하고 바로 종료시키는 것이 # 불가능해서. 최소한의 값인 가로 세로 이동값만을 뽑아 # 정리하였다. # 마지막에 정렬이 더 복잡했다.. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1249_보급로 from collections import deque dx = [0,1,0,-1] dy = [1,0,-1,0] for T in range(int(input())): N = int(input()) arr = [list(map(int, input())) for _ in range(N)] visited = [[float('inf') for _ in range(N)] for _ in range(N)] visited[0][0] = arr[0][0] q = deque([[0, 0]]) while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0 \u003c= cx \u003c N and 0 \u003c= cy \u003c N: Sum = visited[x][y] + arr[cx][cy] if visited[cx][cy] \u003e Sum: visited[cx][cy] = Sum q.append([cx, cy]) print(f'#{T+1} {visited[N-1][N-1]}') # DFS로 구현해보려 했지만, 특정 위치에 왔을 때 종료를 # 구현하는데 어려움이 있어, BFS로 바꾸어 구현. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1238_Contact from collections import deque for T in range(10): N, S = map(int, input().split()) node = list(map(int, input().split())) arr = [[] for _ in range(N)] for i in range(0, N, 2): arr[node[i]].append(node[i+1]) visited = [0] * (N+1) visited[S] = 1 q = deque([S]) while q: v = q.popleft() step = visited[v] for i in arr[v]: if visited[i] == 0: q.append(i) visited[i] = step + 1 for j in range(N+1): if visited[j] == step: result = j print(f'#{T+1} {result}') ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_4261_빠른 휴대전화 키패드 anycall = {'2':\"abc\", '3': \"def\", '4':\"ghi\", '5':\"jkl\", '6':\"mno\", '7':\"pqrs\", '8':\"tuv\", '9':\"wxyz\"} for T in range(int(input())): S, N = map(int, input().split()) words = list(input().split()) result = 0 for x in range(len(words)): count = 0 for i, j in enumerate(str(S)): a = words[x][i] b = anycall[j] if words[x][i] in anycall[j]: count += 1 else: break if count == len(str(S)): result += 1 else: count = 0 print(f'#{T+1} {result}') # 비교적 쉬운 문제. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"1021_회전하는 큐 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = deque([i for i in range(1, N+1)]) poplist = deque(list(map(int, sys.stdin.readline().split()))) count = 0 while poplist: try: if arr[0] == poplist[0]: arr.popleft() poplist.popleft() L = len(arr) a = abs(arr.index(arr[0]) - arr.index(poplist[0])) b = L - a if a \u003c b: arr.rotate(-a) count += a elif a \u003e= b: arr.rotate(b) count += b except IndexError: break print(count) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"5430_AC import sys from collections import deque for T in range(int(sys.stdin.readline().rstrip())): P = sys.stdin.readline().rstrip() N = int(sys.stdin.readline().rstrip()) ## 다양하게 input 받는 거 고민하기 좋다. arr = deque(list(sys.stdin.readline().rstrip()[1:-1].split(\",\"))) if N == 0 or len(arr) == 0: arr = deque([]) reverse = False error = False for i in P: if i == \"R\": reverse = not reverse elif i == \"D\": if len(arr) == 0: error = True break if reverse: arr.pop() else: arr.popleft() if error: print(\"error\") else: if reverse: arr.reverse() print(\"[\", end=\"\") print(\",\".join(arr), end=\"\") print(\"]\") ## reverse() 여러번 돌리면 시간초과 뜬다. # flag = True # for i in P: # if i == \"R\": # arr.reverse() # else: # if len(arr) != 0: # arr.popleft() # else: # print(\"error\") # flag = False # break # if flag: # if len(arr) != 0: # print(\"[\", end=\"\") # print(\",\".join(arr), end=\"\") # print(\"]\") # else: # print('error') ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"10866_덱 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque() for i in range(N): command = sys.stdin.readline().split() if command[0] == \"push_front\": q.appendleft(command[1]) elif command[0] == \"push_back\": q.append(command[1]) elif command[0] == \"pop_front\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"pop_back\": if q: print(q.pop()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"18258_큐 2 import sys from collections import deque # import time N = int(sys.stdin.readline().rstrip()) # start = time.time() # 시작 시간 저장 q = deque() for _ in range(N): command = sys.stdin.readline().split() if command[0] == \"push\": q.append(command[1]) elif command[0] == \"pop\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) # print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"2164_카드2 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque([i+1 for i in range(N)]) while len(q) != 1: q.popleft() q.append(q.popleft()) print(q[0]) ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"11866_요세푸스 문제 0 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) q = deque([i+1 for i in range(N)]) result = [] while q: q.rotate(-K+1) result.append(q.popleft()) print(\"\u003c\", end=\"\") for i in range(N): if i != N-1: print(result[i], end=\", \") else: print(result[i], end=\"\") print(\"\u003e\") ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"1966_프린터 큐 import sys from collections import deque for T in range(int(input())): N, M = map(int, sys.stdin.readline().split()) q = deque(map(int, sys.stdin.readline().split())) idx = deque([0 for i in range(N)]) idx[M] = 1 count = 0 while True: if q[0] == max(q): count += 1 if idx[0] == 1: print(count) break else: q.popleft() idx.popleft() else: q.append(q.popleft()) idx.append(idx.popleft()) # 큐를 사용하는 알고리즘을 고민하는데 # 아주 좋은 문제!! ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:4","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:0","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"4949_균형잡힌 세상 import sys while True: text = sys.stdin.readline().rstrip() if text == \".\": break stack =[] result = \"yes\" for i in text: if i.isalpha() or i == \" \": continue elif i == \"(\" or i == \"[\": stack.append(i) elif i == \")\": if not stack or stack[-1] != \"(\": result = \"no\" break else: stack.pop() elif i == \"]\": if not stack or stack[-1] != \"[\": result = \"no\" break else: stack.pop() if not stack: print(result) else: print('no') ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:1","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"10828_스택 import sys stack = [] commands = [] for i in range(int(sys.stdin.readline().rstrip())): commands.append(sys.stdin.readline().rstrip().split()) for command in commands: if command[0] == \"push\": stack.append(int(command[1])) elif command[0] == \"pop\": if stack: print(stack.pop()) else: print(-1) elif command[0] == \"size\": print(len(stack)) elif command[0] == \"empty\": if stack: print(0) else: print(1) elif command[0] == \"top\": if stack: print(stack[len(stack)-1]) else: print(-1) ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:2","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"1874_스택 수열 import sys N = int(sys.stdin.readline().rstrip()) Numbers = [i for i in range(1, N+1)] Sequence = [] for i in range(N): v = int(sys.stdin.readline().rstrip()) Sequence.append(v) result = \"\" stack = [] ans = [] for i in range(N): if stack and stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" elif not Numbers: while stack: ans.append(stack.pop()) break elif Numbers[0] \u003c= Sequence[i]: try: while Numbers[0] \u003c= Sequence[i]: stack.append(Numbers.pop(0)) result += \"+\" ans.append(stack.pop()) result += \"-\" except IndexError: if stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" continue if ans == Sequence: for i in result: print(i) else: print(\"NO\") # 뭔가 좀 지저분해보이지만.. # 입력받은 수열의 요소 마다 검증을 하고 싶었고 # 각 요소마다 진행사항을 등록하고 싶었다. # 예를 들어) 수열의 첫 번재 '4'가 나오기 위해선. # 1,2,3,4가 스택에 들어갔다가 마지막 4가 출력되면 된다. # 이런 과정을 코딩하고 싶었다. # 인터넷에 있는 까리한 코딩과 비교해봤는데. # 다행이 내 코드가 속도면에서 우위를 점했다. # 메모리는 졌음. ㅎ ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:3","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"17298_오큰수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) NGE = [-1] * N stack = [0] i = 1 while stack and i \u003c N: while stack and arr[stack[-1]] \u003c arr[i]: NGE[stack[-1]]= arr[i] stack.pop() stack.append(i) i += 1 print(*NGE) # stack에 arr의 인덱스를 저장(비교 기준 설정) # i로 비교할 인덱스를 지정해 비교 # stack에 0 저장 # i = 1 즉, arr[1] = 5를 stack에 저장되어있는 # 인덱스값(arr[0])과 비교 NGE라면 arr[i]을 NGE에 저장 # 이게 왜 빠른건지 잘 모르겠다. ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:4","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:0","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1037_약수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) Max = max(arr) Min = min(arr) print(Max*Min) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:1","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1934_최소공배수 import sys def GCD(a, b): while b != 0: m = a % b a = b b = m return a for T in range(int(sys.stdin.readline().rstrip())): A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:2","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"2609_최대공약수와 최소공배수 import sys def GCD(a, b): #최대공약수(유클리드 호제법) while b != 0: m = a % b a = b b = m return a A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(gcd) print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:3","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"5086_배수와 약수 import sys while True: a, b = map(int, sys.stdin.readline().split()) if a == 0 and b == 0: break if b % a == 0: print(\"factor\") elif a % b == 0: print(\"multiple\") elif a % b != 0 and b % a != 0: print(\"neither\") ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:4","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:0","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1931_회의실 배정 import sys N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] schedule = sorted(arr, key=lambda x: (x[1], x[0])) count, end = 0, 0 for s, f in schedule: if s \u003e= end: count += 1 end = f print(count) # 왠지 정렬을 잘하면 계산이 쉬울 것 같아서. # 시작시간과 종료시간을 정렬해 계산했는데 # 1. 종료시간, 2. 시작시간 순위로 정렬해야 했다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:1","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"11399_ATM import sys N = int(sys.stdin.readline().rstrip()) TT = list(map(int, sys.stdin.readline().split())) TT = sorted(TT) result = 0 for i, v in zip(range(N, -1, -1), TT): result += i*v print(result) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:2","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1541_잃어버린 괄호 import sys text = list(sys.stdin.readline().rstrip().split('-')) Nums = [] for N in text: n = sum(list(map(int, N.split(\"+\")))) Nums.append(n) result = 0 for i in range(len(Nums)): if i != 0: result -= Nums[i] else: result += Nums[i] print(result) # 55-50+40 경우 결국 - 뒤에 +는 모두 묶어주면 된다. # 예를 들어 55-50+40-30+49 경우 # 55-(50+40)-(30+49) 가 정답이 된다. # 즉 55 / 50+40 / 30+49 로 나누고 # 첫 인자를 제외한 나머지의 합을 빼주면 된다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:3","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"13305_주유소 import sys N = int(sys.stdin.readline().rstrip()) distance = list(map(int, sys.stdin.readline().split())) #d 2 3 1 price = list(map(int, sys.stdin.readline().split())) #p 5 2 4 1 total = 0 Min = sys.maxsize for i in range(N-1): if i == 0: total += price[0]*distance[0] Min = min(Min, price[0]) else: Min = min(Min, price[i]) total += Min*distance[i] print(total) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:4","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1226_미로1 dx = [0,1, 0, -1] dy = [1,0, -1, 0 ] def IsSafe(x, y): if 0\u003c= x \u003c 16 and 0 \u003c= y \u003c 16: return True def DFS(x, y): global result visited[x][y] = 1 if arr[x][y] == 3: result = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] != 1: DFS(nx, ny) def Find_Start(): for i in range(16): for j in range(16): if arr[i][j] == 2: return i, j for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(16)] visited = [[0 for _ in range(16)] for _ in range(16)] x, y = Find_Start() result = 0 DFS(x, y) print(f'#{T+1} {result}') # 재귀를 사용할 시 return은 불편한 점이 많다. # 하여 특정 조건에서의 값이 필요한 경우. # 변수를 설정해서 그 값을 바꾸는 편이 간편하다. # 다만 런타임에 조심해야 한다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1227_미로2 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] def IsSafe(x, y): if 0\u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(100)] visited = [[0 for _ in range(100)] for _ in range(100)] result = 0 q = deque([[1, 1]]) while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if arr[nx][ny] == 3: result = 1 break if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] == 0: q.append([nx, ny]) if result: break print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1231_중위순회 def DFS(i): global result if i \u003c= N: DFS(i*2) result += words[i] DFS(i*2+1) for T in range(10): N = int(input()) words = [0] * (N+1) for i in range(N): command = input().split() words[int(command[0])] = command[1] result = \"\" DFS(1) print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_5643_키 순서 def DFSF(x, i): for j in arrF[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSF(x, j) def DFSB(x, i): for j in arrB[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSB(x, j) for T in range(int(input())): N = int(input()) M = int(input()) arrF = [[] for _ in range(N+1)] arrB = [[] for _ in range(N+1)] arr = [[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(M): a, b = map(int, input().split()) arrF[a].append(b) arrB[b].append(a) for i in range(1, N+1): x = i DFSF(x, i) DFSB(x, i) count = 0 for i in arr: if sum(i) == N-1: count += 1 print(f'#{T+1} {count}') # 화살표 방향대로의 F # 화살표 반대방향의 B # 앞으로 진행시(F방향) 알 수 있는 위치를 arr에 저장하고 # 반대로 진행시(B방향) 알 수 있는 위치를 arr에 저장했을 때 # 다른 노드의 위치를 모두 확인할 수 있는 노드만이 본인의 위치를 # 알 수 있게 된다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1218_괄호 짝짓기 def Pair_bracket(): for i in range(L): if q[i] in check: ni = i - 1 while True: if q[ni] == 0: ni -= 1 else: break a = q[ni] b = check[q[i]] if a == b: q[i] = 0 q[ni] = 0 else: return 0 return 1 check = {\")\" :\"(\", \"]\":\"[\", \"}\":\"{\", \"\u003e\":\"\u003c\"} for T in range(10): L = int(input()) q = list(input()) print(f'#{T+1} {Pair_bracket()}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1219_길찾기 from collections import deque def BFS(): visited[0] = 1 while q: a = q.popleft() if a == 99: return 1 if visited[a] == 0: for i in range(len(arr[a])): q.append(arr[a][i]) visited[a] = 1 return 0 for _ in range(10): T, N = map(int, input().split()) arr = [[] for _ in range(100)] route = list(map(int, input().split())) visited = [0 for _ in range(100)] for i in range(0, N*2, 2): arr[route[i]].append(route[i+1]) q = deque() for i in range(len(arr[0])): q.append(arr[0][i]) print(f'#{T} {BFS()}') # 빈 2차원 리스트 만드는 법 # [[] * 100] 은 안됨 # [[] for _ in range(N)] 으로 생성 ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1222_계산기1 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. total = 0 for i in text: if i == \"+\": continue total += int(i) print(f'#{T+1} {total}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1223_계산기2 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. aws = [] idx = [] for i in range(L): if i in idx: continue if text[i] in \"0123456789\": aws.append(int(text[i])) elif text[i] == \"*\": aws[-1] = aws[-1]*int(text[i+1]) idx.append(i+1) print(f'#{T+1} {sum(aws)}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:0","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["BEAKJOON"],"content":"1918_후위 표기식 import sys from collections import deque text = sys.stdin.readline().rstrip() # 후위 표기법 알고리즘 operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = deque() result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() print(result) ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:1","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6959_이상한 나라의 덧셈게임 for T in range(int(input())): N = input() result = [\"A\", \"B\"] turn = 1 while len(N) \u003e 1: N = str(int(N[0]) + int(N[1])) + N[2:] turn += 1 print(f'#{T+1} {result[turn%2]}') # 단순 산수 ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_4613_러시아 국기 같은 깃발 for T in range(int(input())): N, M = map(int, input().split()) a = [input() for _ in range(N)] result = N * M for i in range(1, N - 1): for j in range(1, N - i): count = 0 for x in range(N): if 0 \u003c= x \u003c i: count += M - a[x].count('W') elif i \u003c= x \u003c i + j: count += M - a[x].count('B') else: count += M - a[x].count('R') if result \u003e count: result = count print(f'#{T+1} {result}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6109_추억의 2048게임 from collections import deque def turn(): tmp = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): tmp[i][j] = arr[N-1-j][i] return tmp def push(): for y in range(N): q = deque([]) for x in range(N): if arr[x][y] != 0: q.append(arr[x][y]) arr[x][y] = 0 i = 0 while q: if len(q) \u003e= 2: a, b = q.popleft(), q.popleft() if a == b: arr[i][y] = a+b else: arr[i][y] = a q.appendleft(b) i += 1 else: arr[i][y] = q.popleft() direction = {'up': (0, 0), 'left': (1, 3), 'down': (2, 2), 'right': (3, 1)} for T in range(int(input())): N, S = input().split() N = int(N) arr = [list(map(int, input().split())) for _ in range(N)] Front, Back = direction[S] for i in range(Front): arr = turn() push() for i in range(Back): arr = turn() print(f'#{T+1}') for i in arr: print(*i) # 하... 너무 오래 걸렸다. # 방향 전환이 싫어서 U, D, R, L를 # 각각 구현해봤으나.. 실패하고. # 수정해야 할 것도 너무 많아지고.. # 방향 전환 구현하니까.. 이리 저리 돌리는 숫자 # 생각하는데 또 오래 걸리고...ㅎ ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_1211_Ladder2 dx = [0, 0, 1] dy = [1, -1, 0] def IsSafe(x, y): if 0 \u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True def DFS(x, y): global distance if x == 99: return distance visited[x][y] = 1 for i in range(3): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and arr[nx][ny] == 1 and visited[nx][ny] == 0: distance += 1 DFS(nx, ny) return distance # 런타임 오류 방지로 재귀를 빠져나올 때 무조건 리턴. for _ in range(10): T = int(input()) arr = [list(map(int, input().split())) for _ in range(100)] Min = 10000 Midx = 0 for y in range(100): if arr[0][y] == 1: visited = [[0]* 100 for _ in range(100)] distance = 0 v = DFS(0, y) if v \u003c= Min: Min = v Midx = y print(f'#{T} {Midx}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2156_포도주 시식 N = int(input()) wine = [0 for _ in range(N)] total = [0 for _ in range(N)] for i in range(N): wine[i] = int(input()) if N == 1: total[0] = wine[0] else: total[0] = wine[0] total[1] = wine[0] + wine[1] for i in range(2, N): total[i] = max(total[i-1], total[i-2] + wine[i], total[i-3] + wine[i] + wine[i-1]) print(total[N-1]) # N == 1인 경우를 생각하지 않았을 땐 런타임 오류에 걸렸었다. # 그리고 그걸 생각하는데 오래 걸렸다. ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2565_전깃줄 n = int(input()) line = [list(map(int, input().split())) for _ in range(n)] line.sort(key=lambda x: x[0]) # 앞 숫자 기준, 오름차순 정리 arr = [0] * 501 for s, e in line: arr[e] = max(arr[:e]) + 1 print(n - max(arr)) # dp를 활용해 e에 겹쳐지지 않은 줄의 수를 기록 # s는 오름차순으로 정렬해 검증함으로 겹쳐지는 것을 # 신경 쓰지 않아도 ok ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"10844_쉬운 계단 수 # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"9251_LCS # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"1912_연속합 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) result = [arr[0]] for i in range(N-1): result.append(max(result[i]+arr[i+1], arr[i+1])) print(max(result)) # dp 연습하기 좋은 문제 ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"9184_신나는 함수 실행 def w(a,b,c): if a \u003c= 0 or b \u003c= 0 or c \u003c= 0: return 1 if a \u003e 20 or b \u003e 20 or c \u003e 20: return w(20, 20, 20) if dp[a][b][c]: return dp[a][b][c] if a \u003c b and b \u003c c: dp[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) return dp[a][b][c] dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return dp[a][b][c] dp = [[[0]*21 for _ in range(21)] for _ in range(21)] while True: a, b, c = map(int, input().split()) if a == -1 and b == -1 and c == -1: break print(f'w({a}, {b}, {c}) = {w(a, b, c)}') # 갑자기 난이도가 높아진듯.. # 3차원 dp까지는 어찌저찌 고안했으나 # if dp[a][b][c]: # return dp[a][b][c] # 를 어디에 넣어야 할지 고민하는데 # 시간을 소요. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11053_가장 긴 증가하는 부분 수열 n = int(input()) a = list(map(int, input().split())) dp = [0 for i in range(n)] for i in range(n): for j in range(i): if a[i] \u003e a[j] and dp[i] \u003c dp[j]: dp[i] = dp[j] dp[i] += 1 print(max(dp)) ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11054_가장 긴 바이토닉 부분 수열 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) idp = [0 for _ in range(N)] ddp = [0 for _ in range(N)] result = [0 for _ in range(N)] for i in range(N): for j in range(i): if arr[i] \u003e arr[j] and idp[i] \u003c idp[j]: idp[i] = idp[j] idp[i] += 1 for i in range(N-1, -1, -1): for j in range(N-1, i, -1): if arr[i] \u003e arr[j] and ddp[i] \u003c ddp[j]: ddp[i] = ddp[j] ddp[i] += 1 result[i] = ddp[i] + idp[i] -1 print(max(result)) # 11053을 풀어본 뒤에 도전하면 할만하다. # range()를 거꾸로 돌리는데 살짝 애를 먹음. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5678_[Professional] 팰린드롬 for T in range(int(input())): S = \" \" + input() L = len(S) result = 1 for i in range(2, L): for j in range(L-i): if S[j+1:j+i+1] == S[j+i:j:-1]: result = i print(f'#{T+1} {result}') # 슬라이싱을 잘 고민 하면 쉽게 해결 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5672_[Professional] 올해의 조련사 for T in range(int(input())): q = [] n = \"\" for N in range(int(input())): q.append(input()) S = 0 L = N while S != L: if q[S] \u003c q[L]: n += q[S] S += 1 elif q[S] \u003e q[L]: n += q[L] L -= 1 else: W = int((L-S)//2) for i in range(W): flag = True c = q[S+i+1] d = q[L-(i+1)] if c == d: continue elif c \u003c d: n += q[S] S += 1 flag = False break elif c \u003e d: n += q[L] L -= 1 flag = False break if flag: n += q[S] S += 1 n += q[L] print(f'#{T+1} {n}') # 조건은 다 쉬웠으나, 검사하는 횟수?에 착각을해 # 생각보다 시간이 많이 걸린 문제 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7465_창용 마을 무리의 개수 def DFS(x): visited[x] = 1 for i in range(1, N+1): if arr[x][i] == 1 and visited[i] == 0: DFS(i) for T in range(int(input())): N, M = map(int, input().split()) arr = [[0 for _ in range(N+1)] for _ in range(N+1)] visited = [0 for _ in range(N+1)] for i in range(M): x, y = map(int, input().split()) arr[x][y] = 1 arr[y][x] = 1 count = 0 for i in range(1, N+1): if visited[i] == 0: DFS(i) count += 1 print(f'#{T+1} {count}') # 양방향입니다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7701_염라대왕의 이름 정렬 for T in range(int(input())): N = int(input()) S = set() for i in range(N): s = input() S.add(s) A = sorted(S, key=lambda x: (len(x), x)) print(f'#{T+1}') for j in A: print(j) # set 자료형도 sorted를 진행하면 # 자동으로 list type으로 변한다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10761_신뢰 from collections import deque for T in range(int(input())): command = deque(input().split()) N = command.popleft() B = deque() O = deque() order = deque() while command: i = command.popleft() if i == \"B\": B.append(int(command.popleft())) order.append(\"B\") else: O.append(int(command.popleft())) order.append(\"O\") count = 0 b, o = 1, 1 while True: if not order: break count += 1 BP = \"안눌림\" if B: if B[0] \u003e b: b += 1 elif B[0] == b and order[0] == \"B\": B.popleft() order.popleft() BP = \"눌림\" elif B[0] \u003c b: b -= 1 if O: if O[0] \u003e o: o += 1 elif O[0] == o and order[0] == \"O\" and BP == \"안눌림\": O.popleft() order.popleft() elif O[0] \u003c o: o -= 1 print(f'#{T+1} {count}') # 주어진 순서대로 버튼을 눌러야 한다!!! # 첫번째 테스트의 경우 O에 1이 있으나, B2가 눌리기를 기다려야 한다. # order 리스트가 필요한 이유 ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10804_문자열의 거울상 for T in range(int(input())): S = input() L = len(S) result = \"\" for i in range(L-1, -1, -1): if S[i] == \"b\": result += \"d\" elif S[i] == \"d\": result += \"b\" elif S[i] == \"q\": result += \"p\" else: result += \"q\" print(f'#{T+1} {result}') ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10912_외로운 문자 from collections import Counter for T in range(int(input())): S = Counter(input()).most_common() R = \"\" for i in S: if i[1] % 2 == 1: R += i[0] result = sorted(R) if len(result) == 0: print(f'#{T+1} Good') else: result2 = \"\" for i in result: result2 += i print(f\"#{T+1} {result2}\") # Counter와 .most_common 은 유용하다. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10965_제곱수 만들기 P = [2] for i in range(3,3162,2): for q in P: if i % q == 0: break else: P.append(i) ans = [] for T in range(int(input())): N = int(input()) result, n = 1, N for v in P: count = 0 if n == 1 or v \u003e N: break while n % v == 0: n //= v count += 1 if count % 2 != 0: result *= v if n \u003e 1: result *= n ans.append(f'#{T+1} {result}') for i in ans: print(i) # 에라토스테네스 체를 이용해 소수를 구했고 # root(10000001**0.5) 보다 큰 소수의 경우 # 소인수 분해를 하고 나서도 n != 1 수 있다. # 하여 소인수분해를 마치고도 n \u003e 1면 # result에 곱해주었다. # 속도와 n이 root보다 큰 경우가 있다는 것을 깨닫는데 # 오랜시간이 걸렸던 문제. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:0","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"2178_미로탐색 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 1 and visited[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N, M = map(int, sys.stdin.readline().split()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0]*(M) for _ in range(N)] q = deque([[0, 0]]) BFS() print(arr[N-1][M-1]) # pop을 사용하는데 리스트형태의 자료인 경우 # x, y = [1, 2]의 모습으로도 추출이 가능 ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:1","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"7576_토마토 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 def result(): global Max for x in range(N): for y in range(M): if arr[x][y] == 0: print(-1) return if arr[x][y] \u003e Max: Max = arr[x][y] print(Max-1) return dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] M, N = map(int, sys.stdin.readline().split()) # M: 6, N: 4 arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] q = deque() for x in range(N): for y in range(M): if arr[x][y] == 1: q.append([x, y]) BFS() Max = 0 result() # 어떻게 하면 출발점이 2개 이상일 때 # 두 지점에서 동시에 출발해 토마토가 익는 것을 # 판단할 수 있을까에 대한 고민이 1시간.. # 초기 코딩 # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() # 한 시간 후... # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:2","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"1697_숨바꼭질 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) arr = [0] * 30 q = deque([N]) def BFS(): while q: v = q.popleft() if v == K: return print(arr[v]) for i in [v-1, v+1, v*2]: if 0 \u003c= i \u003c 30 and arr[i] == 0: arr[i] = arr[v] + 1 q.append(i) BFS() # 긴 방문 리스트를 만들어 놓고 # 수빈이가 기준점에서 부터 갈 수 있는 장소의 걸음수를 등록한다. # ex) # 위지 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 걸음1: 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 # 걸음2: 0 0 0 2 1 2 0 0 0 2 0 0 0 0 0 0 0 5(기준)에서 갈 수 있는 위치 # 걸음3: 0 0 3 2 1 2 0 3 0 2 0 0 0 0 0 0 0 4(기준)에서 갈 수 있는 위치 # 걸음4: 0 0 3 2 1 2 3 3 0 2 0 3 0 0 0 0 0 6(기준)에서 갈 수 있는 위치 # 걸음5: 0 0 3 2 1 2 3 3 3 2 3 0 0 0 0 0 0 ..3 10(기준)에서 갈 수 있는 위치 # 요런 식으로 진행하면 된다. ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:3","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:0","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1260_DFS와 BFS import sys from collections import deque def DFS(V): print(V, end=' ') DFSv[V] = 1 for i in range(1, N+1): if DFSv[i] == 0 and tree[V][i] == 1: DFS(i) return def BFS(V): q = deque([V]) BFSv[V] = 1 while q: p = q.popleft() print(p, end=\" \") for i in range(1, N+1): if BFSv[i] == 0 and tree[p][i] == 1: q.append(i) BFSv[i] = 1 return N,M,V = map(int, sys.stdin.readline().split()) tree = [[0]*(N+1) for _ in range(N+1)] DFSv = [0 for _ in range(N+1)] BFSv = [0 for _ in range(N+1)] for _ in range(M): S, E = map(int, sys.stdin.readline().split()) tree[S][E] = 1 tree[E][S] = 1 DFS(V) print() BFS(V) # 기초가 제일 중요하다. # 혹시 DFS, BFS가 막힐 땐 이 문제를 다시 풀어보자 ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:1","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2606_바이러스 import sys C = int(sys.stdin.readline().rstrip()) No = int(sys.stdin.readline().rstrip()) arr = [[0 for _ in range(C+1)] for _ in range(C+1)] vistied = [0 for _ in range(C+1)] count = 1 for _ in range(No): S, E = map(int, sys.stdin.readline().split()) arr[S][E] = 1 arr[E][S] = 1 def DFS(V): global count vistied[V] = 1 for i in range(1, C+1): if vistied[i] == 0 and arr[V][i] == 1: vistied[i] = 1 count += 1 DFS(i) DFS(count) print(count-1) ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:2","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2667_단지번호붙이기 import sys def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c N: return True def DFS(x, y, c): global count visited[x][y] = 1 if arr[x][y] == 1: count += 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy, c) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0 for _ in range(N)] for _ in range(N)] result = [] count = 0 # AP 단지안에 건물 숫자 for x in range(N): for y in range(N): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y, count) result.append(count) count = 0 result.sort() print(len(result)) for i in result: print(i) # DFS의 나만의 규칙 # 1. 새로운 노드에 접근하자마자 방문을 표시한다. # 2. isSafe를 만들어 범위를 확인한다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:3","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1012_유기농 배추 import sys # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def DFS(x, y): visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] result = [] for T in range(int(sys.stdin.readline().rstrip())): M, N, K = map(int, sys.stdin.readline().split()) # M 가로, N 세로, K 배추갯수 arr = [[0 for _ in range(M)] for _ in range(N)] visited = [[0]*(M) for _ in range(N)] for i in range(K): y, x = map(int, sys.stdin.readline().split()) arr[x][y] = 1 count = 0 for x in range(N): for y in range(M): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y) count += 1 result.append(count) for i in result: print(i) # 초기 풀이는 런타임 에러가 발생했다. # 하여 결과값을 모았다가 출력하면 속도 증가가 가능하기에 # result = []에 답을 모았다가 출력해보았지만, # 런타임 에러 발생.. # 검색해보니 # sys.setrecursionlimit(50000) 이런 것이 있다는 것을 봤고 # 추가해주니 통과 되었다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:4","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:0","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10989_수 정렬하기3 import sys # 시간 초과 # from collections import deque # # result = deque() # for T in range(int(sys.stdin.readline().rstrip())): # n = int(sys.stdin.readline().rstrip()) # if len(result) != 0: # for i in range(len(result)): # if result[i] \u003e n: # result.insert(i, n) # break # else: # result.append(n) # for i in result: # print(i) # 속도엔 DP지. arr = [0] * 10001 for T in range(int(sys.stdin.readline().rstrip())): n = int(sys.stdin.readline().rstrip()) arr[n] += 1 for i in range(10001): if arr[i] != 0: for j in range(arr[i]): print(i) ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:1","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"11650_좌표 정렬하기 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for _ in range(T): x, y = map(int, sys.stdin.readline().split()) L.append((x, y)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][1]}') # sorted는 여러 그룹의 값이 주어진 경우 # 순차적으로 증감을 비교해 준다. # ex) # A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] # A = sorted(A) # print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:2","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"2108_통계학 import sys from collections import deque, Counter result = deque() T = int(sys.stdin.readline().rstrip()) for _ in range(T): result.append(int(sys.stdin.readline().rstrip())) result = sorted(result) def Am(): return round(sum(result)/T) def Me(): return result[int(T//2)] def Mo(): MoResult = Counter(result).most_common() # MoResult = [(-2, 1), (1, 1), (2, 1), (3, 1), (8, 1)] if len(MoResult) \u003e 1: if MoResult[0][1] == MoResult[1][1]: return MoResult[1][0] else: return MoResult[0][0] else: return MoResult[0][0] def Ra(): return result[-1] - result[0] print(Am()) print(Me()) print(Mo()) print(Ra()) # Counter 함수와 더 익숙해지면 좋을 것 같다. # ex) # from collections import Counter # MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() # print(MoResult) # [(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:3","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10814_나이순 정렬 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for i in range(T): age, name = sys.stdin.readline().split() L.append((int(age), i, name)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][2]}') ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:4","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:0","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"2798_블랙잭 import sys N, M = map(int, sys.stdin.readline().split()) cards = list(map(int, sys.stdin.readline().split())) result = 0 for i in range(N): for j in range(i+1, N): for x in range(j+1, N): if cards[i] + cards[j] + cards[x] \u003c= M: result = max(result, cards[i] + cards[j] + cards[x]) print(result) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:1","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"7568_덩치 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) # 내가 생각한 무식한 방법... W = deque() H = deque() for _ in range(N): x, y = sys.stdin.readline().split() W.append(x) H.append(y) for i in range(N): w = W.popleft() h = H.popleft() count = 0 for j in range(N-1): if W[j] \u003e w and H[j] \u003e h: count += 1 print(count+1, end=\" \") W.append(w) H.append(h) # 인터넷에 있던 멋진 방법 # li = deque() # for _ in range(N): # x, y = sys.stdin.readline().split() # li.append((x, y)) # for i in li: # count = 0 # for j in li: # if i[0] \u003c j [0] and i[1] \u003c j[1]: # count += 1 # print(count+1, end=\" \") # 하지만 내가 짠 코드가 더 빠르다. ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:2","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1018_체스판 다시 칠하기 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = [ list(sys.stdin.readline().rstrip()) for _ in range(N) ] result = deque() for i in range(N-7): for j in range(M-7): caseW = 0 # 시작(기준)점이 W 일 때 바뀌어야 하는 수 caseB = 0 # 시작(기준)점이 B 일 때 바뀌어야 하는 수 for x in range(i, i+8): for y in range(j, j+8): if (x+y) % 2 == 0: if arr[x][y] == \"B\": caseW += 1 if arr[x][y] == \"W\": caseB += 1 else: if arr[x][y] == \"W\": caseW += 1 if arr[x][y] == \"B\": caseB += 1 result.append(caseW) result.append(caseB) print(min(result)) # 체스판에 시작점이 W로 시작했을 때 바뀌어야 하는 수 # VS 시작점이 B로 시작했을 때 바뀌어야 하는 수를 # 비교해야 한다! ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:3","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1436_영화감독 숌 import sys N = int(sys.stdin.readline().rstrip()) X = 666 while N: if '666' in str(X): N -= 1 X += 1 print(X-1) # 666, 1666, 2666, 3666, 4666, 5666, 6661, 6662, 6663, 6664, 6665, 6667, 6668, 6669, 7666, 8666, 9666, 10666 ..... # 666이 첫 번째 수 인데 그다음 666이 들어간 수를 # 단순히 +1 하면서 찾는 것이다. # 당연히 런타임 오류일 줄 알았으나. 아니었다.(왜 아니지...) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:4","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:0","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10872_팩토리얼 import sys N = int(sys.stdin.readline().rstrip()) def fac(n): if n \u003e 1: return n * fac(n-1) else: return 1 print(fac(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:1","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10870_피보나치 수 5 import sys def fivo(n): if n \u003e= 2: return fivo(n-1) + fivo(n-2) else: return n N = int(sys.stdin.readline().rstrip()) print(fivo(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:2","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"2447_별 찍기 - 10 import sys n = int(sys.stdin.readline().rstrip()) def star(i, j): while(i != 0): if i % 3 == 1 and j % 3 == 1: sys.stdout.write(' ') return i //= 3 j //= 3 sys.stdout.write('*') for i in range(n): for j in range(n): star(i, j) sys.stdout.write('\\n') # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 재귀는 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:3","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"11729_하노이 탑 이동 순서 import sys N = int(sys.stdin.readline().rstrip()) def hanoi(N, s, m, e): if N == 1: print(s, e) else: hanoi(N-1, s, e, m) print(s, e) hanoi(N-1, m, s, e) Sum = 1 for i in range(N - 1): Sum = Sum * 2 + 1 print(Sum) hanoi(N, 1,2,3) # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:4","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:0","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"4948_베르트랑 공준 import sys while True: N = int(sys.stdin.readline().rstrip()) if N == 0: break arr = [0,0] + [1] * ((2*N)-1) rootN = int((2*N)**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, 2*N+1, i): arr[j] = 0 print(sum(arr[N+1:(2*N)+1])) # 입출력에 제한이 있다가 0을 입력 받을 때 까지 # 출력을 해야 하는 조건을 달지 않는 것을 주의! ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:1","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"9020_골드바흐의 추측 import sys # 무식한 방법....(당연히 런타임 에러) # def checkSum(): # dis = 10000 # rx = 0 # ry = 0 # for x in range(N+1): # if arr[x] == 1: # for y in range(x, N+1): # if arr[y] == 1: # if x + y == N: # dif = y - x # if dis \u003e dif: # dis = dif # rx = x # ry = y # return rx, ry for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) # 소수 찾기 arr = [0, 0] + [1]*(N-1) rootN = int(N**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, N+1, i): arr[j] = 0 # 확인해야 하는 값을 줄이기 위해, # a는 중앙에서 부터 1 방향으로 내려가고 # b는 중앙에서 N 까지 올라가며 검증 # 16을 예로 (0, 16) (1, 15) (2, 14) ... # 정대칭된 수를 더하면 16을 만들 수 있다. # 16 만들기로 (3, 13)을 제시할 수도 있지만, # 16의 중심값을 기준으로 비교하는 것이 두 수의 차이를 # 더 줄일 수 있는 방법이었다. a = N//2 b = a while a \u003e 0: if arr[a] and arr[b]: print(a, b) break else: a -= 1 b += 1 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:2","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"3053_택시 기하학 import sys, math n = int(sys.stdin.readline().rstrip()) print(n**2*math.pi) # 유클리드 기하학 print(n**2*2) # 택시 기하학 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:3","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"1002_터렛 for T in range(int(input())): x1, y1, r1, x2, y2, r2 = map(int, input().split()) distance = (((x1 - x2) ** 2) + ((y1 - y2) ** 2)) ** 0.5 if x1 == x2 and y1 == y2: if r1 == r2: print(-1) else: print(0) continue if r1 \u003e distance + r2 or r2 \u003e distance + r1 or distance \u003e r1 + r2: print(0) elif r1 == distance + r2 or r2 == distance + r1 or r1 + r2 == distance: print(1) else: print(2) ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:4","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:0","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"10250_ACM호텔 import sys for T in range(int(sys.stdin.readline().rstrip())): H, W, N = map(int, sys.stdin.readline().split()) quo = str((N // H) + 1) rem = str(N % H) if N % H == 0: quo = str(N//H) rem = str(H) print(rem+quo.zfill(2)) # zfill? # a = \"2\" # b = \"12\" # A = a.zfill(2) # B = b.zfill(2) # print(A) // 02 # print(B) // 12 ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:1","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2775_부녀회장이 될테야 import sys for T in range(int(sys.stdin.readline().rstrip())): floor = int(sys.stdin.readline().rstrip()) ho = int(sys.stdin.readline().rstrip()) floor0 = [_ for _ in range(1,ho+1)] for i in range(floor): for j in range(1, ho): floor0[j] += floor0[j-1] print(floor0[-1]) # 놀랍게도 print(floor0[j])로 제출하면 # 런타임 에러.... 변수를 사용하는 것 보다 # 인덱스로(슬라이싱?)을 사용해 접근하는 것이 더 빠른가보다. ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:2","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2869_달팽이는 올라가고 싶다 import sys A, B, V = map(int, sys.stdin.readline().split()) # 의식의 흐름에 따른 코딩 # day = 1 # posi = 0 # while True: # posi += A # if posi \u003e= V: # break # else: # posi -= B # day += 1 # print(day) # 의식을 차리고 난 후 코딩 print((V - B - 1) // (A - B) + 1) ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:3","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"1011_Fly me to the Alpha Centauri import sys for T in range(int(sys.stdin.readline().rstrip())): x, y = map(int, sys.stdin.readline().split()) distance = y - x if distance \u003c= 3: print(distance) else: sr = int(distance**0.5) if distance == sr**2: print(2*sr - 1) elif sr**2 \u003c distance \u003c= sr**2 + sr: print(2*sr) else: print(2*sr+1) # 일단 손으로 노가다를 해야 # 규칙이 보인다... ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:4","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:0","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"10809_알파벳찾기 import sys word = sys.stdin.readline().rstrip() alphabet = list(range(97,123)) for x in alphabet : print(word.find(chr(x)), end=\" \") # find함수는 조건에 맞는 값의 index를 출력하고 # 찾지 못하는 경우 -1을 출력한다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:1","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2941_크로아티아 알파벳 import sys cro = [\"c=\", \"c-\", \"dz=\", \"d-\", \"lj\", \"nj\", \"s=\", \"z=\"] s = sys.stdin.readline().rstrip() for i in cro: s = s.replace(i, \"*\") print(len(s)) ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:2","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2908_상수 import sys A, B = sys.stdin.readline().split() NA = int(A[::-1]) NB = int(B[::-1]) if NA \u003e NB : print(NA) else: print(NB) # 문자열 슬라이싱을 잘 활용하면 아주아주 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:3","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"1316_그룹 단어 체커 import sys N = int(sys.stdin.readline().rstrip()) for i in range(N): sent = sys.stdin.readline().rstrip() for j in range(1, len(sent)): if sent.find(sent[j-1]) \u003e sent.find(sent[j]): N -= 1 break print(N) # find함수도 잘 알아두면 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:4","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["Javascript"],"content":"​ JavaScript Hoisting web 개발을 하면서 여러 레퍼런스들을 확인하고 공부하게 되는데, 문득 똑같아 보이나 왜 이건 되고? 왜 이건 안되지?하는 부분이 있었습니다. 그 차이는 Hoisting에 대한 내용이었는데요. 알아두면 쓸모있기에 정리해봅시다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:0:0","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅(Hoisting)이란? 호이스팅을 한 줄로 설명하자면, 선언문을 유효 범위의 최상단으로 끌어올리는 행위라고 할 수 있습니다. 최상단이라는 표현이 중요한데요. 인터프리터 언어인 자바스크립트가 한 줄씩 순서대로 코딩을 실행하는 것이 아니라, 임의로 특정 내용을 최상단으로 끌어 올려서 우선 실행하는 것을 호이스팅이라고 합니다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:0","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅의 특징 자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑는다. 함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다. 유효 범위: 함수 블록 {} 안에서 유효 실제 메모리에는 변화가 없다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:1","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅의 대상 var 변수 선언과 함수선언식(Function Declarations)에서만 호이스팅이 일어납니다. 첨언으로 [ var 변수 / 함수 ]의 선언만 호이스팅이 동작하고, 할당(초기화)은 호이스팅이 동작하지 않습니다. ​ 🙋‍♂️ var 변수 vs let 변수 비교 // 예시 0 // 아래 코드를 전체 복사 후 붙여넣으면 결과 확인 가능 console.log(a) // undefined console.log(b) // VM85:2 Uncaught ReferenceError: b is not defined var a = \"Im a\"; // var 변수 선언 \u0026 초기화 let b = \"Im b\"; // let 변수 선언 \u0026 초기화 // var 변수 a는 호이스팅되어 오류가 아닌 undefined를 출력하고 // let 변수 b는 호이스팅되지 않아 error를 출력합니다. 만약 변수를 선언한 뒤 나중에 초기화시켜 사용한다면, 그 값은 undefined로 지정됩니다. 아래 예제로 동작 순서를 알아 봅시다. // 예시 1 console.log(\"x:\", x) // x: undefined var x = 1; // x 선언 \u0026 초기화 console.log(x + \"/\" + y); // '1/undefined' var y = 2; // y 선언 \u0026 초기화 // 아래 코드는 '예시 1'이 동작하는 순서를 정리한 것입니다. var x; // x 선언 =\u003e x: undefined var y; // y 선언 =\u003e y: undefined console.log(\"x:\", x) // x: undefined 출력 var x = 1; // x 초기화 =\u003e x: 1 console.log(x + \"/\" + y); // '1/undefined' 출력 var y = 2; // y 초기화 =\u003e y: 1 * [ let / const ] 변수 선언과 함수표현식(Function Expressions)에서는 호이스팅이 발생하지 않습니다. ​ ​ 🙋‍♂️ 함수선언식(Function Declarations) vs 함수표현식(Function Expressions) // 함수 선언식(function declaration) 예시 function 함수명() { 함수 로직 부분 } 함수명(); // 함수 사용 // 함수 표현식(function expression) 예시 var 함수명 = function () { return 'A function expression'; } 함수명(); // 함수 사용 함수선언식은 일반적인 프로그래밍 언어에서 함수 선언과 비슷한 모습니다. 다만, 함수표현식은 유연한 자바스크립트 언어의 특징을 활용한 선언 방식이라고 할 수 있습니다. ​ ​ ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:2","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"​ JavaScript Scope란? Scope [ skoʊp ]1 (무엇을 하거나 이룰 수 있는) 기회[여지/능력] (=potential)2 (주제조직활동 등이 다루는) 범위3 샅샅이[자세히] 살피다. 스코프는 “유효 범위\"로써 번수에 매개변수가 어디까지 유효한지를 나타냅니다. 자바스크립트에선 스코프는 2가지 타입이 있습니다. 바로 Global(전역)과 Local(지역)인데요. 함수 안에서 선언된 변수(Local 변수)는 함수 블록 안에서만 접근이 가능합니다.전역 변수는 어디서든 접근이 가능합니다. // global 변수 선언 var a = 10; console.log(\"global a: \", a) // 10 // local 변수 선언 function print() { var b = 20; if (true) { var c = 30; } console.log(\"local b: \",b) // 20 console.log(\"local c: \",c) // 30 } print() console.log(\"local b: \",b) // ReferenceError: b is not defined // ✨ Point // b는 print함수 안에서 선언된 local 변수 임으로 // print함수가 동작하는 안에서는 존재하지만, // print함수 밖에서는 존재하지 않습니다. ​ ","date":"2020-12-10","objectID":"https://colinder.github.io/js_scope/:0:0","tags":["Javascript","Scope"],"title":"JavaScript Scope","uri":"https://colinder.github.io/js_scope/"},{"categories":["Javascript"],"content":"스코프는 렉시컬(Lexical)과 다이나믹(Dynamic)으로 분류. 렉시컬(Lexical) 스코프는 코드를 작성하는 시점에 스코프가 결정되어진다고 해서 정적 스코프라고도 부릅니다. Javascript는 대표적인 렉시컬 스코프입니다. var a = \"Global\" function print1() { console.log(a); } function print2() { var a = \"Local\"; print1(); } print1() // Global print2() // Global // print2에서 a를 \"Local\"로 재할당 했지만, // print1()이 시작되면서 a는 print2()를 벗어나게 되고 // a는 \"Global\"로 돌아가게된다. ​ ​ ​ ","date":"2020-12-10","objectID":"https://colinder.github.io/js_scope/:1:0","tags":["Javascript","Scope"],"title":"JavaScript Scope","uri":"https://colinder.github.io/js_scope/"},{"categories":["Javascript"],"content":"​ JavaScript Operators Javascript의 연산자를 알아 봅시다. 종류가 많이 있어 많이 사용하는 것들 중심으로 먼저 알아보겠습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:0","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"1. 할당 연산자 // 할당 연산자 let numder = 0 numder += 10 console.log(numder) // 10 numder -= 8 console.log(numder) // 2 numder *= 10 console.log(numder) // 20 numder ++ // 1을 더한다. console.log(numder) // 21 numder -- // 1을 뺀다. console.log(numder) // 20 // 종류 더 많이 존재합니다! ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:1","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"2. 비교 연산자 // 비교 연산자 3 \u003e 2 //true 3 \u003c 2 //false \"A\" \u003c \"B\" //true 'z' \u003c 'a' //false 'a'.codePointAt(0) // 97(등록된 절대값) // 동등 연산자(==) 이는 절대로 쓰지 않는다. // 메모리에 같은 객체를 가리키거나 // 같은 값을 갖도록 type 변환할 수 있다면 서로 같다고 판단. const a = 1 const b = \"1\" a == b //true console.log(8*null) // 0 console.log('5'-1) // 4 console.log('5'+1) // 51 console.log(\"five\" * 2) // NaN // 하여 일치 연산자(===)를 사용한다. type도 같아야 동일하다고 판단. const a = 1 const b = \"1\" a === b //false ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:2","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"3. 논리 연산자 // 논리연산자 // And 연산자: \u0026\u0026 true \u0026\u0026 false // false true \u0026\u0026 true // true 1 \u0026\u0026 0 // 0 0 \u0026\u0026 1 // 0 4 \u0026\u0026 7 // 7 // Or 연산자: || false || ture // true false || false // false 1 || 0 // 1 0 || 1 // 1 4 || 7 // 4 // Not 연산자 ! !true // false ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:3","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"4. 삼항(조건) 연산자 // 삼항 연산자(Ternary Operator) true ? 1 : 2 // 1 if문과 비슷. true 면 1, false 면 2 false ? 1 : 2 // 2 const result = math.PI \u003e 4 ? 'Yep' : 'Nope' console.log(result) // Nope let age = 21 let message = age \u003c 7 ? '애기입니다.' : age \u003c 20 ? '청소년입니다. ' : age \u003c 100 ? '어른입니다. ': '사람입니다.' console.log(message) // 어른입니다. ​ 더 많은 연산자들이 존재합니다. 더 알고 싶다면 MDN공식문서를 찾아 봅시다! ​ ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:4","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"​ JavaScript Type은? 제 생각에 개발 언어를 공부하면서 가장 먼저 알아야 알 것은 그리고 가장 중요한 것은 형식입니다. 때마침 Javascript를 공부하고 있는데, 가장 먼저 Type에 대해 정리해보겠습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:0:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"그 전에 먼저 변수를 선언하는 방법을 알아봅시다. // 변수를 선언 하는 방법 // function scope var a = 10 // 일반적인 변수 선언 방법 // block scope {} 안에서만 존재하는 변수 let b = 20 // 재할당 가능 [최근에는 사용률이 낮아지고 있다고 합니다.] const c = 30 // 재할당 불가능 [\"재할당 불가능\"이라는 설명은 !== 값이 바뀌지 않는다.] ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:1:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"Javascript는 크게 두 가지 타입으로 구분합니다. 원시타입 VS 참조타입원시 타입은 숫자(Number), 불린(Boolean), null, undefined, 문자열(String), 심볼 총 6가지가 존재하고참조 타입은 객체(Object), 배열(Array), 함수(function)가 있습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"1. 원시 타입(Primitive Data Type) 원시 타입의 데이터는 변수에 할당이 될 때 메모리 상에 고정된 크기로 저장이 되고 해당 변수가 원시 데이터 값을 보관합니다. 원시 타입 자료형은 모두 변수 선언, 초기화, 할당 시 값이 저장된 메모리 영역에 직접적으로 접근합니다. 즉, 변수에 새로운 값이 할당이 될 경우, 변수에 할당된 메모리 블럭에 저장된 값이 바로 변경됩니다. 숫자형(Number) // Number const a = 13 const b = -5 const c = 3.14 // float const d = 2.00e8 // 2.99 * 10**8 const e = Infinity const f = -Infinity const g = NaN // Not a Number 하지만 타입은 넘버... // 변수의 타입을 알고 싶을 때 console.log(typeof(g)) typeof(g) // 개발자 도구 창에서는 typeof(g) 만 입력해도 보임. 불린형(참, 거짓)(Boolean) // Boolean (소문자로 작성) true false // false 값을 초기값으로 변수 선언 var bNoParam = new Boolean(); var bZero = new Boolean(0); var bNull = new Boolean(null); var bEmptyString = new Boolean(''); var bfalse = new Boolean(false); // true 값을 초기값으로 변수 선언 var btrue = new Boolean(true); var btrueString = new Boolean('true'); var bfalseString = new Boolean('false'); var bSuLin = new Boolean('Su Lin'); var bArrayProto = new Boolean([]); var bObjProto = new Boolean({}); 문자형(String) // String const sentence1 = 'Ask and go to the blue' const sentence2 = 'Ask and go to the red' const firstName = 'Tony' const lastName = 'Stark' const fullname = firstName + lastName console.log(fullname) // expected output: TonyStark // 줄바꿈 const word = '안녕 \\n하세요' // \\ =\u003e 달러표시 console.log(word) // ✨String = Temlates Literal✨ // `을 활용해 여러 줄에 걸처 문자를 정의 할 수도 있고 // JS의 변수를 문자열 안에 바로 연결할 수 있는 이점이 생긴다. const ssafy = '5반' const word3 = `${ssafy}안녕들 하신가` Null \u0026 undefined (Empty Value) 타입 // Empty Value (null \u0026 undefiened) // 값이 존재하지 않음을 표현하는 값으로 null과 undefiend가 있다. // 두 개가 존재하는 이유는 단순한 설계 실수로 인함 때문이다. let firstName console.log(firstName) // 변수 값을 지정하지 않으면, undefined 출력됨. let lastName = null console.log(lastName) // null // null과 undefined의 차이 // null 또는 undefined를 검사할 때, 동등 연산자(==)와 일치 연산자(===)의 차이를 주의하세요. // 동등 연산자는 자료형 변환을 수행합니다. typeof null // \"object\" (하위호환 유지를 위해 \"null\"이 아님) typeof undefined // \"undefined\" null === undefined // false null == undefined // true null === null // true null == null // true !null // true isNaN(1 + null) // false isNaN(1 + undefined) // true 심볼형(Symbol) // 심볼 자료형은 ES6부터 추가된 원시 자료형입니다. // 다른 원시형과 다르게(유일하게) 변경 불가능한 자료형으로, // 참조형의 키(key)로도 사용이 가능합니다. // Symbol 선언 방법 const symbol = Symbol(); const hello = Symbol('Hi'); console.log(hello) //Symbol(Hi) // new 연산자를 이용한 문법은 TypeError가 발생됩니다. var sym = new Symbol(); // TypeError // 특성 console.log(Number(1) === Number(1)) // true console.log(\"심볼 비교1\", Symbol() === Symbol()) // false 👈왜? console.log(\"심볼 비교2\", Symbol('Hi') === Symbol('Hi')) // false 👈왜?? console.log(typeof(Symbol())) // symbol // 👉 심볼 비교1, 2가 왜 false일까? // Symbol을 함수로 호출하는 경우에 값을 전달할 수 있는데 ex) Symbol('Hi') // 이 값은 디버깅 오로지 용도이고, (인자로 전달한 Hi에 따른) 고유한 symbol값은 생성되지 않습니다. // 즉, Symbol()는 항상 고유한 값을 반환합니다. // =\u003e const A = Symbol('Hi'), const B = Symbol('Hi') 같이 // 동일한 Symbol('Hi') 명령어로 A와 B를 생성했어도 // 각각 고유한 값을 가집니다. // 추가 실습 const nationality = Symbol('nationality') const user = {name: 'kim'} user[nationality] = \"korean\" console.log(user) // user: { name: 'kim', [Symbol(nationality)]: 'korean' } console.log(user[nationality]) // korean ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:1","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"2. 참조 타입(Reference Data Type) 참조 타입의 데이터는 크기가 정해져 있지 않고 변수에 할당이 될 때값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장됩니다. 데이터에 대한 참조만 저장 === 변수의 값이 저장된 힙 메모리의 주소값을 저장한다. === 변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근한다. 객체 Object // Object 객체 생성(선언) new Object() // 생성(생성자 함수 사용) const ob = new Object() console.log(ob) // ▪{} =\u003e __proto__: Object // 프로퍼티 추가 ob.id = 'qqq' ob.pass = 1234 ob.gender = \"m\" console.log(ob) // {id: 'qqq', pass: 1234, gender: \"m\"} // 추가 생성법 및 프로퍼티 추가 // 방법.1 const object1 = { a: 'foo', b: 42, c: {} }; console.log(object1.a); // \"foo\" // 방법.2 const a = 'foo'; const b = 42; const c = {}; const object2 = { A: a, B: b, C: c }; console.log(object2.B); // 42 // 방법.3 (방법.2에 이어서) const object3 = { a, b, c }; console.log(object3.a); // \"foo\" // 방법.4 (객체 리터럴 방식으로 생성) var me = {id: 'JG1', pass: 1234, gender:'m'} console.log(me.id) // \"JG1\" ////////////////////////////////////////////////////////////////////////////// // 2. Object (python의 dict와 비슷한듯.) // key는 문자열 타입이고, value는 모든 타입이 될 수 있다. const me = { name:'홍길동', // key가 한 단어 일때 'phone number':'01012345678', // key가 여러 단어 일때 samsungProducts: { galaxyWatch: '2019GalaxyWatch', galaxyPhone: 'galaxy S9', galaxyBuds: 'Buds V1', }, } // 두가지 방법으로 접근이 가능 // (1) dot notation me.name // 홍길동 me.samsungProducts.galaxyBuds // \"Buds V1\" // (2) []로 호출 me['phone number'] // '01012345678' // Object.keys() - O 대문자 const fruits = {a:'apple', b:'banana'} Object.keys(fruits) // [\"a\", \"b\"] // Object.values() Object.values(fruits) // [\"apple\", \"banana\"] //Object.entries() Object.entries(fruits) // [ [\"a\", \"apple\"], [\"b\", \"banana\"] ] // Object Literal (ER6+) const books = ['Learning JS', 'Eloquent JS'] const comics = { DC : ['Aquaman', 'SHAZAM'], Marvel: ['Captain Marvel', 'Avengers'] } const megazines = null const bookStore = { books: books, comics: comics, megazines: megazines, } bookStore.books[0] // 'Learning JS' 배열(Array) // 1. Array const numbers = [1,2,3,4] numbers[0] // 1 numbers[-1] // undefined / 정확한 양의 정수만 사용 가능 numbers.length // 4 //reverse - 원본 배열의 요소들의 순서를 반대로 정렬한다. numbers.reverse // [4,3,2,1] numbers.reverse // [1,2,3,4] const strings = ['d','c','b','a'] strings.reverse // ['a','b','c','d'] // push \u0026 pop - 요소를 배열의 가장 뒤에 추가하거나 삭제한다. numbers.push('a') // [1, 2, 3, 4, \"a\"] numbers.pop() // 'a' // unshift \u0026 shift - 요소를 배열의 가장 앞에 추가하거나, 제거한다. numbers.unshift('a') // [\"a\", 1, 2, 3, 4] numbers.shift() // 'a' // includes - 배열의 특정 요소가 있는지 여부를 boolean 값으로 반환해준다. numbers.includes(1) // true numbers.includes(0) // false // indexOf // 배열의 특정 요소가 있는지 여부를 확인 후, // 가장 첫번째로 찾은 아이템의 index값을 반환한다. // 요소가 없으면 -1을 반환 numbers.push('a','a') numbers.indexOf('a') // 4 numbers.indexOf('b') // -1 함수(function) // 함수 선언은 크게 두 가지로 나누어서 생각해볼 수 있다. // 1. Function Scope - var를 사용할 때 // python의 global 선언한 def 속 변수 느낌.. function number(num) { var acc = num + 1 return acc } console.log(acc) // num이 정의 되지 않아서 error if (true) { var name = '용우와 영수' } console.log(name) // '용우와 영수' // 2. Block Scope - const, let을 사용할 때 // {} 안에서만 존재하는 변수 // python의 global 선언 안한 def 속 변수 느낌.. let age = '30' if (true) { let age = '100' console.log(age) // 100 } console.log(age) // 30 function numberTwo(num) { let accTwo = num +1 return accTwo } console.log(numberTwo(2)) // 3 ​ ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:2","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Computer Science"],"content":"​ Process VS Thread 면접 질문에서 가장 많이 들어본 이야기라고 친구들이 이야기 해줬습니다. 근데 전 아직 자신있게 설명할 정도로 알지 못하기에 알아봅시다! ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:0:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"프로그램(Program)란 무엇인지 우선 알아봅시다. 소프트웨어의 한가지로, 어떤 문제를 해결하기 위하여 그 처리 방법과 순서(a.k.a ALGORITHM)를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체를 뜻합니다. 쉽게 말해, “어떤 작업을 위해 실행할 수 있는 파일”을 뜻합니다. 그리고 그 프로그램을 실행 시키는 주체를 인스턴스라고도 표현합니다. 예들 들어, Excel.exe, kakaotalk.exe 등과 같이 어떤 작업을 위해 실행할 수 있는 (설치 등)파일을 생각해 볼 수 있습니다. ​ ​ Process Process는 프로그램의 인스턴스(독립적인 개체)가 실행되어 메모리에 적재된 것을 말합니다. 조금 다르게 운영체제로부터 시스템 자원을 할당받는 자원의 크기라고도 말할 수 있습니다. 조금 간단하게는 “실행된 프로그램을 의미\"합니다. 앞서 운영체제로부터 할당을 받는다고 설명했는데 CPU의 시간 / 운영되기 위해 필요한 주소 공간 / Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역등이 대상입니다. ​ 즉, 프로그램을 실행하게 되면 CPU의 일정 용량?을 차지하면서 수행하는 주체가 Process입니다. 하여, 프로그램은 하나인데 Process는 여러 개가 동작할 수 있습니다. (==인스턴스가 여러 개) 예를 들어 엑셀을 사용하고 있는데, 새로 만들기로 엑셀창을 하나 더 열 수도 있겠죠? 여기서 엑셀 실행파일이 Program, 엑셀창이 Process입니다. 간단히 1개의 Program으로 2개의 Process를 동작시킨 것입니다. ​ 🙋‍♂️ 이제 프로세스(Process)의 특징에 대하여 좀 더 알아봅시다. 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받습니다. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. BUT 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용하면 가능해집니다. Ex) 파이프, 파일, 소켓통신, mapped file 등을 이용한 통신 방법 이용 ex) 실제로 엑셀의 경우 A엑셀파일, B엑셀파일이 있을 때, B의 특정 셀값을 A에서 불러와 사용할 수 있습니다. 즉, 프로세스간에 통신이 가능합니다. ​ ​ Thread 프로세스(Process) 내에서 실행되는 흐름의 단위으로 프로세스 하나에 자원을 공유하면서 일련의 과정, 여러 개를 동시에 실행시킬 수 있는 것을 말합니다. 기본적으로 하나의 프로세스가 생성되면 하나의 Thread가 같이 생성됩니다. 이를 Main Thread라고 부르며, thread를 추가로 생성하지 않는 한, 모든 프로그램 코드는 Main Thread에서 실행됩니다. ​ Multi Thread 그림을 보면 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유하고 ( Stack만 스레드 별로 가지게 됩니다. ) 하나의 프로세스는 여러 개의 스레드를 가질 수 있는데, 이를 Multi Thread라고 합니다. 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있습니다. ​ 🙋‍♂️ 다른 자원들은 공유하지만 굳이 스택만 분리해서 사용하는 이유는? LIFO(Last In First Out) / 후입 선출이라는 스택의 특성과도 연관이 있습니다. 왜냐하면? Code와 Data, Heap 영역을 공유하는 것에는 큰 문제가 없지만, 스택 영역은 스택이 쌓이면 위에서부터 프로세스가 섞인 채로 순서대로 나오게 되므로 더 복잡해지기 때문에 원활한 실행 흐름을 위해 스택은 따로 독립적으로 존재하게 됩니다. ​ ​ Multi Process 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것. 😆 장점 안정성이 좋음 - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않습니다. 😔 단점 Context Switching(여러 프로세스를 왔다 갔다 하는 것)에서의 오버헤드 Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됩니다. 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 합니다. 프로세스 사이의 어렵고 복잡한 통신 기법(IPC) ​ *오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. ​ ​ ​ 이런 단점들을 보완하기 위해 Multi Thread가 등장하였습니다. Multi Thread 하나의 프로세스 내에서 여러 개의 thread가 동작하는 것을 말합니다. 😆 장점 시스템 효율성이 향상됩니다. 프로세스에서 자원을 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 즉, 시스템의 자원 소모를 줄일 수 있습니다. 시스템 처리량이 증가 됩니다. 스레드 사이에 작업량이 작아 Context Switching이 빠릅니다. 결과적으로 프로그램 응답 시간이 단축됩니다. 프로세스 간 통신 방법에 비해 thread간의 통신 방법이 간단합니다. ✔ 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다. ✔ Context Switching시 스레드는 Stack 영역만 처리하기 때문 😔 단점 여러 개의 스레드를 이용하는 경우, 미묘한 시간차나 잘못된 변수를 공유함으로써 오류가 발생할 가능성이 있습니다. 하여 Thread-Safety하게 구현해야 합니다. ex) 스레드1이 공유 자원 내의 A데이터를 조작하다가, 스레드2에 제어권을 넘겨준 이후 스레드2가 A데이터를 변경한다면 스레드1이 다시 제어권을 받아 남은 작업을 계속할 때 원치 않는 결과가 나올 수 있다. 프로그램 디버깅이 어렵습니다. 단일 프로세스 시스템에서는 효과를 기대하기 어렵습니다. ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:1:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"Thread-Safety 스레드 안전(thread 安全, 영어: thread safety)은 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다. Re-entrancy(재진입성) 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. (동기화 잘 하라.) Mutual exclusion(상호 배제) 공유 자원을 꼭 사용해야 할 경우 해당 자원의 접근을 세마포어 등의 락으로 통제한다. (역시 동기화 잘 하라.ㅎ.) Thread-local storage(스레드 지역 저장소) 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. (글로벌 변수 등의 사용을 남발하지 말라.) Atomic operations(원자 연산) 공유 자원에 접근할 때 원자 연산을 이용하거나 ‘원자적’으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다. (역시 동기화 잘 하라는 건데, python 연산자를 예로 “+=“는 한줄의 코드 임에도 “+“를 한 후에 “=” 연산을 하기 때문에 원자적이라고 할 수 없다고 봅니다.) ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:0","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"부록 자바에서 동기화 방법 Synchronized Volatile Atomic Class ​ ​ 👀요약 운영체제는 Process 단위로 메모리를 할당해주고, 같은 프로세스 소속의 Thread는 메모리를 공유합니다. (스레드도 각자의 스택영역을 보유하므로 완전히 공유한다고 보기는 어렵습니다.) ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:1","tags":["CS","Process","Thread","computer science"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["web"],"content":"​ HTTP vs HTTPS 웹개발 프로젝트를 하면서 인터넷 주소창(URL)을 자주 보게 되었습니다. 그러던 중 HTTP와 HTTPS의 차이를 발견하였고 단순히 HTTPS가 보안이 더 뛰어나서 적용하면 좋다. 정도의 개념만을 가지고 있다, ‘한 번 차이를 깔끔히 정리하면 좋겠다.’ 싶어 정리해보겠습니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:0:0","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"뜬금없이 URL란 무엇인지 우선 알아봅시다. 우리가 ‘인터넷 주소창’이라고 흔히 말하는 URL은 Uniform Resource Locator, 자원 위치 규약? 정도로 이해하면 좋을 것 같습니다. 우리가 사는 주소를 잠시 생각해봅시다. 먼저, 대한민국안에 서울특별시에 있는 강남구를 생각해보면 대한민국이라는 국가에서 서울특별시라는 위치로 그리고 그 안에 강남구로 범위를 좁히며 구체적인 위치를 생각할 수 있습니다. 이렇듯. URL은 인터넷 상의 여러 페이지의 주소입니다. 예를 들어, https://colinder.github.io/는 https://colinder.github.io/라는 페이지를 보여주고, https://colinder.github.io/hugo_setting/은 https://colinder.github.io/안에 hugo_setting/의 페이지도 이동하는 것이죠. URL과 웹 사이트 주소를 같은 것이라고 생각할 수 도 있는데, URL은 웹 사이트 주소보다 큰 개념이고, 웹 사이트 주소 뿐만 아니라 네트워크 상에 연결된 다양한 자원까지 포함된 개념입니다. URL은 위에서 말한대로 일종의 규약인데 URL에 접속하는 경우에는 해당 URL에 맞는 *프로토콜을 알아야 합니다. *FTP은 파일 전송을 위해, HTTP는 온라인 문서와 같은 리소스를 보기위해 사용합니다. 그리고 HTTP를 편리하게 이용할 수 있게 만든 응용 소프트웨어가 ‘웹 브라우저’(ex. 크롬, 사파리, 익스플로러)입니다. ​ *프로토콜: 복수의 컴퓨터 혹은 단말기와 데이터 통신을 원활하게 하기 위해 필요한 통신 규약 *FTP: File Transfer Protocol / 파일을 전송하는 방법 혹은 그런 프로그램 ​ ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:1:0","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"HTTP (HyperText Transfer Protocol) 이제 HTTP입니다! 위에서 살짝 언급했듯이, HTTP는 인터넷에서 웹 서버와 사용자(우리) 컴퓨터에 설치된 웹 브라우저 사이에 문서(DOM)를 전송하기위한 통신규약입니다. 저는 HT의 뜻이, HTTP를 이해하는데 핵심이라고 생각합니다. HyperText: 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트. 간단히 클릭을 통해 여러 문서를 이동하며 내용을 볼 수 있는 것입니다. 즉, http://colinder.github.io는 colinder.github.io라는 주소(도메인)을 HyperText Transfer Protocol 형태로 받아와서 보여주세요! 정도로 해석할 수 있습니다. ​ ​ 그럼 HTTPS는 무엇일까요? ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:2:0","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"HTTPS (HyperText Transfer Protocol + Secure Socket) HTTP + S(Secure Socket) 즉, HTTP에서 Secure Socket이 추가된 것이 HTTPS입니다. 간단히 HTTPS을 사용하면 암호화된 Protocol을 사용한다는 뜻입니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:0","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"🤔Secure Socket은 무엇일까요? Secure Socket은 SSL(Secure Socket Layer) 프로토콜을 의미하는데, 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약입니다. SSL는 과거의 명칭이고, SSL이 표준화되면서 TLS(Transport Layer Security)로 바뀌어 사용되고 있습니다. 보안이 어떻게 진행되는지 알아보겠습니다. 공개키와 대칭키로 암호문을 주고 받는 과정을 보며, 보안의 강점이 있는 것을 알았습니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:1","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"🙄 좋은 점은 보안뿐일까요? HTTPS의 장점은 보안상 우위에만 있는 것이 아닙니다. 사실 HTTPS로 전환하게 되면 검색엔진 최적화(SEO)에 있어서도 큰 혜택을 볼 수 있습니다. (구글이 HTTPS 웹사이트에 가산점을 주어 검색시 노출에 혜택을 주겠다고 공표했습니다.) 사용자들이 결국에는 가장 안전하다고 생각하는 사이트를 더 많이 방문하기 때문이기도 합니다. 또한 가속화된 모바일 페이지(AMP, Accelerated Mobile Pages)를 만들고 싶을 때도 HTTPS 프로토콜을 사용해만 합니다. 여기서 AMP란 모바일 기기에서 훨씬 빠르게 콘텐츠를 로딩 하기 위한 방법으로 구글이 만든 것입니다. AMP는 HTML에서 불필요한 부분을 없앤 것이라고 볼 수 있습니다. 구글의 SERP(검색 결과 페이지)를 보면 스마트폰과 태블릿의 사용자들이 모바일에서 사용하기 편하도록 AMP 콘텐츠들이 두드러져 보이는 것을 볼 수 있습니다 모바일 친화적인 웹사이트를 만드는 것과 모바일 검색순위 및 지역에 SEO를 증가시키는 것이 점점 더 중요해지고 있는 요즘, HTTP를 HTTPS로 전환하는 것이 강점이 있다는 것을 알 수 있습니다. ​ ​ 👀요약 http와 https의 가장 큰 차이는 보안기술이 적용되었는지 아닌지가 맞았습니다. 다만, 보안이 우수한 사이트가 노출에 이점이 있다는 점. 어떤 보안 기술이 적용되고 있는지와 어떤식으로 보안 기술이 작동하는지 알 수 있었습니다. 추가로 직접 정리한 SSL 진행 절차가 보기 어려울 수 있어서 단계별로 정리해보겠습니다. 사이트 안전성 인증 받기 사용자와 사이트 간의 인증 내용 확인 사용자와 사이트 간의 통신 ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:2","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"참고한 글 https://post.naver.com/viewer/postView.nhn?volumeNo=16561296\u0026memberNo=1834 https://blog.globalhost.co.kr/19 https://12bme.tistory.com/80https://constant.kr/blog/2018/08/10/ssl-%EC%9D%B4%EB%9E%80-%EA%B5%AC%EA%B8%80%EC%97%90%EC%84%9C-ssl%EC%9D%84-%EC%A4%91%EC%9A%94%ED%95%98%EA%B2%8C-%EC%97%AC%EA%B8%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0/ http://blog.wishket.com/http-vs-https-%EC%B0%A8%EC%9D%B4-%EC%95%8C%EB%A9%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%EB%A0%88%EB%B2%A8%EC%9D%B4-%EB%B3%B4%EC%9D%B8%EB%8B%A4/ ​ ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:4:0","tags":["http","web","https"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"​ 도메인(domain)이란? 도메인의 뜻은 무엇일까요? 어찌저찌 설명할 순 있지만, 확신을 가지고 정확하게 답할 수 없었기에 정리해보겠습니다. ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:0:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["web"],"content":"이번에도 뜬금없이 ‘IP’ 란 무엇인지 우선 알아봅시다. IP는 Internet Protocol의 약자로 인터넷에 연결되어 있는 장치(컴퓨터, 스마트폰, 타블릿, 서버 등등)들은 각각의 장치를 식별할 수 있는 주소를 가지고 있는데 이를 ip라고 합니다. 간단히 각 장치(device)들의 주민등록번호라고 생각하면 이해하는데 도움이 됩니다. ex) 125.209.222.141, 172.217.175.238 ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:1:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["web"],"content":"도메인(domain)이란? ip는 사람이 이해하고 기억하기 어렵기 때문에 쉽게 접근할 수 있게 각 ip에 고유한 이름을 부여할 수 있게 했는데, 이것을 도메인이라고 합니다. 125.209.222.141 =\u003e naver.com 172.217.175.238 =\u003e google.com 당연하게도 125.209.222.141과 naver.com은 같은 주소를 의미하니까 URL에 125.209.222.141를 입력하면 naver 메인 페이지로 이동할 수 있습니다. ​ ​ 👀요약 간단하게 IP와 도메인이란 무엇인지 알아봤습니다. 기초적인 지식일 수록 정확하게 알고 싶어서 정리해봤습니다. 간단하쥬?ㅎ 추가로 cmd를 켜고 nslookup \u003c인터넷도메인\u003e 을 입력하면 ip주소를 확인할 수 있습니다. ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:2:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["Javascript"],"content":"​ Async to Sync in JavaScript 누구나 웹개발을 하다보면 HTTP 통신을 통해 데이터를 가져오고 가공하고 사용하게됩니다. 그리고 동기, 비동기 처리 때문에 골치가 아파집니다. (만약 골치가 아프지 않다면.. 부럽습니다..) 더 이상 골치아프기 싫어서 정리해봅시다.👍 *동기, 비동기 설명은 이전 포스팅으로 갈음합니다. ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:0:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"Async(비동기) to Sync(동기) 방법 자바스크립트에서의 비동기를 동기로 동작시키는 대표적인 3가지의 방법을 알아보겠습니다. Callback Promise Async / Await ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:1:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"1. Callback 개발자들 마다 정의가 조금씩 다르겠지만, 저는 어떤 이벤트가 발생한 후, 수행될 함수로 정의해보겠습니다. 예제를 보며 이해해 봅시다. // Callback 사용 예제 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 callback이라는 함수를 받는다. const data = 'i am data' // i am data라는 값을 담은 변수 data를 생성 callback(data) // callback이라는 함수에 data라는 변수를 넘겨줌. } function b(value) { // 함수 b는 입력받은 값 value를 콘솔에 출력하는 함수. console.log('넘겨받은 값', value) } // 사용해 봅시다. a(function(value) { // 함수 a에 function을 받는데 값으로 value를 받는다. console.log('넘겨받은 값', value) // 함수 a가 실행되면 자동으로 const data를 만드는데 data에는 'i am data'라는 값이 할당. 되고 value가 된다. }) // 위를 간소화한 코드. a(b) ​ 위의 예제 코드가 눈에 들어왔다면, 먼저 비동기적 코드를 만들어 봅시다. // Callback 비동기적 코딩 // a가 동작하고 b가 동작하길 원하며 코딩 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 2초 후에 동작 setTimeout(function() { console.log('running a....') }, 2000) } function b() { // 함수 b는 1초 후에 동작 setTimeout(function() { console.log('running b....') }, 1000) } // 실행해봅시다. a() b() setTimeout이라는 javascript의 가장 대표적인 동작 지연 함수를 사용해 코딩해보았고 결과로 a → b의 순서가 아닌 함수 동작 시간에 따른 딜레이를 확인해보았습니다. ​ 어떻게 해야 내가 코딩한 순서대로 (a → b) 동기적으로 작동하게 만들 수 있을까요? // Callback 동기적 코딩 // a가 동작하고 b가 동작하길 원하며 코딩 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 2초 후에 동작 setTimeout(function() { console.log('running a....') callback() // 👈 callback함수를 추가 }, 2000) } function b() { // 함수 b는 1초 후에 동작 setTimeout(function() { console.log('running b....') }, 1000) } // 실행해봅시다. a(b) 원하는 동작 console.log(‘runing a….')뒤에 callback함수를 넣어 console.log(‘runing b….')를 동작했습니다. 간단해보이지만 강력하고, 막상 적용하려면 어려울 수 있습니다. 연습을 추천합니다.😊 근데 callback 함수는 대부분의 개발자들이 간단한 코딩에만 사용합니다. 단순히 1, 2개 정도의 요청이라면, callback 함수로 처리할 수 있지만, 만약 그 수가 많아진다면, 소위 callback HELL이 되기 때문입니다. 그래서 다른 방법도 알아봅시다! ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:2:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"2. Promise Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다. 간단히 비동기 작업에 사용되는 객체입니다. Promise는 ex) new Promise (function ( resolve, reject )) 의 형태로 사용됩니다. 특징으로 Promise의 인자는 반드시 function을 받아야 합니다. (동작 성공시 실행될 resolve라는 함수와 실패시 동작할 reject / 2개의 인자를 받습니다.) Promise 는 3가지 상태가 존재합니다. 만약 인자를 받지 않거나 함수 이외의 값을 전달하면, Uncaught TypeError가 발생하고, 인자로 전달된 resolve 와 reject 중 하나라도 호출하지 않는다면, 영원히 pending 상태로 대기하게 됩니다. 또 Promise 객체들은 .then() 을 통해 이어질 수 있고 .catch() 를 통해 에러 캐치를 할 수 있습니다. 이 부분을 활용해 동기 처리를 합니다. // Promise 사용 예제 function test() { // test라는 동작(함수)을 만드는데 return new Promise(function(resolve, reject) { // Promise로 만들고 Promise는 인자로 resolve, reject를 받는다. try { // 정상처리되면(조건은 다양하게 구성) resolve( // resolve를 동작하는데 console.log('Promise resolve') // Promise resolve를 출력하고 ) } catch { // error가 발생하면 reject( // reject를 동작하는데 console.log('Promise reject') // Promise reject를 출력한다. ) } }) } test() // test를 동작(함수실행)하는데 .then((res) =\u003e // 에러가 없다면 console.log('정상 처리 완료') // '정상 처리 완료'를 출력하고 ) .catch((err) =\u003e // 에러가 발생했다면 console.log('에러 발생') // '에러 발생'을 출력한다. ) ​ 위의 예제 코드가 눈에 들어왔다면, 이제 동기적 코드를 보며 이해해봅시다. // Promise 동기적 코딩 // 1,2,3 순서대로 출력되길 원하며 코딩 function test() { // test라는 동작(함수)을 만드는데 return new Promise(function(resolve, reject) { // Promise로 만들고 Promise는 인자로 reselve, reject를 받는다. try { setTimeout(function() { // AJAX등의 처리를 기다리는 '지연 시간'을 setTimeout으로 설정 resolve( console.log('1') ) // resolve처리를 하는데 3초의 딜레이를 주고 },3000) console.log('2') // resolve } catch { reject( console.log('reject running') ) } }) } function b() { setTimeout(function() { console.log('3') }, 1000) } // 실행해봅시다. test() .then(b) // .then(function() {b()}) ////////////////////////////////////////////////////////////////////////////////////// // .then(b) === .then(function() {b()}) === .then(() =\u003e {b()}) !== .then(b()) // .then(b) / .then(function() {b()}) / .then(() =\u003e {b()})는 // \"test함수에 오류가 없다면 b함수를 return 하라\" 라는 의미기 때문에 동기적인 처리가 가능! // 반면 .then(b())는 \"test함수에 오류가 없으면 b라는 함수를 실행하라\" 라는 의미기 때문에 // 순서에 상관없이 오류가 없다면 b를 즉시 실행한다. // 비슷하게... // .then(console.log('hi'))는 \"요청들어오면 hi를 출력하라\" 라는 의미고 // .then(function() {console.log('hi')}) or .then(() =\u003e {console.log('hi')})는 // \"어떤 요청의 결과로 hi를 return하라\" 하는 의미기 때문에 동기적으로 동작한다. 위 설명에는 1,2,3 순서대로 출력되길 원하며 코딩이라고 적어놨지만, 결과 화면은 다른 것을 알 수 있습니다. 실은 2,1,3 순서대로 출력되는 것을 의도한 코딩입니다. 2의 경우 resolve에 포함되어 있지 않기 때문에 *인터프리터 언어 특징에 따라 진행되기 때문입니다. *인터프리터 언어의 특징은 다른 포스팅에 정리되어 있습니다. ​ 하지만 Promise 또한 단계?가 많아진다면 가독성 매우 떨어질 수 있습니다. 사실 callback과 Promise를 사용하는데 가독성에 문제가 있다면, 본인의 코드를 의심해봐야 될 수 있습니다.👀ㅎ. ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:3:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"3. Async / Await Async(비동기) / Await(기다려!)는 비동기 처리를 하는 방법 중 하나입니다. Promise 나 Callback 보다 가독성이 좋은 코드를 짤 수 있다고 생각합니다. 위에 Promise를 살펴본 이유가 있습니다. Async/await의 기반이 Promise이기 때문입니다. 우리가 쓰는 모든 async 함수는 Promise를 리턴하고, 모든 await 함수는 일반적으로 Promise가 됩니다. Async/await는 ex) async function functionName(){ await  promiseFunction } 의 형태로 사용됩니다. sync function은 내부에 await 문법을 사용하기 위해 선언합니다. async function은 AsyncFunction 객체를 반환하며 ‘async function’ 표현식으로만 생성됩니다. async function은 인자를 받을 수 있으며, 실행 후 반환 값은 Promise 입니다. await 연산자는 async function 내부에서만 사용할 수 있습니다. (외부에서 사용하면 SyntaxError가 발생.) await는 반환된 Promise의 resolve의 상태까지 대기하며, await의 값은 Promise의 resolve값이 반환됩니다. 만약 중간에 reject를 만나면 해당 async function스코프의 작업을 중단되며, 이후 스코프 작업이 진행됩니다. // Async/Await 사용 예제 function promise() { return new Promise(function(resolve, reject) { resolve(10) }) } async function foo() { const num = await promise() console.log(num) } // 돌려봅시다! foo() // 10 ​ 위의 코드가 이해 되셨다면 동기적 사용에 대한 코드를 보며 이해해 봅시다. // Async/Await 동기적 코딩 function promise() { console.log('AsyncAwait running...') return new Promise(function(resolve, reject) { setTimeout(function() { resolve(10) }, 5000) }) } async function foo() { console.log('foo running...') const num = await promise() console.log('num:', num) } // 돌려봅시다! foo() 가독성이 훨씬 뛰어나다고 생각합니다. Promise를 선언하고 이를 await 걸어, 순서를 정리하는 방법으로 코딩을 하다보니 가독성은 좋지만, Promise의 사용법도 익혀야 한다는 단점이 있습니다. ​ 👀요약 공부한 3가지 방법 모두 유용하고 강력한 기능이라는 생각입니다. 모두를 익히면 좋고 선택적으로 익혀야 한다면 본인에게 잘 맞는 방법으로 익혀 사용하면 좋을 것 같습니다. ​ ​ 🤷‍♂️삽질 Async/Await 관련해서 혼자 이런 저런 테스트를 해보니 위에 설명한 것과 같이 new Promise()로 선언한 것들만 동기적으로 작동했고 일반 function으로 선언한 것들은 원하는 대로 동작하지 않았습니다. 또 주의할 점에 // 여러 test 중 하나. function promise() { console.log('AsyncAwait running...') return new Promise(function(resolve, reject) { setTimeout(function() { resolve(10) }, 5000) }) } function test2Promise() { console.log('test2Promise 시작') return new Promise(function(resolve, reject) { setTimeout(()=\u003e { console.log('test2Promise running...') // 👈 Promise의 resolve가 없습니다. },3000) }) } async function foo() { console.log('foo running...') const num = await promise() // await test1() await test2Promise() console.log('num:', num) } // 돌려봅시다! foo() test2Promise의 resolve를 등록하지 않으면 이전 Promise()인 promise()도 resolve가 정상적으로 진행되 않는 것을 볼 수 있습니다. 위에서 설명한 만약 인자를 받지 않거나 함수 이외의 값을 전달하면, Uncaught TypeError가 발생하고, 인자로 전달된 resolve 와 reject 중 하나라도 호출하지 않는다면, 영원히 pending 상태로 대기하게 됩니다. 가 발생한 것입니다. ​ 공부를 하던 중 .then()에 대한 흥미로운 내용을 확인했습니다. .then()은 요청의 결과가 성공했을 때 사용하는 것으로만 생각했는데 인자를 2개 받는 다는 것을 알았습니다. 확인해보니 .then() 에 넘겨지는 인자는 선택적(optional)이었습니다. 그리고 catch(failureCallback) 는 then(null, failureCallback) 의 축약었습니다. ​ ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:4:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"참고 했던 글 https://medium.com/@olaf.go/javascript-async-to-sync-157c57208598 https://victorydntmd.tistory.com/48 https://medium.com/@pks2974/javascript-%EC%99%80-promise-a6db8ca424ed https://joshua1988.github.io/web-development/javascript/js-async-await/ https://medium.com/@pks2974/javascript-%EC%99%80-async-await-111fdad3c20d https://mber.tistory.com/8 https://medium.com/@kiwanjung/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4 https://joshua1988.github.io/web-development/javascript/promise-for-beginners/#promise%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise ​ ​ Special Thanks to kmpak.sfy✨. ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:5:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Interpreter","Compiler"],"content":"​ Interpreter VS Compiler_Language web 개발을 하다보면 javascript를 공부하게 되고, javascript를 공부하다보면, 어려워지죠ㅎ. 더 어려워 지기 전에 기초적인 지식?인 인터프리터 언어와 컴파일 언어의 특징과 차이에 대하여 알아봅시다! ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:0:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"뜬금없이 프로그래밍 언어란 무엇인지 우선 알아봅시다. 컴퓨터는 이진수만 이해할 수 있습니다. 즉 컴퓨터는 우리가 사용하는 언어가 아닌 ‘0’, ‘1’만 이해합니다. 근데 이게 프로그래밍 언어랑 무슨 상관일까요? 상관이 아주 많습니다…ㅎ.. 프로그래밍 언어로 프로그램을 만들고 실행 할 때 우리는 ‘0’, ‘1’ 같은 명령어로 코딩을 하지 않습니다. 도대체 우리가 영어로 작성한(C, java, python 등등) 코딩을 어떻게 컴퓨터가 이해하고 실행하는 것일까요? 모든 프로그래밍언어는 그 프로그래밍 언어를 기계어 명령어로 번역해 줄 번역기가 존재합니다. 그리고 그 번역기가 영문으로 된 프로그래밍 언어(사람이 이해하기 쉬운 언어를 고급 언어라고 부릅니다.)를 ‘0’, ‘1’로(기계어 명령어) 번역해줍니다. 추가로 누구나, 프로그래밍 언어를 배울 때 환경 설정을 하게 됩니다. 예를 들어 자바라면 JDK를 설치하고, 파이썬이라면 파이썬을 설치하고, C라면 gcc와 같은 프로그램을 설치합니다. 여러분이 프로그래밍 언어를 배우기 위해 환경 설정 할 때 설치했던 바로 그 개발환경설정 툴 중에 이 번역기가 반드시 포함되어 있습니다. *근데 번역기는 번역 시기에 따라 크게 인터프리터 언어와 컴파일러 언어로 구분합니다. ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:1:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"Interpreter_Language(인터프리터 언어) 고급 언어로 작성된 소스코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 언어. javascript, HTML, SQL, python, R, ruby 등 고급 언어를 한 줄씩 중간 코드(intermediate code)로 변환하고 이를 각 행마다 실행합니다. 100줄의 명령어(==소스파일)가 있으면, 100번 실행합니다. 즉, Runtime상황에서는 한 줄씩 실시간으로 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다. But 실행속도는 느리지만 코드 변경시 빌드 과정없이 바로 실행이 가능하다는 장점이 있습니다. javascript를 사용해보면 소스코드를 고치고 서버를 다시 시작하지 않아도 변경사항이 반영된 상태로 테스트를 진행할 수 있습니다. 또한 명령어을 잘못 입력해도 바로바로 수정할 수 있습니다. 또한 실행중에 발생한 에러가 각 행(row)별로 전달되는데, 에러 이후 작성된 코드는 확인하지 않습니다. 이는 보안적인 관점에서 도움이 됩니다. ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:2:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"Compiler_Language(컴파일러 언어) 고급 언어로 작성된 소스코드 명령어들을 모두 모아 기계어로 번역(build) 하고 이를 실행하는 언어. build ? build는 소스파일을 실행파일로 생성하는 과정입니다. 즉, 고급언어 =\u003e (변환) =\u003e 저급언어(기계어) 과정을 거쳐서 실행파일로 생성해 구동합니다. C, C++. C# 등. 소스코드를 기계어로 번역하는 빌드 과정에서는 인터프리터 언어에 비해 시간이 소요됩니다. 하지만 Runtime상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 빠르게 실행할 수 있습니다. 메모리도 많이 차지합니다. ​ ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:3:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["react-native"],"content":"​ React-Native google login 서비스를 개발하다보면 로그인 기능이 새삼 대단해보입니다. 신경쓸 것도 많고, 하지만 이런 수고를 sns로그인 기능으로 대신한다면 편의성이 많이 높아집니다. 하여 해보겠습니다. *google login을 하기 위해 firebase(모바일 및 웹 애플리케이션 개발 플랫폼)을 사용합니다. 개발환경 npm으로 진행 react-native_cli (✨expo로 진행하지 않습니다.) android 기준 함수형 컴포넌트로 진행 (✨ 클래스 컴포넌트로 진행하지 않습니다.) RN 버전 0.60이상에서 진행 react-native-cli: 2.0.1 react-native: 0.63.3 ​ googleSignin 프로젝트 생성 후 googleSignin.js 생성 ​ index.js 에서 시작앱 변경 # index.js /** * @format */ import {AppRegistry} from 'react-native'; import App from './googleSignin'; // 변경 import {name as appName} from './app.json'; AppRegistry.registerComponent(appName, () =\u003e App); ​ googleSignin.js 틀 잡기 # googleSignin.js import React from 'react' import { View, Text } from 'react-native' const googleSignin = () =\u003e { return ( \u003cView\u003e \u003cText\u003egoogle Sign in\u003c/Text\u003e \u003c/View\u003e ) } export default googleSignin ​ react native google login github 이동 후 root폴더 에서 google-signin 설치 npm install --save @react-native-community/google-signin ​ Andriod guide로 이동 google-services.json 파일을 generate해야 한다고 합니다. 이걸 위해 firebase에 등록하러 갑시다. ​ firebase 이동 프로젝트 추가 (+) Android 패키지 이름 추출 *root/android/app/src/main/AndroidManifest.xml 에서 확인 sha1 추출 # root/android/app으로 이동 # terminal keytool -list -v -keystore debug.keystore -alias androiddebugkey -storepass android -keypass android 다시 firebase에서 안드로이드 설정 선택 앱 등록 진행 하다보면 google-services.json다운이 가능 *혹시 에러 뜨면 pakage name변경 진행 # In: android/app/src/main/java/MY/APP/NEW_ID/MainActivity.java: package 새로운 패키지 이름 등록; # In: android/app/src/main/java/MY/APP/NEW_ID/MainApplication.java: package 새로운 패키지 이름 등록; # In: android/app/src/main/AndroidManifest.xml: package=\"새로운 패키지 이름 등록\" # And in android/app/build.gradle: applicationId \"새로운 패키지 이름 등록\" # In: android/app/BUCK: android_build_config( package=\"새로운 패키지 이름 등록\" ) android_resource( package=\"새로운 패키지 이름 등록\" ) # Gradle' cleaning in the end (in /android folder): ./gradlew clean google-services.json다운 후 root/android/app안에 넣기 ​ 다시 Andriod guide로 돌아와서 2. Installation 진행 link the native module (난 RN \u003e= 0.60니까 pass) Update android/build.gradle with buildscript { ext { buildToolsVersion = \"27.0.3\" minSdkVersion = 16 compileSdkVersion = 27 targetSdkVersion = 26 supportLibVersion = \"27.1.1\" googlePlayServicesAuthVersion = \"16.0.1\" // \u003c--- use this version or newer 👈(추가) } ... dependencies { classpath 'com.android.tools.build:gradle:3.1.2' // \u003c--- use this version or newer 👈(default로 입력되어 있었음) classpath 'com.google.gms:google-services:4.1.0' // \u003c--- use this version or newer 👈(추가) } ... allprojects { repositories { mavenLocal() google() // \u003c--- make sure this is included 👈(default로 입력되어 있었음) jcenter() maven { // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url \"$rootDir/../node_modules/react-native/android\" } } } Update android/app/build.gradle with ... dependencies { implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) implementation \"com.android.support:appcompat-v7:23.0.1\" implementation \"com.facebook.react:react-native:+\" implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.0.0' // \u003c-- add this; newer versions should work too 👈(default로 입력되어 있었음) } ... ... apply plugin: 'com.google.gms.google-services' // \u003c--- 👈 this should be the last line 이후 내용은 link관련인데. 난 RN \u003e= 0.60니까 pass ​ 다시 react native google login github을 참고하며 진행 GoogleSignin # googleSignin.js import { GoogleSignin, GoogleSigninButton, statusCodes } from '@react-native-community/google-signin'; # googleSignin.js const googleSignin = () =\u003e { useEffect(() =\u003e { GoogleSignin.configure({ scopes: ['https://www.googleapis.com/auth/drive.readonly'], // what API you want to access on behalf of the user, default is email and profile webClientId: '\u003c요기는 firebase를 참고해서 입력합니다.\u003e', // client ID of type WEB for your server (needed to verify user ID and offline access) offlineAccess: true, // if you want to access Google API on behalf of the user FROM YOUR SERVER // hostedDomain: '', // specifies a hosted domain restriction // loginHint: '', // [iOS] The user","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_googlelogin/:0:0","tags":["react-native","web"],"title":"React-Native_google login","uri":"https://colinder.github.io/react-native_googlelogin/"},{"categories":["react-native"],"content":"참고 했던 글 https://www.youtube.com/watch?v=A1Ai4sKk0jM https://medium.com/humanscape-tech/hooks-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-usestate-useeffect-811636d1035e 패키지 이름 변경: https://stackoverflow.com/questions/37389905/change-package-name-for-android-in-react-native ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_googlelogin/:1:0","tags":["react-native","web"],"title":"React-Native_google login","uri":"https://colinder.github.io/react-native_googlelogin/"},{"categories":["react-native"],"content":"​ React-Native navigation vue는 router를 사용해 화면을 이동합니다. 그렇다면, react-native는 어떻게 화면을 이동할까요? 바로 react-native navigation을 사용합니다. 어떻게 사용하는건지 기록합시다. 공식홈페이지의 Getting started로 알아봅시다. ​ *새로운 프로젝트를 만들고 root폴더에서 진행. 개발환경 npm으로 진행 react-native_cli (✨expo로 진행하지 않습니다.) android 기준 함수형 컴포넌트로 진행 (✨ 클래스 컴포넌트로 진행하지 않습니다.) RN 버전 0.60이상에서 진행 react-native-cli: 2.0.1 react-native: 0.63.3 ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:0:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"React-Native navigation 개발환경세팅 Getting started의 npm설치 npm install @react-navigation/native ​ 화면을 조금 내려서 dependency도 설치 npm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view ​ entry file파일에 import 등록 제가 개발하는 당시 기준 index.js를 보면 9번 줄에 App에서 시작이 된다고 명시되어 있음으로 App.js (a.k.a entry file) 최상단에 import를 등록합니다. import 'react-native-gesture-handler'; *기본적인 사용환경 설정은 완료되었습니다. 다만, stack이라는 기술을 사용할 예정이라 추가로 진행할 것이 있습니다. ​ 공식문서의 stack navigator library로 이동 후 설치 npm install @react-navigation/stack *이제 정말 개발 환경 설정이 완료되었습니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:1:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"React-Native navigation 사용해보자 페이지를 이동하는 것과 페이지를 이동할 때 params(인자)를 같이 넘겨주는 방법을 기록합니다. 먼저, root폴더에 src라는 폴더를 만들고 / home.js와 user.js 파일을 만듭니다. (함수형으로 개발하니 rnfe + tab을 입력해 양식을 빠르게 불러올 수 있습니다.) 틀을 잡고 시작합니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"페이지 이동(RN navigation) import → entry file 코딩→ components 코딩 순서로 진행합니다. 설치한 navigation과 stack을 import 해줍니다. # App.js import 'react-native-gesture-handler'; import React from 'react' import { NavigationContainer} from '@react-navigation/native' //👈 import { createStackNavigator} from '@react-navigation/stack' //👈 ... const Stack = createStackNavigator(); //👈 추가로 stack을 사용하기 위해 변수 선언 ​ Usage # App.js import 'react-native-gesture-handler'; import React from 'react' import { NavigationContainer} from '@react-navigation/native' import { createStackNavigator} from '@react-navigation/stack' import HomeScreen from './src/home' import UserScreen from './src/user' const Stack = createStackNavigator(); const App = () =\u003e { return ( \u003cNavigationContainer\u003e \u003cStack.Navigator initialRouteName='Home'\u003e \u003cStack.Screen name='Home' component={HomeScreen}/\u003e \u003cStack.Screen name='User' component={UserScreen}/\u003e \u003c/Stack.Navigator\u003e \u003c/NavigationContainer\u003e ) } export default App # NavigationContainer (Fragments같은 겁니다.) # initialRouteName: 초기 화면을 Home으로 설정했습니다. ​ home.js와 user.js도 코딩합니다 # home.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { //👈 navigation을 등록 return ( \u003cView\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ //👈 onPress: 버튼이 눌리면 실행 navigation.navigate('User') //👈 이런 문법으로 사용 }} /\u003e \u003c/View\u003e ) } export default HomeScreen # user.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { // navigation을 등록 return ( \u003cView\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ navigation.navigate('Home') // 이런 문법으로 사용 }} /\u003e \u003c/View\u003e ) } export default UserScreen 이 상태에서 시뮬레이터를 돌려보면 화면 전환이 되는 것을 볼 수 있습니다. But 할 것이 남았습니다. 이제 params도 전달 해봅시다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:1","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"페이지 이동 with params navigation.navigate(A, B)는 두개의 인자를 받습니다. A는 이동할 컴포넌트의 ‘이름’, B가 ‘params‘입니다. (아래는 home.js → user.js로 params를 보내는 예제입니다.) ​ home.js에서 전달할 params를 구성합니다. # home.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { return ( \u003cView style={{ // 화면에 보기 좋게 간단한 스타일 설정 flex: 1, alignItems: 'center', justifyContent: 'center' }}\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ navigation.navigate('User', { // 두번째 인자 입력 userIdx: 100, userName: 'jong', userLastName: null, }) }} /\u003e \u003c/View\u003e ) } export default HomeScreen ​ user.js에서 parmas를 받습니다. # user.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const UserScreen = ({ route, navigation }) =\u003e { // route를 인자로 받음. const { userIdx, userName, userLastName } = route.params; // 전달받은 값(route) return ( \u003cView\u003e \u003cText\u003eUser Screen\u003c/Text\u003e \u003cButton title=\"To Home Screen\" onPress={() =\u003e { navigation.navigate('Home') }} /\u003e \u003cText\u003eUser Idx: {JSON.stringify(userIdx)}\u003c/Text\u003e {/* JSON의 string으로 받습니다. */} \u003cText\u003eUser Name: {JSON.stringify(userName)}\u003c/Text\u003e { route.params.userLastName \u0026\u0026 \u003cText\u003eUser LastName: {JSON.stringify(userLastName)}\u003c/Text\u003e} {/* 조건을 줘봤습니다. {인자가 있을 때만 \u003cText\u003e로 값을 표시} */} \u003c/View\u003e ) } export default UserScreen ​ *결과 화면 home.js user.js ​ ​ 👀요약 지금까지 components간의 이동과 params, 간단한 스타일의 적용을 알아봤습니다. 해보면 어렵지 않으나, 모르면 다른 세상 이야기같습니다. 다음은 react-native에 google login을 심어보겠습니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:2","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["web"],"content":"​ 개발을 하다보면, 유저의 로그인 기능을 고민하는 경우가 많습니다. 근데. 로그인 기능을 개발하다보면 꼭 마주치는 두 가지… cookie와 session에 대하여 알아보겠습니다. 다만 그전에 cookie와 session이 생기게 된 배경에 대하여 같이 알아 보겠습니다. ​ HTTP 프로토콜의 특징 HTTP는 Connectionless(비연결성)하고, Stateless하다고 합니다. Connectionless란, 클라이언트가 행위를 통해 서비스를 제공받기 위해 서버에 request(요청)를 하면 서버는 클라이언트의 요청값에 따라 클라이언트에게 response(응답)하게 됩니다. 이렇게 한번의 request — response의 결과로 클라이언트는 어플리케이션이 제공하는 서비스를 받게되면서, 서로의 접속을 끊게 된다는 특성입니다. Stateless란, 접속을 끊는 순간 서버와 클라이언트간의 통신이 끊키고 상태정보를 유지하지 않는다는 특성입니다. 이 두가지 특성은 장점이자 단점이 되는데, 접속을 유지함에 따르는 리소스를 줄일 수 있는 장점과 통신을 할때마다 클라이언트 인증을 해야한다는 단점이 있습니다. 그리고 이러한 단점을 보완하기 위해 쿠키, 세션이 생기게 되었습니다. ​ 쿠키(cookie)란? 웹 서버가 브라우저에게 지시하여 사용자의 로컬 컴퓨터에 파일 또는 메모리에 사용자 식별 정보를 저장하는 작은 테이터 파일입니다. 어떤 말인지 모르겠죠? ㅎ.. 📃 쿠키는 주로 아래의 세 가지 목적을 위해 사용됩니다. 세션 관리(Session Management) 로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장합니다. 개인화(Personalization) 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있습니다. 트래킹(Tracking) 사용자의 행동과 패턴을 분석하고 기록합니다. ​ 흐름을 보며 더 구체적으로 알아봅시다! 클라이언트(사용자)가 브라우저(사용자PC)를 통해 방문한 적 없는 페이지에 접속하면, 서버는 “세션 식별자(session identifier)” 정보를 담아 쿠키를 설정하여 제공(응답)한다. 제공받은 cookie는 클라이언트의 사용자PC(로컬 하드)에 저장된다. A FEW TIMES LATER.... 나중에 클라이언트가 재접속시 사용자PC(로컬 하드)에 있던 Set-cookie값을 서버측으로 전송한다. 서버측에서는 쿠키로 사용자를 인식하고 서비스 로직에 따라 클라이언트의 cookie값을 update 하게 된다. *새로운 페이지에 접근하기전에는 클라이언트에게 쿠키가 없습니다. *서버는 쿠키를 보낼때 이 쿠키를 사용할 Domain과 Path정보까지 함께 브라우저로 전송합니다. 즉, Domain과 Path는 쿠키를 어느 도메인의 어느 패스에서 인증하는데 사용할지 브라우저에게 알려주고 브라우저는 Domain과 Path가 일치할 때만 쿠키를 서버로 전송해서 사용자를 인증 받습니다. 일단 그렇게 알고 봅시다ㅎㅎ. ​ 근데 쿠키에는 “세션 식별자(session identifier) 정보”가 담겨 있다고 했는데 쿠키는 어떻게 구성되어 있을까요? 또 어떻게 접근해서 정보를 보는 걸까요? 알아봅시다! ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:0:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 문법 // 쿠키는 \"이름=값\" 페어로 시작됩니다. Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Expires=\u003cdate\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Max-Age=\u003cnon-zero-digit\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Domain=\u003cdomain-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Path=\u003cpath-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Secure Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; HttpOnly Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; SameSite=Strict Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; SameSite=Lax // Multiple directives are also possible, for example: Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Domain=\u003cdomain-value\u003e; Secure; HttpOnly ​ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:1:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 읽기 document.cookie 프로퍼티를 이용하면 브라우저에서도 쿠키를 확인할 수 있습니다. // ex) alert( document.cookie ); // cookie1=value1; cookie2=value2;... // 모든 쿠키를 알림창으로 확인하겠다.는 명령어 // 어디든 사이트에 들어가서 개발자 도구창을 열고 console.log(document.cookie) 를 입력해 보세요! document.cookie는 name=value쌍으로 구성되어있고, 각 쌍은 ;로 구분합니다. (ex. document.cookie = “cookiename=value; path=/; expires=0; domain=.tistory.com”) 이때, 쌍 하나는 하나의 독립된 쿠키를 나타냅니다. 정규 표현식이나 배열 관련 함수를 함께 사용해 ;을 기준으로 document.cookie의 값을 분리하면 원하는 쿠키를 찾을 수 있습니다. ​ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:2:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 구성요소 쿠키는 다음의 요소들로 구성됩니다. name (쿠키의 이름) 필수 value (쿠키에 저장된 값) 필수 domain (쿠키를 발급해준 서버의 도메인(사이트) 주소) domain=site.com 쿠키에 접근 가능한 domain(도메인)을 지정합니다. 다만, 몇 가지 제약이 있어서 아무 도메인이나 지정할 수 없습니다. domain 옵션에 아무 값도 넣지 않았다면, 쿠키를 발급받은 사이트(도메인)에서만 쿠키에 접근할 수 있습니다. site.com에서 생성한 쿠키를 other.com에선 절대 전송받을 수 없습니다. 이 외에 까다로운 제약사항이 하나 더 있습니다. 서브 도메인(subdomain) (ex. forum.site.com)에서도 쿠키 정보를 얻을 수 없다는 점입니다. // ex) site.com에서 user가 colinder라는 쿠키를 설정함 document.cookie = \"user=colinder\" // site.com의 서브도메인인 forum.site.com에서 쿠키에 접근하려 함 alert(document.cookie); // 찾을 수 없음 이런 제약사항은 안정성을 높이기 위해 만들어졌습니다. 민감한 데이터가 저장된 쿠키는 관련 페이지에서만 볼 수 있도록 하기 위함입니다. 하지만, forum.site.com과 같은 서브 도메인에서 site.com에서 생성한 쿠키 정보를 얻을 방법이 있습니다. site.com에서 쿠키를 설정할 때 domain 옵션에 루트 도메인인 domain=site.com을 명시적으로 설정해 주면 됩니다. // site.com에서 // 서브 도메인(*.site.com) 어디서든 쿠키에 접속하게 설정할 수 있습니다. document.cookie = \"user=colinder; domain=site.com\" // 이렇게 설정하면 // forum.site.com와 같은 서브도메인에서도 쿠키 정보를 얻을 수 있습니다. alert(document.cookie); // user=colinder 쿠키를 확인할 수 있습니다. 하위 호환성 유지를 위해 (site.com 앞에 점을 붙인) domain=.site.com도 domain=site.com과 동일하게 작동합니다. 오래된 표기법이긴 하지만 구식 브라우저를 지원하려면 이 표기법을 사용하는 것이 좋습니다. 이렇게 domain 옵션값을 적절히 사용하면 서브 도메인에서도 쿠키에 접근할 수 있습니다. path (쿠키로 사용자를 인증받을 수 있는 경로 설정) path=/ 서버 이름 뒤에 오는 경로(ex. site.com**/login**, site.com**/main** 등)에 따라 쿠키 사용여부가 결정됩니다. 위와 같이 슬래쉬( / )로 설정하면 모든 path에서 쿠키를 사용할 수 있습니다. (미 지정시) 기본값은 현재 경로입니다. path=/admin 옵션을 사용하여 설정한 쿠키는 /admin과 /admin/something에선 볼 수 있지만, /home 이나 /adminpage에선 볼 수 없습니다. 특별한 경우가 아니라면, path 옵션을 path=/같이 루트로 설정해 웹사이트의 모든 페이지에서 쿠키에 접근할 수 있도록 합니다. expires (쿠키의 만료시간) 쿠키가 언제 삭제되는지 결정합니다. 쿠키는 지속 쿠키(Persistent Cookie)와 세션 쿠키(Session Cookie)로 나눌 수 있습니다. 지속 쿠키(Persistent Cookie) 만료 날짜/시간(expires 나 max-age )을 지정하지 않은 쿠키 파일로 저장되므로 브라우저가 종료되어도 쿠키는 남아있습니다. 세션 쿠키(Session Cookie) 만료 날짜/시간(expires 나 max-age )을 지정한 쿠키 브라우저 메모리에 저장되므로 브라우저가 종료되면 쿠키는 사라지게 됩니다. expires와 max-age expires ex) expires=Tue, 19 Jan 2038 03:14:07 GMT 브라우저는 설정된 유효 일자까지 쿠키를 유지하다가, 해당 일자가 도달하면 쿠키를 자동으로 삭제합니다. (옵션값을 과거로 지정하면 쿠키는 삭제됩니다.) 쿠키의 유효 일자는 반드시 GMT(Greenwich Mean Time) 포맷으로 설정해야 합니다. date.toUTCString을 사용하면 해당 포맷으로 쉽게 변경할 수 있습니다. 아래는 유효 기간이 하루인 쿠키를 만드는 예시입니다. // 지금으로부터 하루 후 let date = new Date(Date.now() + 86400e3); date = date.toUTCString(); document.cookie = \"user=colinder; expires=\" + date; max-age ex) max-age=3600 max-age는 expires 옵션의 대안으로, 쿠키 만료 기간을 설정할 수 있게 해줍니다. 현재부터 설정하고자 하는 만료일시까지의 시간을 초로 환산한 값을 설정합니다. (0이나 음수값을 설정하면 쿠키는 바로 삭제됩니다.) // 1시간 뒤에 쿠키가 삭제됩니다. document.cookie = \"user=colinder; max-age=3600\"; // 만료 기간을 0으로 지정하여 쿠키를 바로 삭제함 document.cookie = \"user=colinder; max-age=0\"; 다른 브라우저들은 둘 다(Expires 와 Max-Age) 지정되었을 때 Max-Age 값을 더 우선시합니다. secure (쿠키 보안 설정) 이 옵션을 설정하면 HTTPS로 통신하는 경우에만 쿠키가 전송됩니다. secure 옵션이 설정된 경우, https://site.com에서 설정한 쿠키는 http://site.com에서 접근할 수 없습니다. 쿠키에 민감한 내용이 저장되어 있어 암호화되지 않은 HTTP 연결을 통해 전달되는 걸 원치 않는다면 이 옵션을 사용하면 됩니다. secure 옵션을 설정하지 않으면 http://site.com에서 설정(생성)한 쿠키를 https://site.com에서 읽을 수 있고, https://site.com**에서 설정(생성)한 쿠키도 **http://site.com에서 읽을 수 있습니다. 쿠키는 기본적으로 도메인만 확인하지 프로토콜을 따지진 않기 때문입니다. // (https:// 로 통신하고 있다고 가정 중) // 설정한 쿠키는 HTTPS 통신시에만 접근할 수 있음 document.cookie = \"user=John; secure\"; samesite (쿠키 보안 설정) 또 다른 보안 속성인 samesite 옵션은 크로스 사이트 요청 위조(cross-site request forgery, XSRF)공격을 막기 위해 만들어진 옵션입니다. 이 옵션엔 두 가지 값을 설정할 수 있습니다. samesite=strict(값을 설정하지 않고 그냥 samesite 옵션만 써줘도 동일하게 동작함) 사용자가 사이트 외부에서 요청을 보낼 때, samesite=strict 옵션이 있는 쿠키는 절대로 전송되지 않습니다. 메일에 있는 링크를 따라 접속하거나 evil.com과 같은 사이트에서 폼을 전송하는 경우 등과 같이 제3의 도메인에서 요청이 이뤄질 땐 쿠키가 전송되지 않죠. 인증 쿠키에 samesite 옵션이 있는 경우, XSRF 공격은 절대로 성공하지 못합니다. evil.com에서 전송하는 요청엔 쿠키가 없을 것이고, bank.com은 미인식 사용자에게 지급을 허용하지 않을 것이기 때문입니다. 이 보호장치는 꽤 믿을 만합니다. bank.com에서 수행하는 모든 작업은 samesite 쿠키를 함께 전송하기 때문이죠. 하지만 약간의 불편함도 감수해야 합니다. 만약 사용자가 메모장 등에 bank.com에 요청을 보낼 수 있는 링크를 기록해 놓았다가 이 링크를 클릭해 접속하면 bank.com이 사용자를 인식하지 못하는 상황이 발생하기 때문입니다. 실제로 이런 경우 samesite=strict 옵션이 설정된 쿠키는 전송되지 않습니다. 이런 문제는 쿠키 두 개를 함께 사용해 해결할 수 있습니다. “Hello, John\"과 같은 환영 메시지를 출력해주는 “일반 인증(general recognition)“용 쿠키, 데이터 교환 시 사용하는 samesite=strict 옵션이 있는 쿠키를 따로 둬서 말이죠. 이렇게 하면 외부 사이트를 통해 접","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:3:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"참고 했던 글 https://thoughtbot.com/blog/lucky-cookies https://www.joinc.co.kr/w/man/12/cookie https://ko.javascript.info/cookie#ref-201 https://ko.javascript.info/cookie https://genesis8.tistory.com/220 https://medium.com/@ddinggu/cookie%EB%9E%80-a650c6d2803e https://jeong-pro.tistory.com/80 https://im-first-rate.tistory.com/33 https://noritersand.github.io/javascript/javascript-document-cookie-%EC%BF%A0%ED%82%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4/ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:4:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["Vue"],"content":"​ Vue_LifeCycle 솔직히 처음 라이프사이클이란 것을 공부했을 때는 이게 무슨 말인지? 삶의 주기를 왜 알아야 하는지 전혀 몰랐습니다. 이런 저에게 Vue 공식문서에는 말했습니다. 지금 당장 모든 것을 완전히 이해할 필요는 없지만 다이어그램은 앞으로 도움이 될 것입니다. 그리고, LifeCycle을 공부 하기 전 DOM에 대한 개념이 부족하다면 what is DOM?을 꼭 보고 오길 추천합니다. ​ Vue.js의 라이프 사이클은 크게 Creation, Mounting, Updating, Destruction으로 나눌 수 있습니다. 이는 생성(create)되고, DOM에 부착(mount)되고, 업데이트(update)되며, 없어지는(destroy) 4가지 과정을 말합니다. 각각의 단계에서, Vue를 사용하는 사람들을 위해 훅(Hook)을 할 수 있도록 API를 제공합니다. 일반적으로 많이 사용하는 종류로는 beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed가 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:0:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"1. Creation (컴포넌트 초기화 단계) Creation 단계에서 실행되는 훅(hook)들이 라이프사이클 중에서 가장 처음 실행됩니다. 이 단계는 컴포넌트가 DOM에 추가되기 전이기 때문에 DOM에 접근하거나 this.$el를 사용할 수 없고, 서버 사이드 렌더링(SSR)에서는 지원되는 훅입니다. 따라서 클라이언트 단과 서버단 렌더링, 모두에서 처리해야할 일이 있다면 이 단계에서 하면됩니다. Creation단계에서 호출되는 라이프 사이클 훅은 [beforeCreate]과 [created]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:1:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeCreate() 이름처럼 가장 먼저 실행되는 beforeCreate훅입니다. Vue 인스턴스가 초기화 된 직후에 발생됩니다. 컴포넌트가 DOM에 추가되기도 전이어서 this.$el에 접근할 수 없습니다. 또한 data, methods, watch, computed, events(vm.$on, vm.$once, vm.$off, vm.$emit)등이 설정되기 전이라 접근할 수 없습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:2:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"created() data를 반응형으로 추적할 수 있게 되며 , methods, watch, computed, events등이 활성화되어 접근이 가능하게 됩니다. 하지만 아직까지 DOM에는 추가되지 않은 상태입니다. 하여 this.$el에는 접근할 수 없습니다. 컴포넌트 초기에 외부에서 받아온 값들로 data를 세팅해야 하거나 이벤트 리스너를 선언해야 한다면 이 단계에서 하는 것이 가장 적절합니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:3:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"2. Mounting (DOM 삽입 단계) Mounting단계는 초기 렌더링 직전에 컴포넌트에 직접 접근할 수 있습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) 초기 랜더링 직전에 돔을 변경하고자 한다면 이 단계를 활용할 수 있습니다. 그러나 컴포넌트 초기에 세팅되어야할 데이터 fetch는 created() 단계에 주로 사용하게 될 겁니다! Mounting단계에서 호출되는 라이프 사이클 훅은 [beforeMount]과 [mount]가 있습니다. *fetch: api를 불러오고, 정보를 내보내 주기도 하는 함수 ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:4:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeMount() DOM에 부착하기 직전에 호출되는 beforeMount훅입니다. 가상 DOM은 생성되어 있으나 실제 DOM에 부착되지는 않은 상태입니다. 하여 아직도 this.$el에는 접근할 수 없습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:5:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"mount() 드디어! mounted 훅에서는 컴포넌트, 템플릿, 렌더링된 DOM에 접근할 수 있습니다. this.$el을 비롯한 data, computed, methods, watch 등 모든 요소에 접근이 가능합니다. 하지만 모든 하위 컴포넌트가 마운트된 상태를 보장하지는 않습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) mount에는 약간의 이슈가 있습니다. 위의 설명에 “하지만 모든 하위 component가 mount된 상태를 보장하지는 않고” == 여러 component가 중첩되어 사용되는 경우 부모, 자식 component의 로딩에 순서가 있기 때문입니다. 순서: 부모 created =\u003e 자식 created =\u003e 자식 mounted =\u003e 부모 mounted *이때는 this.$nextTick을 이용한다면, 모든 화면이 렌더링 된 이후에 실행되므로 마운트 상태를 보장할 수 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:6:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"3. Updating (Diff 및 재 렌더링 단계) 컴포넌트에서 사용되는 반응형 속성들이 변경되거나 어떤 이유로 재 렌더링이 발생되면 실행됩니다. 디버깅이나 프로파일링 등을 위해 컴포넌트 재 렌더링 시점을 알고 싶을때 사용하면 되죠. 조심스럽지만, 꽤 유용하게 활용될 수 있는 훅입니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) Updating단계에서 호출되는 라이프 사이클 훅은 [beforeUpdate]과 [updated]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:7:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeUpdate() 이 훅은 컴포넌트의 데이터가 변하여 업데이트 사이클이 시작될 때 실행됩니다. 정확히는 DOM이 재 렌더링되고 패치되기 직전에 실행됩니다. 컴포넌트 초기에 data가 세팅되어야 한다면 created 훅을, 렌더링 되고 DOM을 변경해야 한다면 mounted 훅을 사용하면 되기 때문에, 거의 사용하지 않는 라이프 사이클 훅입니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:8:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"updated() 이 훅은 DOM이 재 렌더링 된 후 호출되는 라이프 사이클 훅입니다. DOM이 업데이트 완료된 상태이므로 DOM의 종속적인 연산을 할 수 있습니다. 예를 들어 변경된 data가 DOM에도 적용된 후에 호출되는 훅입니다. (updated훅에서 data를 수정하게 되면 update훅이 호출 되기 때문에 무한 루프에 빠질 수 있으니 되도록이면 안쓰는 것이 좋습니다…) 또 위의 mounted와 비슷한 이유로 모든 자식 컴포넌트의 재 렌더링 상태를 보장하지는 않으며, this.$nextTick()을 이용해, 모든 화면이 업데이트 된 이후의 상태를 보장할 수 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:9:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"4. Destruction (해체 단계) 컴포넌트가 제거 될 때 실행되는 라이프 사이클 훅입니다. (서버 사이드 렌더링(SSR)시에도 호출되지 않습니다.) Destruction단계에서 호출되는 라이프 사이클 훅은 [beforeDestroy]과 [destroyed]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:10:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeDestroy() 컴포넌트가 제거 되기 직전에 호출되는 라이프 사이클 훅입니다. 이 훅에서 컴포넌트는 본래의 기능들을 가지고 있는 온전한 상태이기 때문에 모든 속성에 접근이 가능합니다. 하여 이 훅에서 이벤트 리스너를 해제하거나 컴포넌트에서 동작으로 할당 받은 자원들은 해제해야 할 때 사용하기 적합한 훅입니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:11:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"destroyed() 컴포넌트가 제거 된 후 호출되는 라이프 사이클 훅입니다. 컴포넌트의 모든 이벤트 리스너(@click, @change 등..)와 디렉티브(v-model, v-show 등..)의 바인딩이 해제 되고, 하위 컴포넌트도 모두 제거됩니다. ​ ​ 👀요약 LifeCycle을 모르고 개발한다는게 운 좋으면 되고 운 나쁘면 안되고, 하는 막무가내 개발과 비슷하다고 느꼈습니다. 간단하게라도 흐름을 숙지하면 많은 도움이 될 것이고, 아무리 바쁘더라도 created와 mouted 정도는 알고 개발하면 확실히 도움이 됩니다. ​ ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:12:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"참고 했던 글. https://vuejs.org/v2/api/#Options-Lifecycle-Hooks https://beomy.tistory.com/47 https://medium.com/witinweb/vue-js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-7780cdd97dd4 https://wormwlrm.github.io/2018/12/29/Understanding-Vue-Lifecycle-hooks.html https://junsday.tistory.com/44 ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:13:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Web"],"content":"​ Web을 공부하다보면 반드시 듣게 되는 단어. “DOM” 근데 이게 뭔지 감이 잘 안왔고 그래서 WIT블로그를 필사하며 공부한 내용을 추가해 정리했습니다. ​ DOM이란? DOM(Document Object Model)은 웹 페이지에 대한 인터페이스입니다. 기본적으로 페이지의 콘텐츠 및 구조, 그리고 스타일을 읽고 조작할 수 있도록 API를 제공합니다. 먼저 DOM을 이해하기 전에 웹 페이지가 어떻게 빌드 되는지 알아보면 이해하는데 도움이 됩니다. 하여 알아봅시다! *인터페이스(interface): 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다. 즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템. ​ ​ 웹 페이지는 어떻게 만들어질까? 웹 브라우저가 원본 HTML 문서를 읽어들인 후, 스타일을 입히고 대화형 페이지로 만들어 뷰 포트에 표시하기까지의 과정을 “CRP(Critical Rendering Path)”이라고 합니다. Understanding the Critical Rendering Path을 참고해보면 6단계로 웹 페이지가 생성되는 것을 알 수 있습니다. 하지만 어렵죠. 조금 더 간추려 보자면 이 단계들은 2개로 나누어 생각해볼 수 있습니다. 첫 번째 단계에서 브라우저는 읽어들인 문서를 파싱하여 어떤 내용을 페이지에 렌더링할지 확인하고 랜더트리를 생성합니다. 그리고 두 번째 단계에서 브라우저는 해당 렌더링을 수행합니다. *DOM(Document Object Model) – HTML 요소들의 구조화된 표현 *CSSOM(Cascading Style Sheets Object Model) – 요소들과 연관된 스타일 정보의 구조화된 표현 ​ ​ 설명과 그림을 보면 DOM은 웹페이지 생성에 첫번째로 수행되는 기능입니다. 그리고 HTML 요소들의 구조화된 표현 이죠. 그렇다면 HTML은 뭘까요? HTML(Hyper Text Markup Language)은 웹 페이지를 위한 언어로, 특정 영역이 어떤 성질을 갖는지 미리 정해진 규칙에 따라 구조화된 요소들로 이루어진 마크업 언어입니다. 마크업 언어는 태그(\u003c\u003e)를 이용하여 데이터 구조를 명명하는 언어이므로(ex. \u003cbody\u003e), 태그 안에 담기는 요소들에 따라 영역의 성질이 달라지게 되고 각 영역들이 모여 구조화된 문서를 만듭니다. 또한 HTML은 인간이 이해하고 구분할 수 있는 언어로 만들어져 있고, 기계는 이렇게 규약된 언어를 해석할 수 없기 때문에, 파싱이라는 작업을 거쳐 브라우저가 해석할 수 있는 언어와 구조로 변환하는 작업이 필요합니다. (각 브라우저마다 파서가 다르기 때문에 같은 HTML문서라도 다른 파싱 결과값을 가질 수 있다.) 즉, 브라우저에서 HTML을 가공?(parsing)하여 Object 객체로 다시 만들어 기계가 해석할 수 있는 모습으로 변형한 것을 DOM이라고 합니다. ​ ​ DOM은 어떻게 만들어지는 걸까? DOM은 HTML 요소들이 가공(구조화)된 표현입니다. 둘은 서로 비슷하지만, DOM이 갖고 있는 특징은 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용될 수 있다는 점입니다. DOM의 개체 구조는 노드 트리로 표현됩니다. 이 HTML 구조는 이와 같은 노드 트리의 DOM으로 구성됩니다. ​ ​ 그럼 DOM과 HTML은 같은건가? 답은 ‘아니다.’ 라고 말 할 수 있습니다. DOM은 HTML 문서로부터 생성되지만 항상 동일하지 않습니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:0","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"1. DOM은 HTML이 아닙니다. DOM은 HTML 문서로부터 생성되지만 항상 동일하지 않습니다. DOM이 원본 HTML 소스와 다를 수 있는 두 가지 케이스가 있습니다. 작성된 HTML 문서에 오류가 있을 때 DOM은 유효한 HTML 문서의 인터페이스입니다. DOM을 생성하는 동안, 브라우저는 유효하지 않은 HTML 코드를 올바르게 교정합니다. 위에 html코드에는 필수 요소인 \u003chead\u003e와 \u003cbody\u003e가 빠져 있습니다. 하지만 DOM에는 올바르게 교정되어 있는 모습을 볼 수 있습니다. ​ 자바스크립트에 의해 DOM이 수정될 때 DOM은 HTML 문서의 내용을 볼 수 있는 인터페이스 역할을 하는 동시에 동적 자원이 되어 수정될 수 있습니다. 예를 들어, 자바스크립트를 사용해 DOM에 새로운 노드를 추가할 수 있습니다. 이 코드는 DOM을 업데이트합니다. 하지만 HTML 문서의 내용을 변경하진 않습니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:1","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"2. DOM은 브라우저에서 보이는 것이 아닙니다. 위의 그림에서 보면 DOM은 아직 CSSOM(CSS)가 적용되지 않은 상태입니다. 렌더 트리는 오직 스크린에 그려지는 것으로 구성되어 있어 DOM과 다릅니다. 달리 말하면, 렌더링 되는 요소만이 관련 있기 때문에 시각적으로 보이지 않는 요소는 제외됩니다. 예를 들어, 아래 html코드에는 p태그가 display: none 스타일 속성을 가지고 있는 요소입니다. 렌더 트리에 해당하는 뷰 포트에 표시되는 내용은 \u003cp\u003e 요소를 포함하지 않습니다. DOM은 \u003cp\u003e 요소를 포함시킵니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:2","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"3. DOM은 개발도구에서 보이는 것이 아닙니다. 개발도구의 요소 검사기는 DOM과 가장 가까운 근사치를 제공합니다. 그러나 개발도구의 요소 검사기는 DOM에 없는 추가적인 정보를 포함합니다. 가장 좋은 예는 CSS의 가상 요소입니다. ::before 과 ::after 선택자를 사용하여 생성된 가상 요소는 CSSOM과 렌더 트리의 일부를 구성합니다. 하지만, 기술적으로 DOM의 일부는 아닙니다. DOM은 오직 원본 HTML 문서로부터 빌드 되고, 요소에 적용되는 스타일을 포함하지 않기 때문입니다. 가상 요소가 DOM의 일부가 아님에도 불구하고, 요소 검사기에서는 아래와 같이 확인됩니다. 이러한 이유로 가상 요소는 DOM의 일부가 아니기 때문에 자바스크립트에 의해 수정될 수 없습니다. ​ *해당 포스팅은 WIT블로그를 필사하며 공부한 내용을 기록해 놓은 것입니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:3","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"더 공부하기 ::before와 ::after는 가상요소입니다. https://green-webdesigner.tistory.com/20 ​ ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:1:0","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["web"],"content":"​ 동기(Synchronous)란? 어떤 작업을 실행했을 때, 그 작업이 끝나고 결과를 응답받은 뒤에 다음 함수를 실행하는 방식. 만약 응답값이 없다면, 무한정 기다려요. 즉, 응답을 받아야! 다음 실행이 되는 방식입니다. ex) A실행 👉 A의 결과값 return 확인 👉 B실행 ​ 비동기(Asynchronous)란? 어떤 작업을 실행한 후 결과값을 기다리지 않고, 바로 다음 함수를 실행합니다. ex) A실행 👉 B실행 👉 … ​ CallBack함수란? 비동기 처리결과로 반환되는 Callback함수 Callback함수는 특정함수에 매개변수로 전달된 함수를 의미합니다. ex) DB에서 데이터를 가져오라는 요청 👉 데이터가 오는 중인데 👉 출력해버리면 결과값이 나오지 않는다. But, Callback 함수로 처리결과를 받은 후에 출력을 하게 로직을 짜면 문제없이 출력된다. 상황에 따라 어떤 작업이 끝났다는 것을 사용자에게 알려주거나, 코드 내부에서 Callback함수를 받았을 경우에만 처리하는 로직등을 짜서 가시적인 개발에 도움이 됩니다. ​ ​ # 개인적으로 동기는 '순차'라는 단어로 변환해 생각하면서 이해했습니다. 동기적 👉 '순차'적 👉 지정된 순서대로 시작 비동기적 👉 비'순차'적 👉 순서에 상관없이 시작 ","date":"2020-10-11","objectID":"https://colinder.github.io/sync_async_callback/:0:0","tags":["vue","web"],"title":"동기 \u0026 비동기 \u0026 CallBack함수","uri":"https://colinder.github.io/sync_async_callback/"},{"categories":["git"],"content":"​ Fork fork는 다른 사람(프로젝트)의 github repository에서 내가 어떤 부분을 수정하거나, 기능을 추가 하고 싶을 때 해당 repository를 그대로 복제하는 기능. fork한 저장소는 원본 repository와 연결되어 있습니다. 여기서 연결되어 있다는 의미는, 원본 repository에 어떤 변화가 생기면 이는 forked된 나의 repository에도 반영될 수 있다는 것입니다. (단, fetch나 rebase의 과정이 필요합니다. fetch나 rebase를 하지 않았다면, 단순히 원본 repository를 복사해서 가져온 상태라고 할 수 있습니다.) fork는 보통 2가지 목적을 위해 사용합니다. 오픈소스 기여를 위해 기존 오픈 소스의 사본을 만들어서 새로운 버전을 만들어나가기 위해 (예를 들어 장고 오리지널이 망했는데 누군가 이 프로젝트를 fork해서 새로운 버전으로 이어나가는 거죠) *fetch: Git에서 어떤 브랜치의 코드를 받아오는 방법 중 하나. (또 다른 하나는 pull) *rebase: Git에서 한 브랜치에서 다른 브랜치로 합치는 방법 중 하나. (또 다른 하나는 merge) ​ 🤔만약? 내가 손본(개발한) 내용을 push 하면 나의 repository에만 변경사항이 저장되고 원본 repository에는 영향을 주지 못합니다. 다만, 원본 repository에도 나의 변경사항을 반영하고 싶다면, 원본 repository에 pull request를 보내고 원본 repository 관리자가 수락하면 원본 repository에도 반영이 됩니다. == 타인 코드에 기여한다. ​ Clone clone은 특정 repository를 내 local machine(ex. 내 노트북)에 복사하여 새로운 저장소를 만드는 기능. clone하면 서버에 있는 프로젝트 히스토리를 포함한 거의 모든 데이터를 복사합니다. (거의 모든이라고 기록한 이유는 세부 명령어에 따라 clone되는 내용이 달라지기 때문입니다.) 또한 clone한 원본 repository의 remote가 origin으로 자동 설정됩니다. 만약 권한이 없다면 original repository의 로그를 보지 못하며, 해당 저장소로 push 하지도 못합니다. ​ 하지만! 로그까지도 모두 clone하는 등의 몇 가지 명령어가 존재합니다. 그중 많이 쓰이는 bare와 mirror에 대하여 정리해봤습니다. –bare 공식문서의 설명은 아래와 같음. Make a bare Git repository. That is, instead of creating \u003cdirectory\u003e and placing the administrative files in \u003cdirectory\u003e/.git, make the \u003cdirectory\u003e itself the $GIT_DIR. This obviously implies the --no-checkout because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/. When this option is used, neither remote-tracking branches nor the related configuration variables are created. 간단히 bare옵션은 HEAD의 refs 정보가 clone됩니다. *HEAD: 현재 작업중인 브랜치 *refs: 알아보기 쉬운 이름으로 설정된 commit 이름을 “References” 또는 “Refs” 라고 부른다. ​ –mirror 공식문서의 설명은 아래와 같음. Set up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository. 간단히 mirror옵션은 모든 브랜치의 refs 정보가 clone됩니다. ​ ​ ​ ✨Point # fork와 clone의 차이 원본 저장소와 연결이 되어 있냐(fork) 아니냐(clone)? ​ *Push Option –mirror Instead of naming each ref to push, specifies that all refs under refs/ (which includes but is not limited to refs/heads/, refs/remotes/, and refs/tags/) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option remote.\u003cremote\u003e.mirror is set. ​ ​ Special Thanks to Eric✨. ","date":"2020-10-11","objectID":"https://colinder.github.io/git_fork_vs_clone/:0:0","tags":["git","fork","clone"],"title":"Git_fork vs clone","uri":"https://colinder.github.io/git_fork_vs_clone/"},{"categories":["Web"],"content":"​ AJAX 세상에는 다양한 web서버가 있다. 그리고 모든 web은 “요청”과 “응답”으로 통신한다. 예를 들어.. 요청: “이미지를 보여줘” 응답: “오키” or “싫어” 그렇다면, 이 web서버들과 통신 하려면 어떻게 해야 할까? 대표적인 통신 방법을 AJAX라 한다. 이는 JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자며, 자체가 하나의 특정한 기술을 말하는 것이 아니며, 함께 사용하는 기술의 묶음을 지칭하는 용어이다. 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법 이며 Ajax를 한마디로 정의하자면 JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이라고 할 수 있겠습니다. ​ ​ Ajax 중 하나인 axios에 대하여 정리한다. axios 구형 브라우저를 지원한다. 응답 시간 초과를 설정하는 방법이 있다. JSON 데이터 자동변환이 가능하다. node.js에서의 사용이 가능하다. request aborting(요청 취소)가 가능하다. catch에 걸렸을 때, .then을 실행하지 않고, console창에 해당 에러 로그를 보여준다. return값은 Promise 객체 형태이다. ​ ","date":"2020-10-11","objectID":"https://colinder.github.io/what_is_ajaxaxios_00/:0:0","tags":["Vue","Web","AJAX","axios"],"title":"what is AJAX(axios)?","uri":"https://colinder.github.io/what_is_ajaxaxios_00/"},{"categories":["Web"],"content":"🙋‍♂️사용법 (vue기준) # Terminal에 npm install axios 👈 axios 설치 # main.js import Vue from 'vue' import App from './App.vue' import axios from \"axios\" 👈 추가 Vue.config.productionTip = false Vue.prototype.$axios = axios 👈 추가 new Vue({ render: h =\u003e h(App), }).$mount('#app') # axios를 모든 components에서 사용가능하게 등록한 것 == '전역으로 설정' ​ ","date":"2020-10-11","objectID":"https://colinder.github.io/what_is_ajaxaxios_00/:1:0","tags":["Vue","Web","AJAX","axios"],"title":"what is AJAX(axios)?","uri":"https://colinder.github.io/what_is_ajaxaxios_00/"},{"categories":["Web"],"content":"Example jsonplaceholder라는 json형태의 가상테이터 요청 사이트를 이용해 테스트를 진행 솔직히 여기 site의 Guide만보고 따라해도 AJAX를 맛볼 수 있다. (혹시 몰라 설명하자면, Guide의 “fetch\"를 “axios\"로 바꾸어 사용해보면 된다. ) // 새로 프로젝트를 만들고 npm install axios 설치하고, main.js에서 전역설정해준 뒤 진행. // test해볼 conponents인 HelloWorld.vue의 내용을 수정해서 진행. // HelloWorld.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003eaxios 테스트\u003c/h1\u003e 👈 \u003cbutton @click=\"axiosTest()\"\u003eaxios 테스트\u003c/button\u003e 👈 \u003cp\u003e{{this.posts}}\u003c/p\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name : 'HelloWorld', data() { 👈 return { 👈 posts: '' 👈 } 👈 }, 👈 methods: { 👈 axiosTest() { 👈 const baseURI = 'https://jsonplaceholder.typicode.com' 👈 this.$axios.get(`${baseURI}/posts`) 👈 .then((res) =\u003e { 👈 alert('1차 요청 완료') 👈 this.posts = res.data 👈 }) 👈 } 👈 }, 👈 } \u003c/script\u003e // 살짝 JSONPlaceholder의 공식 Guide를 따르진 않는다. 서버실행화면 =\u003e 버튼클릭 후 결과화면 (요청이 잘 받아진 화면을 확인할 수 있다.) ​ 보기 좋게 parsing해보자. // HelloWorld.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003eaxios 테스트\u003c/h1\u003e \u003cbutton @click=\"axiosTest()\"\u003eaxios 테스트\u003c/button\u003e \u003cp v-for=\"(post, i) in posts\" :key=\"i\"\u003e{{post}}\u003c/p\u003e 👈 수정 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name : 'HelloWorld', data() { return { posts: '' } }, methods: { axiosTest() { const baseURI = 'https://jsonplaceholder.typicode.com'; this.$axios.get(`${baseURI}/posts`) .then((res) =\u003e { alert('1차 요청 완료') this.posts = res.data }) } }, } \u003c/script\u003e 서버실행화면 =\u003e 버튼클릭 후 결과화면 ​ ​ 하지만, 여기서 의문이 생긴다. 비동기 요청인 axios를 동기적으로 처리 할 순 없을까? ","date":"2020-10-11","objectID":"https://colinder.github.io/what_is_ajaxaxios_00/:2:0","tags":["Vue","Web","AJAX","axios"],"title":"what is AJAX(axios)?","uri":"https://colinder.github.io/what_is_ajaxaxios_00/"},{"categories":["git"],"content":"​ Git_Mirroring 기존에 사용하고 있던 A_Repo에서 B_Repo로 커밋히스토리 그대로 복사가 필요할 때가 있습니다. 여기서 A_Repo를 그대로 가져온다는 의미는 단지 파일을 새롭게 만드는 것이 아니라 A_Repo에서 작업하던 commit 이력 모두를 그대로 이전하는 의미를 뜻합니다. ​ 터미널을 엽니다. 복사하고자 하는 저장소(A_Repo)의 bare clone을 생성합니다. git clone --bare https://github.com/user/old-repository.git 새로운 저장소(B_Repo)를 만들고 mirror-push를 진행합니다. cd old-repository.git 👈 위에서 클론(bare)한 폴더로 이동 git push --mirror https://github.com/user/new-repository.git 2번 과정에서 클론된 저장소를 지웁니다.(선택사항) ​ 대부분의 경우 위의 방법으로 미러링이 가능하지만, github 정책상 크기가 100MB를 넘어가는 파일이 단 한번이라도 commit되었다면, 오류가 발생하는 이슈가 있을 수도 있음. ​ ","date":"2020-10-08","objectID":"https://colinder.github.io/git_mirroring/:0:0","tags":["git","Mirroring"],"title":"Git_Mirroring","uri":"https://colinder.github.io/git_mirroring/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D3_3975_승률 비교하기 result = [] for T in range(int(input())): A, B, C, D = map(int, input().split()) if B/A \u003e D/C: result.append(\"BOB\") elif B/A \u003c D/C: result.append(\"ALICE\") else: result.append(\"DRAW\") for t in range(T+1): print(f\"#{t+1} {result[t]}\") # 아니 이게 D3라고? 완전 난이도 설정 실수네. 했다가 런타임 오류 보고 # 왜 그런건지 알았다. # python은 결과를 모았다가 출력하는 게 더 빠르다. ​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D2_5176_이진탐색 def makeTree(n): global count #Tree 범위 제한 if n \u003c= N: #1부터 시작한다고 가정했을 때 왼쪽노드는 현재 인덱스의 2배 makeTree(n*2) #더이상 못가면 값넣기 tree[n] = count #값 넣었으면 증가시키기 count += 1 #우측 노드는 인덱스 2배 + 1 makeTree(n*2 + 1) for T in range(int(input())): N = int(input()) tree = [0 for i in range(N+1)] count = 1 makeTree(1) print(f'#{T+1} {tree[1]} {tree[N//2]}') # 2020하반기 네이버 코테를 풀고 tree에 대하여 깊이있게 공부해봐야겠다고 생각하며 # 다시 처음부터 공부하는데, 미쳤다.ㅎ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["web"],"content":"​ REST API Reference [TOC] ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:0:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.사용자 API Members Descriptions POST /accounts/signup 회원가입 POST /accounts/login 회원 로그인 POST /accounts/userDetail 회원정보 PUT /accounts/update 회원정보 수정 DELETE /accounts/dropUser 회원탈퇴 GET /accounts/emailAuth 이메일 인증 GET /accounts/emailCheck 이메일 중복 확인 GET /accounts/nicknameCheck 닉네임 중복 확인 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.1 회원 로그인 POST /accounts/login ​ 회원 로그인 API 입니다. ​ Request parameters Parameter Type Description email String 이메일 password String 비밀번호 ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.2 회원가입 POST /accounts/signup ​ 회원가입 API 입니다. ​ Request parameters Field Type Description password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail 1.2.1 이메일 중복확인 GET /accounts/emailCheck 회원가입시 이메일 중복확인하는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description result.data String 아이디사용가능 ​ Response (Fail) Field Type Description result.data String 아이디중복 1.2.2닉네임 중복확인 GET /accounts/nicknameCheck 회원가입시 닉네임중복확인하는 API 입니다. ​ Request parameters Field Type Description nickname String 닉네임 ​ Response(Success) Field Type Description result.data String 닉네임사용가능 ​ Response (Fail) Field Type Description result.data String 닉네임중복 1.2.3이메일 인증 GET /accounts/emailAuth 이메일 중복 확인시 이메일을 인증메일을 보내는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description dice int 이메일 인증 코드 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.3 회원 정보 수정 PUT /accounts/update 회원정보 수정 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 nickname String 닉네임 content String 자기소개 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.4 회원 정보 POST /accounts/userDetail 회원정보를 조회하는 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.5 회원탈퇴 DELETE /accounts/dropUser 회원 탈퇴 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:5","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.게시물 API Members Descriptions POST /articles/register 글 작성 GET /articles/showArticle 글 상세 조회 PUT /articles/modify 글 수정 DELETE /articles/dropArticle 글 삭제 POST /articles/like 글 좋아요 POST /articles/likedList 좋아요 게시물 리스트 GET /articles/searchArticle 글 검색 POST /articles/getRecommentList 음식점 추천 리스트 GET/articles/list 전체 글 리스트 POST /articles/postedList 사용자가 작성한 글 리스트 GET/articles/postedListByLikes 좋아요순 글 리스트 GET/articles/postedListByHits 조회순 글 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.1 글 작성 POST /articles/registe 글 작성 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.2 글 상세 조회 GET /articles/showArticle 글 상세조회하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String 조회 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.3 글 수정 PUT /articles/modify 글 수정하는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.4 글 삭제 DELETE /articles/dropArticle 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 삭제 성공 ​ Response (Fail) Field Type Description result.data String 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.5 글 좋아요 POST /articles/like 글 좋아요 올리거나 내리는 API 입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:5","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.6 좋아요 게시물 리스트 POST /articles/likedList 좋아요 누른 게시물을 리턴해주는 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data List Post객체의 리스트 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:6","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.7 글 검색 GET /articles/searchArticle 글 검색 API 입니다. ​ Request parameters Field Type Description keyword(path) String 검색어 ​ Response(Success) Field Type Description result.data HashMap 해쉬맵으로 검색결과를 리턴 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:7","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.8 음식점 추천 리스트 POST /articles/getRecommentList 음식점 추천 API입니다. ​ Request parameters Field Type Description food String 관련 태그를 ,로 연결하여 보내기 isCafe String 카페도 추천하면 추가 isDrink String 술집도 추천하면 추가 like String 피드백에서 좋아요수가 부족할때 watch String 피드백에서 조회수가 부족할때 star String 피드백에서 별점이 부족할때 ​ Response(Success) Field Type Description 음식 Post 추천하는 음식점 카페 Post 추천하는 카페 술집 Post 추천하느 술집 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:8","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.9 전체 글 리스트 GET /articles/list 전체 글을 받는 API입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:9","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.10 사용자가 작성한 글 리스트 POST /articles/postedList 사용자가 작성한 글의 리스트를 리턴해주는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result List 전체 글의 리스트 ​ Response (Fail) Field Type Description result null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:10","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.11좋아요순 글 리스트 GET /articles/postedListByLikes 좋아요 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:11","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.12 조회순 글 리스트 GET /articles/postedListByHits 조회 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:12","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.13 좋아요순 글 리스트 GET /articles/postedListByStarpoint 별점순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:13","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.글 임시저장 API Members Descriptions POST /subarticles/register 임시 글 작성 GET /subarticles/detail/{postid} 임시저장 글 상세 조회 GET /subarticles/list/{userid} 유저별 임시 글 리스트 DELETE /subarticles/dropSubarticle 임시 글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.1 임시 글 작성 POST /subarticles/register 임시 글 작성 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.2 임시저장 글 상세 조회 GET /subarticles/detail/{postid} 임시 글 상세조회 API입니다. ​ Request parameters Field Type Description postid int DB에서 관리하는 post id ​ Response(Success) Field Type Description result Post 유저별 임시저장 글 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.3 유저별 임시 글 리스트 GET /subarticles/list/{userid} 유저별 임시 글 리스트 API입니다. ​ Request parameters Field Type Description userid int DB에서 관리하는 user id ​ Response(Success) Field Type Description result List 유저별 임시저장 글의 리스트 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.4 임시 글 삭제 DELETE /subarticles/dropSubarticle 임시 글 삭제 API입니다. 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 임시저장 글 삭제 성공 ​ Response (Fail) Field Type Description result.data String 임시저장 글 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.댓글 API Members Descriptions GET /comments/list/{postid} 해당글의 댓글 전체 리스트 POST /comments/register 댓글 작성 PUT /comments/modify 댓글 수정 DELETE /comments/dropComment 댓글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.1 해당 글의 전체 댓글 GET /comments/list/{postid} 해당 글의 전체 댓글을 받아오는 API입니다. ​ Request parameters Field Type Description postid(path) int 해당 글 id ​ Response(Success) Field Type Description result.data List Comment객체의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.2 댓글 작성 POST /comments/register 댓글 작성하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.3 댓글 수정 PUT /comments/modify 댓글 수정하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.4 댓글 삭제 DELETE /comments/dropComment 댓글 삭제하는 API입니다. ​ Request parameters Field Type Description commentId int 댓글의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3307_최장 증가 부분 수열(LIS) for T in range(int(input())): N = int(input()) arr = list(map(int, input().split())) dp= [1] * N for i in range(1, N): for j in range(i): if arr[j] \u003c arr[i]: dp[i]= max(dp[i], dp[j] + 1) print(f'#{T+1} {max(dp)}') # dp는 쉬운듯 어렵고 어려운듯 쉽다... # LIS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3304_최장 공통 부분 수열(LCS) for T in range(int(input())): A, B = input().split() dp = [[0 for i in range(len(A)+1)] for j in range(len(B)+1)] for i in range(1, len(B)+1): for j in range(1, len(A)+1): if B[i-1] == A[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) print(f'#{T+1} {dp[-1][-1]}') # 아니다. DP는 그냥 겁나 어렵다.. # 각각의 문자 위치를 숫자로 바꾸고 이를 2차원 배열로 만들어서 # 일치하는 문자가 나왔을 때의 숫자를 dp에 기록해서 진행하는데 # 난 A, B의 검사 순서를 B -\u003e A 로 해야 한다는 것을 아주 느리게 깨달았다. # LCS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 for T in range(int(input())): N = int(input()) days = [] for _ in range(N): days.append(int(input())-1) days = days[1:] dp = [1]*(N-1) count = 0 while any(dp): # 👈 dp가 모두 0일 때까지 while을 돌린다. i = dp.index(1) for j in range(i,N-1): if days[j] % days[i] == 0: dp[j] = 0 count += 1 print(f\"#{T+1} {count}\") # 2주기로 정박하는 배가 있다고 할 때, 이 배는 2일 4일 8일 12일에 정박할 수 있다. # 중간에 비어있는 일자가 있더라도 1배가 정박한 것으로 본다. # any() 함수를 써봤는데 좋았다. 푸는데 2시간... 걸렸다...ㅎ. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_10726_이진수 표현 def check2(M): for i in range(N): if M % 2 != 1: return \"OFF\" else: M = M // 2 return \"ON\" for T in range(int(input())): N, M = map(int, input().split()) print(f'#{T+1} {check2(M)}') # 특정 조건에서 더 이상 검색할 필요가 없다면, def를 선언해 사용하는 것이 아주 유용하다. # 처음에는 bin함수를 사용해 slicing을 해서 뭐..뭐.. 어떻게 해보려 했지만 # run time error가 났다. 조금 생각해보니, 굳이 bin을 사용할 것도 없어보였고, # 간단하게 시도했더니 풀렸다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3131_100만 이하의 모든 소수 a = [0, 0] + [1] * 1000000 for i in range(2, 1000000): if a[i] == 1: for j in range(2*i, 1000001, i): a[j] = 0 for i in range(2, 1000000): if a[i] == 1: print(i, end=\" \") # 에라토스테네스의 체 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3233_정삼각형 분할 놀이 for T in range(int(input())): A, B = map(int, input().split()) result = 0 for i in range(int(A//B)): result += 2*(i+1) - 1 print(f'#{T+1} {result}') # A를 B의 길이로 나눈 정삼각형은 맨 위층 부터 2n-1개의 삼각형이 나온다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_1860_진기의 최고급 붕어빵 def check(): global bread for i in range(max(people)+1): if i == 0: pass else: if i % M == 0: bread += K if i in people: if bread \u003c= 0: return 'Impossible' else: bread -= 1 return 'Possible' for T in range(int(input())): N, M, K = map(int, input().split()) people = list(map(int, input().split())) bread = 0 print(f'#{T+1} {check()}') # 특정 조건인 경우 더 이상 확인할 필요가 없기 때문에 즉시 종료가 가능한 def 함수를 # 선언해서 구현했고, 조건중 0초일때 붕어빵 판매가 가능한지 생각 후 해결되었다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_4047_영준이의 카드 카운팅 for T in range(int(input())): counts = {'S': 13, 'D': 13, 'H': 13, 'C' : 13} arr = input() new_arr = [] for i in range(0, len(arr), 3): new_arr.append(arr[i:i+3]) if len(set(new_arr)) != len(new_arr): print(f\"#{T+1} ERROR\") else: for i in new_arr: counts[i[0]] -= 1 print(f\"#{T+1} \", end='') print(*counts.values()) # 엄청 좋은 문제라고 생각한다. 막 어렵진 않으나 다양한 스킬들을 사용해서 # 풀어볼 수 있는 좋은 문제라고 생각한다. # 1. set{}의 활용 / 2. for문 slicing / 3. print안에 end 활용 / 4. set자료 접근 등 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["block_chain"],"content":"​ 🧔프라이빗 블록체인 VS 👨🏻‍🤝‍👨🏻퍼블릭 블록체인 VS 🔒프라이빗 네트워크 VS 🔐퍼블릭 네트워크 Why 이런 질문을? 블록체인 관련 정보를 구글링하다보면, 프라이빗 네트워크, 퍼블릭 네트워크, 프라이빗 블록체인, 퍼블릭 블록체인. 이 4가지의 말을 혼용해서 사용하고 있는 것을 쉽게 볼 수 있다. 여기서 프라이빗 네트워크와 프라이빗 블록체인과 같이 네트워크와 블록체인을 같은 의미로 많이 사용하는데. 과연 이 둘이 같은 것을 의미하는지 알아보았다. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"결론 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:1","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 블록체인=\u003e 사용자의 접근조건을 기준으로 프라이빗과 퍼블릭을 나눔 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:2","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 네트워크=\u003e 서비스 운용형태를 기준으로 프라이빗과 퍼블릭을 나눔 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:3","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🧔프라이빗 블록체인 선택된 참여자만 블록체인에 접근이 가능하며, 선택된 참여자만 블록을 만들 수 있음. 특징 네트워크 구성할 때 인증과 검증 과정을 통해 선택적으로 참여자가 노드를 구성 네트워크를 구성하는 참가자인 노드가 되기 위해서는 운영 주체의 허가가 필요 참여자가 제한되기 때문에 빠른 거래나 처리속도가 필요한 경우와 네트워크 내에서만 정보가 공개되어야 하는 경우에 적합한 형태 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:1:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"👨🏻‍🤝‍👨🏻퍼블릭 블록체인 누구든 블록체인에 접근이 가능하며, 누구나 블록을 만들 수 있음. ex) 비트코인(1세대 블록체인), 이더리움(2세대 블록체인) 특징 모든 참여자에게 거래 내용이 공유 자유롭게 읽고 쓸 수 있지만, 정보를 위변조하는 것이 불가능 거래 처리 용량 제한으로 인한 확장성 부족이나 채굴에 들어가는 전력의 큰 비용 등 문제 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:2:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔒프라이빗 네트워크 운영자의 허가를 받은 인원만 거래 내용을 확인할 수 있음. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:3:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔐퍼블릭 네트워크 누구나 거래내역을 확인할 수 있음. ​ ex) 블록체인 자체에 모두가 접근할 수 있는가? -\u003e 퍼블릭 블록체인이다. 실제 운용하는 형태가 퍼블릭한가? -\u003e 퍼블릭 네트워크이다. 하이퍼렛저 패브릭은 블록체인 자체가 모두가 접근하도록 설계가 되어 있지 않네? -\u003e 프라이빗 블록체인 실제 운용도 프라이빗 하구나! -\u003e 프라이빗 네트워크 이더리움은 최초에 모두가 쓸 수 있게 만들어졌군 -\u003e 퍼블릭 블록체인이네 그렇지만 일단 우리 팀원들끼리만 써야지 -\u003e 프라이빗 네트워크 ​ 내용을 정리하면서 발생했던 의문들. 노드를 생성한다는 것은 어떤 의미인가? 노드? 네트워크를 구성하는 참가자 == 노드 블록을 생성해 네트워크를 구성한다. 한개의 노드만 있더라도 네트워크는 구성되었고, 노드끼리 연결되는 순간에 서로 다른 체인데이터를 가지고 있다면, 합의로직에 따라서 합의가 진행된 후 체인 데이터가 같아진다. 프라이빗 네트워크는 어떻게 구성하는가? 개념적으로는 잘못되었을 수 있지만, 단순히 회원가입시 노드를 만들고 지갑까지 생성해 해쉬(#)값을 추출해 DB에 저장하고, 이후 서비스 사용시 해쉬값이 일치하는 사용자에게만 특정 내용을 보여준다면 프라이빗한 네트워크로 서비스를 제공할 수 있겠다. 블록체인을 생성하는 것이랑 네트워크에 참여하는 것은 별개의 일이 아닌가? 위에 설명한 노드를 만들면 나의 첫 블록인 genesis.json 파일을 만들고 네트워크에 참여하게 된다. 네트워크에 참여 후 addpeer를 통해 네트워크 사용자를 확장해나간다. 즉, 별개의 일이다. ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:4:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 for T in range(int(input())): D, A, B = map(int, input().split()) D = str(D) arr = [0, 0] + [1] * (B - 1) # 에라토스테네스의 체를 활용할껀데 어떤 수까지 검증하면 될까? # 검증해보니 모든 수는 자신의 int(root)까지만 확인하면 배수값인지 확인이 가능했다. rootB = int(B**0.5) #👈 이 아이디어를 얻기까지 오랜시간이 걸렸다. for i in range(2, rootB+1): #👈 if arr[i] == 1: #👈 for j in range(2*i, B+1, i): #👈 에라토스테네스의 체 를 활용 arr[j] = 0 #👈 result = [] for i in range(A, B+1): if arr[i] == 1 and D in str(i): result.append(i) print(f'#{T+1} {len(result)}') ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_1493_수의 새로운 연산 new_number = [(0, 0)] count = 1 while count \u003c= 300: count += 1 for x in range(1, count): y = count - x new_number.append((x, y)) for T in range(int(input())): p, q = map(int, input().split()) x = new_number[p][0] + new_number[q][0] y = new_number[p][1] + new_number[q][1] result = new_number.index((x, y)) print(f'#{T+1} {result}') # 별다른 아이디어는 없었다. 그냥 인덱스별 좌표를 미리 만들어 두고 # 그걸 불러오는 방법을 생각했다. (런타임이 겁났지만, Pass 했다.) ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_10570_제곱 팰린드룸 수 for T in range(int(input())): N = [0]*1001 A, B = map(int, input().split()) for i in range(A, B+1): if str(i) == str(i)[::-1]: if i**0.5 % 1 == 0: if str(int(i**0.5)) == str(int(i**0.5))[::-1]: N[i] = 1 print(f'#{T+1} {N.count(1)}') #그냥 문제에 주어지는 대로 풀었다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_3032_홍준이의 숫자 놀이 def exeu(a, b): global x, y r = [a, b] s = [1, 0] t = [0, 1] while r[-1] != 0: q = int(r[-2] / r[-1]) r.append(r[-2] - q * r[-1]) s.append(s[-2] - q * s[-1]) t.append(t[-2] - q * t[-1]) x = s[-2] y = t[-2] for T in range(int(input())): A, B = map(int, input().split()) exeu(A, B) print(f'#{T+1} {x} {y}') # 확장된 유클리드 알고리즘을 공부하면 된다. # 근데 쉽지 않으니 시간을 가지고 봐야 한다. # 실은 난 아직 이해하지 못했다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_2817_부분 수열의 합 import itertools for T in range(int(input())): N, K = map(int, input().split()) # N: 갯수, K: 목표 합 Nums = list(map(int, input().split())) count = 0 for i in range(1, N+1): boxs = itertools.combinations(Nums, i) for box in boxs: if sum(box) == K: count += 1 print(count) # 하... 라이브러리 쓰자.. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1491_원재의 벽 꾸미기 for T in range(int(input())): N, A, B = map(int, input().split()) result = [] for R in range(1, N+1): for C in range(1, R+1): if R * C \u003e N: break elif R * C \u003c= N: result.append(A * abs(R-C) + B * (N - R*C)) print(f\"#{T+1} {min(result)}\") # A X lR – Cl + B X (N - R X C)에서 # A X lR – Cl =\u003e 양수, B X (N - R X C) =\u003e 양수 만 가능하다. # 또 직사각형 인테리어라고해서 R != C 라고 생각했으나,, # R = C인 경우도 넣어줘야 답이 나왔다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1229_암호문2 for T in range(10): N = int(input()) passwords = list(map(int, input().split())) order = int(input()) cmd = list(input().split()) for i in range(len(cmd)): if cmd[i] == 'I': for j in range(int(cmd[i+2])): passwords.insert(int(cmd[i+1])+j, int(cmd[i+3+j])) elif cmd[i] == 'D': for j in range(int(cmd[i+2])): passwords.pop(int(cmd[i+1])) print('#{}'.format(T+1), end=' ') print(*passwords[0:10]) # 조건 자체는 어렵지 않은데, 다뤄야하는 숫자들이 많아서 결과를 확인하기 어려웠다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_5515_2016년 요일 맞추기 days= [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366] day = 4 for T in range(int(input())): m, d = map(int, input().split()) if m != 1: add_month = days[m-2] elif m == 2: add_month = days[1] else: add_month = 0 result = (day + add_month + (d-1)) % 7 print(f'#{T+1} {result}') # 이건 그냥 했다. ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10505_소득 불균형 for T in range(int(input())): N = int(input()) dp = [0] * 100001 Max = 0 for i in list(map(int, input().split())): dp[i] += 1 Max += i print(f'#{T+1} {sum(dp[:int(Max/N)+1])}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10200_구독자 전쟁 for T in range(int(input())): N, A, B = map(int, input().split()) # 최소값 구하기 if A+B \u003e= N: Min = (A+B)-N if A \u003e= B: Max = B else: Max = A else: Min = 0 if A \u003e= B: Max = B else: Max = A print(f'#{T+1} {Max} {Min}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_3376_파도반 수열 for T in range(int(input())): Padovan = [1, 1, 1, 2] N = int(input()) for i in range(N-4): Padovan.append(Padovan[i+2]+Padovan[i+1]) print(f'#{T+1} {Padovan[N-1]}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_5642_합 T = int(input()) for T in range(T): N = int(input()) Nums = list(map(int, input().split())) result = 0 Sum = 0 flag = 0 for i in range(N): Sum = Sum + Nums[i] if Sum \u003c 0: Sum = 0 elif Sum \u003e result: result = Sum if Nums[i] \u003c 0: flag += 1 if flag == N: result = max(Nums) print(f'#{T+1} {result}') # 모두 음수인 경우를 생각해야 한다... 이거 생각하는데 40분 걸렸따... ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["block_chain"],"content":"​ 🎈가상환경에서 블록체인 채굴 및 기본 시스템 정리 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:0:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"1. geth(Go-ethereum) 설치 블록체인 기술은 중앙집중화된 데이터베이스에 반기를 들고 나온 개념이기 때문에 중앙 서버 이런게 없다. 즉 누구라도 해당 블록체인 네트워크에 참여하고 싶다면 언제라도 블록체인 데이터베이스를 싱크해주는 로컬 프로그램을 다운 받아 실행하면 데이터를 받을 수 있다. 그렇다면 블록체인 네트워크에 참여하고 싶다면 어떻게 해야 할까? 앞서 말한 로컬 프로그램을 다운 받으면 참여가 가능하다. 이 프로그램들 중 하나인 GO 로 짜여진 Go Ethereum(줄여서, geth)을 설치해본다. 작성당시 가장 최신 버전인 1.9.20 for windows로 다운을 받는다. 다운 받고 실행하면 경고창이 뜨는데 추가정보누르고 실행누르고 진행한다. devolop 뭐시기는 선택하지 않았고, next를 누루고 진행한다. 설치가 깔끔히 마무리 되지 않고 경고창이 떴는데, 환경변수 설정해주었다. 검색 → 시스템 환경 변수 편집 → 고급 → 환경 변수 → Path더블클릭 → 새로만들기 → C:\\Program Files\\Geth 추가 cmd 창을 열어(관리자: 명령 프롬프트) geth를 입력해 실행되는지 확인한다._______끝 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:1:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"2. Web3 설치 모든 자료와 정보가 분산화, 분권화된 차세대 네트워크 구조로서, 서버가 없는 혁신적인 인터넷 분산형 웹. web3.js는 JavaScript 기반으로 Dapp 이나 서비스를 구현할 때 매우 유용. (출처: 위키) ​ 이미 Vue_CLI 프로젝트를 구성해 놓은 것이 있어서 Terminal 에서 npm install web3 입력해서 web3를 설치한다. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:2:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"3. VirtualBox 설치 VirtualBox: 하드웨어를 소프트웨어적으로 구현해서 그 위에서 운영체제가 작동하도록하는 기술 Windows hosts 와 All supported platforms 두개를 다운 받는다. Windows hosts: 그냥 next연타하여 설치 All supported platforms을 더블클릭하여 설치를 진행하는데 👍전체 설치는 이 블로그의 설치 동영상을 참고하여 설치를 진행 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:3:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"4. Vagrant 설치 Vagrant는 가상머신을 편리하게 사용할 수 있도록 도와주는 프로그램입니다. 이미 누군가가 Vagrant로 설정해 놓은 가상머신 Box를 간단한 명령어로 손쉽게 설치 할 수 있으며 가상 머신과 호스트 머신과의 환경설정도 쉽게 할 수 있습니다. 다운로드는 여기서 진행. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:4:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"5. Remix IDE 설정 이더리움 스마트 컨트랙트 프레임워크 여기서 진행! ​ 🎈본격적인 블록체인 관련 가상환경 세팅 및 채굴 진행 20.09.01 한 일.. ⛏ 광산에서 일하는 것을 예시로! VirtualBox(🏞): 블록체인 생성 및 채굴을 위한 가상환경을 세팅 (내가 채굴할 산을 고르는 것) Vagrant(🏟): 가상환경에서 노드를 생성하는 등, 블록체인 관련 프레임워크 (광구를 생성하는 것) geth(📜👷‍♂️): 블록체인 노드의 관련 프로그램 (광구에 어떤 사람이 들어오고 어떤 사람을 파견할지 등등) ​ 블록체인 관련 작업을 할 디렉토리 생성 후 Terminal을 열어 vagrant 관련 명령어 실행(이미 설치는 완료) \u003e vagrant version #설치 여부 및 버전 확인 =\u003e 버전 넘버가 보이면 ok \u003e vagrant plugin install vagrant-scp # 호스트 \u0026 가상머신 간 연동 프로그램 설치 \u003e vagrant init # 블록체인 채굴을 위한 기초 세팅 시작 # 해당 명령어를 입력하면 작업하는 디렉토리에 Vagrantfile이 생긴다. vagrant init 후 생기는 Vagrantfile을 수정해 최초의 블록(genesis.json)을 생성해야 한다. # Vagrantfile =\u003e 내용을 수정한다. # -*- mode: ruby -*- # vi: set ft=ruby : # All Vagrant configuration is done below. The \"2\" in Vagrant.configure # configures the configuration version (we support older styles for # backwards compatibility). Please don't change it unless you know what # you're doing. VAGRANT_API_VERSION = \"2\" vms = { 'eth0' =\u003e \"10\", 'eth1' =\u003e \"11\" } Vagrant.configure(VAGRANT_API_VERSION) do |config| config.vm.box = \"ubuntu/bionic64\" vms.each do |key, value| config.vm.define \"#{key}\" do |node| node.vm.network \"private_network\", ip: \"192.168.50.#{value}\" if \"#{key}\" == \"eth0\" node.vm.network \"forwarded_port\", guest: 8545, host: 8545 end node.vm.hostname = \"#{key}\" node.vm.provider \"virtualbox\" do |nodev| nodev.memory = 2048 end end end end # 내가 이해?한 바로는 eth0과 eth1이라는 2개의 노드(광구)를 설정했다. 정도 \u003e vagrant up # 방금 설정한 eth0과 eth1 노드(광구)를 오픈(실행) \u003e vagrant status # 설정되어 있는 두 노드(광구)의 상태를 확인 runing이면 오픈한 상태 ​ 여기 가지 작업을 했다면 vitualbox에 두개의 노드(광구)가 등록되어있는 것을 확인 할 수 있다. ​ 등록된 노두(광구) 중에서 eth0을 먼저 설정해보자 지금까지 진행한 폴더에서 Terminal을 열고 vagrant 명령어로 노드(광구)를 설정해준다. 기본적은 vagrant 명령어 명령어 설명 vagrant up 상태확인할가상머신이름 가상머신 기동 vagrant status 상태확인할가상머신이름 가상머신 상태 확인 vagrant ssh 접속할가상머신이름 가상머신에 접속 vagrant halt 멈출가상머신이름 가상머신 정지 vagrant suspend 가상머신 휴면 vagrant resume 가상머신 휴면에서 복원 vagrant reload 가상머신 재시동 vagrant destroy 가상머신 제거 *모든 명령어가 vagrant up 상태확인할가상머신이름 과 같이 사용 가능하다. ​ 이제 노드(광구)를 열었으니 접속해보자 =\u003e vagrant ssh 접속할가상머신이름 ​ geth를 설치해준다. *Geth 설치 (Go-ethereum client) # vagrant@eth0:~$ 가상머신에서 수행 \u003e sudo apt-get update \u003e sudo apt-get install software-properties-common \u003e sudo add-apt-repository -y ppa:ethereum/ethereum \u003e sudo apt-get install ethereum #여기까지 순서대로 설치하면 geth설치는 완료. # 프라이빗 이더리움를 관리할 폴더 생성 \u003e mkdir -p dev/eth_localdata #-p는 mkdir 옵션사항 =\u003e 중간경로도 다 만들어라 \u003e mkdir database \u003e cd database # 프라이빗 이더리움을 위한 genesis.json블록파일(블록들을 연결하기 위한 최초의 블럭) 생성 \u003e vi genesis.json # genesis.json를 만들겠다. # genesis.json의 내용 등록 (예시) i → 입력 활성화 → 아래 내용입력 후 → esc → ZZ(저장하고 종료) { \"config\": { \"chainId\": 5245, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0xdeadbeefdeadbeef\", \"difficulty\": \"0x40\", \"gasLimit\": \"9999999\", \"alloc\": {}, \"extraData\": \"\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\": \"0x00\" } # genesis.json 저장 후 \u003e cd .. 다시 root폴더로 이동한다. ​ 나의 최초의 블록(genesis.json)을 만들었다면 등록(초기화)해줘야 한다. =\u003e ✨geth를 사용하여 진행 \u003e geth init #이 명령어로 등록(초기화)을 할 수 있는데... # 위의 --datadir을 참고하여 \u003e geth --datadir ~/dev/eth_localdata init ~/database/genesis.json # ~/database 위치에 있는 genesis.json을 등록(초기화)하고 등록 후 생기는 관련 자료는 ~/dev/eth_localdata에 모아놓겠다는 뜻 ​ 이제 노드(광구)를 관리할 계정(🙋‍♂️사람)도 등록해준다. \u003e geth account new # 이 명령어를 입력하면 아이디는 자동으로 생성되고 비밀번호만 설정할 수 있게 진행된다. # 계정이 잘 만들어 진 것인지 확인하기 위해서는 \u003e geth account list ​ 이제 노드(광구)에 어떤 사람들이 들어올 수 있는지와 입장하는 명령어들을 살펴보자. 어떤식으로 입력(설정)하는 지는 여기를 참고하여 진행하였다. # eth0의 노드(광구) 입장 명령어 \u003e geth console # 다만 보통의 경우 아래와 같이 노드(eth0)에 다양한 주소 및 설정을 붙이고 진행한다. \u003e geth --networkid 5245 --port 30303 --maxpeers 2 --datadir ~/dev/eth_localdata --rpcaddr 0.0.0.0 --nodiscover --nousb console \u003e\u003e ~/eth0.log # 일단 이걸로 채굴 성공 geth --datadir ~/dev/eth_localdata --nodiscover --nousb --networkid 5245 console # 맨 마지막에 2\u003e\u003e ~/eth0.log를 붙이면, 진행기록을 root주소에 eth0.log를 만들어 저장한다.란 뜻. # 진행 도중 ERROR 모음 Failed to enumerate USB devices =\u003e --nousb 추가해주면 사라짐. ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"Transaction eth0 안에 account[0] 이랑 account[1] 이 있고 coinbase는 accounts[0] 인 상황에서 account[0]에서 채굴한걸 account[1]로 보낼 것이다. =\u003e 이를 트랜잭션(Transaction) 한다고 한다. 트랜잭션을 위해서는 먼저 계정들의 잠금 해제가 필요하다. EOS계정을 만들면 기본적으로 잠금 상태인데, # 잠금해제 command 로 해제가 가능하다. (이더를 보내는 EOS계정만 잠금을 풀어주면 된다.) personal.unlockAccount(eth.accounts[0]) #기본적인 세팅, 입력 후 비밀번호 입력 계정 잠금 해제(잠금 해제 유효시간 기본 - 300초) personal.unlockAccount(eth.accounts[0], \"inputpassword\") #비밀번호가 입력되어 계정 잠금 해제(비밀번호 입력 필요X) personal.unlockAccount(eth.accounts[0], \"inputpassword\", 0) #계정 잠금 해제(0 - Geth 프로세스 종료되기 전까지 해제) ​ 이제 트랜잭션이 있는지 확인해보자. (eth.pendingTransactions =\u003e 트랜잭션 확인) 입력한 transaction이 없으니 비어있다. ​ 이제 송금(Transaction) 해보자. eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10, \"ether\")}) # eth.accounts[0]에서 eth.accounts[1]로 web3단위로 10이더를 보내겠다.는 뜻. 색이 이쁘니 성공적으로 명령을 처리 한 것 같다. 하지만 accounts[1]계정에 돈이 들어오지 않았다. ​ 트랜잭션은 등록된게 확인된다. 왜 진행은 안됬을까…. 하지만 accounts[1]계정에 돈이 들어오지 않았다. *blockNumber: null로 accounts[0]에서 보낸 트랜잭션이 accounts[1]의 블록에 포함되지 않음을 알 수 있다. ​ 송금 확인(sendTransaction으로 트랜잭션을 발행해도 처리안됨 =\u003e 블록체인에서는 블록 안에 그 트랜잭션이 포함될 때 트랜잭션 내용이 실행) ✨ 간단히 트랜잭션을 등록하고 miner.start() command로 채굴을 시작하는 경우(블록 활성화?)에 트랜잭션이 반영된다! \u003e miner.start(1) # 이걸로 잠시 채굴을 켰다가. \u003e miner.stop() # 으로 채굴을 꺼주고 \u003e eth.pendingTransactions # 으로 트랜잭션 내용을 다시 확인해주면 비어있는 것을 볼 수 있다. ​ 그리고 # EOS계정(accounts[1])의 잔액을 확인해보면 \u003e eth.getBalance(eth.accounts[1]) \u003e web3.fromWei(eth.getBalance(eth.accounts[1]), \"ether\") #둘다 확인 가능하며 송금이 잘 진행된 것을 볼 수 있다. 여기까지 진행하면서, 두 블로그를 매우 많이 참고했고, 도움이 되었어서 소개한다. Mr.Latte - [Go Ethereum 사용 법] Allg - [Geth 설치 및 테스트 네트워크에서 송금하기] ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:1","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["Vue"],"content":"​ Vuex 핵심컨셉(getters, mutations, actions, modules) ","date":"2020-08-27","objectID":"https://colinder.github.io/08_vue_vuex-concept/:0:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"3. Actions 공식문서에 따르면 액션(Actions)은 변이(mutations)와 유사하나, 몇가지 다른 점이 있다고 한다. 상태를 변이시키는 대신 액션으로 변이에 대한 커밋을 합니다. 작업에는 임의의 비동기 작업이 포함될 수 있습니다. Q. 상태를 변이시키는 대신 액션으로 변이에 대한 커밋을 합니다. A. mutations의 역할은 State를 관리하는 것이다. 그런데 만약 비동기적 요청을 마구잡이로 보내게 된다면, State가 변질될 가능성이 높아진다. 결국 비동기 요청의 경우에도 mutations에 정의한 메소드의 형태로 보내어 상태가 변화하는 것을 추적한다. ​ Q. 작업에는 임의의 비동기 작업이 포함될 수 있습니다. A. 예를 들어 axios요청을 보내놓고 store에 등록된 자료를 가져오거나 수정해 사용하고 싶은 경우 사용하겠다. ​ - 이론적인 개념을 조금 더 생각해보자면, mutations의 경우 디버깅을 위해 동기(순차)적으로 작동이 되었으나 actions의 경우 비동기(비순차)적인 역할을 수행하는데 도움이 된다. 예를 들면, axios요청을 보낸다 던가. setTimeout()을 설정해 작동 시간을 조정한다던가. ​ 🙋‍♂️간단히 Actions을 실습해 봅시다. (Step. 1, 2로 구성) Step. 1 // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { addOneMutations(state) { return state.second++ } }, actions: { 👈 //비동기 요청인 setTimeout을 실습 👈 delayFewMinutes(context) { 👈 context는 그냥 선언적인 겁니다. return setTimeout(() =\u003e { 👈 context.commit('addOneMutations'); 👈 actions도 결국 commit 으로 }, 1000) 👈 mutations를 불러오는 겁니다. } 👈 'addOneMutations'는 위에 mutations에 } 👈 선언한 것을 불러온 것이고 / 1000은 1초를 의미 }) ​ Step. 2 //사용하는 component에서 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eMutations 사용한 값: {{$store.state.second}}\u003c/h1\u003e \u003cbutton @click=\"useMutations\"\u003e+\u003c/button\u003e \u003chr\u003e \u003ch1\u003eActions 사용한 값: {{$store.state.second}}\u003c/h1\u003e 👈 \u003cbutton @click=\"useActions\"\u003e+\u003c/button\u003e 👈 \u003chr\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { //mutations을 이용할 떄는 commit을 사용 useMutations() { return this.$store.commit(\"addOneMutations\", {N: 2}) }, //actions를 이용할 떄는 dispatch를 사용 👈 useActions() { 👈 return this.$store.dispatch(\"delayFewMinutes\") 👈 actions은 store에서 } 👈 'dispatch'로 불러옵니다. } } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ✋잠깐. Actions도 인자를 넘길 수 있는데! \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { //mutations을 이용할 떄는 commit을 사용 useMutations() { return this.$store.commit(\"addOneMutations\", {N: 2}) }, //actions를 이용할 떄는 dispatch를 사용 useActions() { return this.$store.dispatch(\"delayFewMinutes\", {by: 50, time: 2000}) 👈 요기요기 } } } \u003c/script\u003e // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { addOneMutations(state) { return state.second += 2 } }, actions: { //비동기 요청인 setTimeout을 실습 delayFewMinutes(context, payload) { 👈 return setTimeout(() =\u003e { 👈 context.commit('addOneMutations', payload.by) 👈 이런식으로 인자로 작동시간 }, payload.time) 👈 설정도 가능하고, mutations에 } 👈 payload 받는 부분 만들어서 } 👈 거기까지도 전달 가능 }) ​ ","date":"2020-08-27","objectID":"https://colinder.github.io/08_vue_vuex-concept/:1:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"4. Modules 모듈은 간단하게 store에 여러개의 저장소(모듈s)를 만들어 관리한다는 것이다. 공식문서에 따르면 Vuex는 저장소를 모듈 로 나눌 수 있습니다. 고 설명하고 있다. //예를 들자면 이런 모습으로.(출처: 공식문서) const moduleA = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { 👈 여기서 모듈을 선언해주고 a: moduleA, 👈 각각의 모듈을 등록해주고 있는 b: moduleB 👈 모습을 볼 수 있다. } }) ​ ​ ​ ​ ","date":"2020-08-27","objectID":"https://colinder.github.io/08_vue_vuex-concept/:2:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"✨실습해보면서 알게된 포인트를 정리하며 마친다. 1️⃣ Mutations은 동기(순차)적인 경우에 Actions은 비동기(비순차)적인 경우에 사용한다. (하지만 Actions도 결국엔 Mutations를 불러와 사용한다.) 2️⃣ 각각의 Components에서 Actions는 dispatch로 호출해 사용한다. Mutations는 commit으로 불러와서 사용 3️⃣ Modules는 store의 저장소를 분할해 등록하고 싶을 때 사용한다. Vue는 단일 트리 컴포넌트 형식이니 자주 사용되진 않을 것 같다. ","date":"2020-08-27","objectID":"https://colinder.github.io/08_vue_vuex-concept/:2:1","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"​ Vuex 핵심컨셉(getters, mutations, actions, modules) ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:0:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"1. Getters 만약? A.vue와 B.vue에서 각각 store의 state에 등록된 second의 2를 3으로 변형해 사용하고 싶다면 어떻게 해야 할까? 저장소에 등록되어 있는 상태(state)를 변경하고 싶다면? 아마 귀찮겠지만, 각각의 파일에서 // A.vue computed: { change() { return this.$store.state.second + 1 } } // B.vue computed: { change() { return this.$store.state.second + 1 } } 이와 같이 동일한 코드를 작성해서 사용해야 할 것이다. ​ 이러한 코드의 중복을 막고 state에 등록된 data를 변경해 사용하고 싶을 때 getters를 사용한다. ​ 🙋‍♂️실습해보자! (Step. 1, 2로 구성) Step. 1 //지난시간에 등록한 내용을 활용해서 //store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { 👈 addOne(state) { 👈 return state.second + 1 👈 } 👈 } 👈 }) ​ Step. 2 // A.vue, B.vue 동일하게 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { 👈 그냥 store에서 return this.$store.state.second 👈 불러온 자료를 }, 👈 노출하기 위한 등록 useGetters() { 👈 store에 addOne이라는 return this.$store.getters.addOne 👈 ✨ getters를 불러오기 } 👈 위해 작성한 코드 } 👈 입니다. } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:1:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"2. Mutations 공식문서에 Mutations는 “Vuex 저장소에서 실제로 상태를 변경하는 유일한 방법은 변이하는 것\"이라는 설명이 있다. 하지만 나는 Mutations는 store.state 값을 변경하는 로직들을 의미한다고 정리하고 싶다. Getters 와 차이점을 알아두면 좋은데, 인자를 받을 수 있다. ____ex) addOneMutations(state, 인자) computed가 아닌 methods에 등록해 사용한다. computed는 계산된값이기에 등록하면 바로 노출이 가능하지만 Methods는 함수지 등록된 값이 아니다. mutations에 등록된 로직은 작동시 state의 값을 변경시킨다.___(단, 새로고침시 state을 원복) mutations은 commit()으로 호출해 사용한다. ​ 역시 🙋‍♂️실습해보자! (Step. 1, 2로 구성) Step. 1 // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { 👈 addOneMutations(state) { 👈 return state.second++ 👈 or 2씩 증가: return state.second += 2 } 👈 } }) ​ Step. 2 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eMutations 사용한 값: {{$store.state.second}}\u003c/h1\u003e 👈 \u003cbutton @click=\"useMutations\"\u003e+\u003c/button\u003e 👈 \u003chr\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { 👈 useMutations() { 👈 return this.$store.commit(\"addOneMutations\") 👈 }, 👈 } 👈 } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:2:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"✨실습해보면서 알게된 포인트를 정리하며 마친다. 1️⃣ Getters로 가져온 값은 새로고침(F5)을 하여도 사라지지 않는다. 애초에 store에서 변형한 값을 가져오니까. 2️⃣ Mutations로 등록된 methods는 원본데이터(store.state)의 값을 변화 시킨다. 단, 새로고침(F5)시 원본데이터 값이 회복된다. 3️⃣ Mutations은 동기(순차)적으로 작동되며 commit으로 불러와 사용한다. 원본데이터(state)의 값을 변경시키기 때문에 순서가 중요하다! ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:2:1","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1149_RGB거리 N = int(input()) RGB = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(RGB)): RGB[i][0] = RGB[i][0] + min(RGB[i-1][1], RGB[i-1][2]) RGB[i][1] = RGB[i][1] + min(RGB[i-1][0], RGB[i-1][2]) RGB[i][2] = RGB[i][2] + min(RGB[i-1][0], RGB[i-1][1]) print(min(RGB[i][0], RGB[i][1], RGB[i][2])) # 2시간이 넘게 고민한 결과... # 문제 속 조건3 \"\"i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\"\"을 이해하는데 시간이 걸렸다. # 조건3에 따르면 N=3인 경우, i = 2가 되고, 결국 1번, 3번 집의 색과 2번 집의 색이 다르면 된다. # 난 이걸.. 1번집과 3번집의 색이 달라야 한다고 잘못 이해해서 시간을 버렸다.ㅎ ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1932_정수삼각형 N = int(input()) tree = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(tree)): f = len(tree[i]) for j in range(f): if j == 0: tree[i][j] = tree[i][j] + tree[i-1][j] elif j == f-1: tree[i][j] = tree[i][j] + tree[i-1][j-1] else: tree[i][j] = tree[i][j] + max(tree[i-1][j-1], tree[i-1][j]) print(max(tree[i])) # 이전 문제를 풀고선 그리 어렵지않게 풀었다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"2579_계단오르기 # 1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다. # 2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다. # 3. 마지막 도착 계단은 반드시 밟아야 한다. N = int(input()) # stairs = [int(input()) for _ in range(N)] # 이렇게 정보를 받으면 느리다.... stairs = [0 for _ in range(301)] for i in range(N): stairs[i] = int(input()) total = [0 for _ in range(301)] total[0] = stairs[0] total[1] = stairs[0] + stairs[1] total[2] = max(stairs[1] + stairs[2], stairs[0] + stairs[2]) # 마지막 계단을 반드시 밟아야 하니까. \u003c0: 안밟음, 1: 밟음\u003e for i in range(3, N): total[i] = max( total[i-3]+stairs[i-1]+stairs[i], # 1 0 1 1(마지막계단)의 경우 total[i-2]+stairs[i] # 1 0 1(마지막계단)의 경우 ) print(total[N-1]) ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1463_1로 만들기 x = int(input()) x_map = [0 for i in range(x+1)] visited = [0 for i in range(10**6)] x_map[x] = 1 count = 0 while x_map[1] == 0: count += 1 for i in range(1, x+1): if x_map[i] == count: if i % 3 == 0 and visited[i//3] == 0: x_map[i//3] = count+1 visited[i//3] = 1 if i % 2 == 0 and visited[i//2] == 0: x_map[i//2] = count+1 visited[i//2] = 1 if x_map[i-1] == 0 and visited[i-1] == 0: x_map[i-1] = count+1 visited[i-1] = 1 print(x_map[1]-1) # 코딩하면서는 너무 바보 같은 방법인가.. 했지만, 통과됬으니 뭐.. 만족한다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1003_피보나치 함수 def Fibonacci(N): if N \u003c 3: print(zero[N], one[N]) else: f = 1 s = 2 for i in range(N-2): zero.append(zero[f] + zero[s]) one.append(one[f] + one[s]) f += 1 s += 1 print(zero[N], one[N]) for T in range(int(input())): N = int(input()) zero = [1, 0, 1] one = [0, 1, 1] Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1904_01타일 def Fibonacci(N): result: 0 f = 0 s = 1 for i in range(1, N+3): if i == 1: result = f elif i == 2: result = s else: result = f+s f = s % 15746 s = result % 15746 print(result % 15746) Fibonacci(int(input())) # 문제를 먼저 손으로 플어보니 결국 피보나치 수열이 답이었는데 # 15746의 나머지가 답이어서 그런지 '시간 초과'가 발생했다. # 때문에 '왜맞틀?'로 고민하다 검색해보니 결과값을 15746의 나머지로 더한다는 # 방법을 보고 이를 참고했다. (솔직이 아직 이게 왜 더 빠른지 잘 모르겠다.) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"2748_피보나치의 수2 def Fibonacci(N): Fibo = [0, 1] f = 0 s = 1 for i in range(3, N+2): Fibo.append(Fibo[f] + Fibo[s]) f += 1 s += 1 print(Fibo[N]) N = int(input()) Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"9461_파도반 수열 for T in range(int(input())): N = int(input()) Padovan = [1, 1, 1] f = 0 s = 1 for i in range(N-3): Padovan.append(Padovan[f] + Padovan[s]) f += 1 s += 1 print(Padovan[N-1]) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["web"],"content":"​ Naming Convention 정해진 규정은 없으나, 많은 개발자들이 암묵적으로 지키고 있는 이름짓는 방법. ​ snake_case 🐍 # _ == snake some_var = 5 my_awesome = 3 ​ camelCase 🐪 # 낙타등이 솟아 있는 모습 someVar = 5 pyAwesome = 3 ​ UpperCamelCase 🐪🐪 # 낙타얼굴과 등이 중간에 솟아 있는 모습 (파스칼식(Pascal case)이라고도 불린다.) SomeVar = 5 PyAwesome = 3 ​ Kebab-Case 🥙 # 케밥이 꼬챙이에 꽂힌 모습에서 생긴 방법(이라는데 난 생김새는 잘 모르겠다.ㅎ) main-login = 5 feed-content = 1 ​ ","date":"2020-08-02","objectID":"https://colinder.github.io/namingconvention/:0:0","tags":["web"],"title":"Naming Convention","uri":"https://colinder.github.io/namingconvention/"},{"categories":["Vue"],"content":"​ What is Vuex? (공식문서) Vuex는 Vue.js 애플리케이션에 대한 상태 관리 패턴 + 라이브러리 입니다. 애플리케이션의 모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있습니다. 또한 Vue의 공식 devtools 확장 프로그램과 통합되어 설정 시간이 필요 없는 디버깅 및 상태 스냅 샷 내보내기/가져오기와 같은 고급 기능을 제공합니다. (공식문서 설명) ​ # 설치 명령어 npm i vuex or npm install vuex # 이후 src폴더안에 vuex폴더를 만들고 store.js라는 파일을 생성. (파일생성위치는 자유롭게 설정가능) ​ 그렇다면? 상태관리패턴이란 무엇인가? ​ 🤔이를 알아보기 전에 간단히 지난 시간에 알아본 props와 emit의 문제점을 생각해보자! 많은 components를 통과해야 하는 prop의 경우 테이터 이동을 위한 코드가 장황해질 수 있다. 형제 components는 부모를 거쳐 데이터를 이동해야 하는 불편함이 발생한다. 심지어 손자 components 끼리 데이터를 이동하려면 엄청나게 많은 props와 emit이 작성되어야 하는데, 이런 불편함을 해소하기 위해 데이터 저장소(STORE)를 생성하는 것을 고민해볼 수 있다. ​ 이 때문에 대규모 애플리케이션의 상태를 관리할 수 있는 상태 관리 패턴이 필요해진다. 예를 들면 이를 단일 상태 트리(single state tree) 로 데이터를 관리한다고 표현한다. 공식문서에 이에 대한 설명이 있는데 내가 생각하는 핵심은 아래와 같다. 각 애플리케이션마다 하나의 (데이터)저장소만 갖게 한다. 데이터를 저장하고 이를 불러오기만하면 되니 간편한 코딩이 가능해진다. ROW 데이터를 저장하는 곳을 지정해 관리하는 곳이 생긴다. 이를 구현해보자. ​ 아까 만든 store.js에 기본적인 세팅을 진행해보자. (해당 과정은 총 3 Step으로 구성) ​ Step. 1 store.js에 데이터를 등록(저장)한다. ## store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ // 여기에 state(상태) 정보를 등록해서 사용. // ex) 여러형태의 데이터를 구현해보자. state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] } }) ## ✨Point: store에 state라는 곳에 데이터를 저장했다는 것을 기억하고 다음으로 넘어가자. ​ Step. 2 저장소(STORE)에 데이터가 입력되었으니 이를 최상위 .js 파일(main.js)에 등록해 모든 영역에서 사용가능**(전역으로 등록)**하게 하자. ## main.js import Vue from 'vue' import App from './App.vue' import router from './router' (이전에 설명한 router도 설치되었음을 알 수 있다.) import store from '../src/vuex/store.js' 👈(추가) Vue.config.productionTip = false new Vue({ router, (이전에 설명한 router도 설치되었음을 알 수 있다.22) store, 👈(추가) render: h =\u003e h(App) }).$mount('#app') ​ Step. 3 store에 저장된 데이터를 불러와 사용한다. (난 Vue_CLI를 사용해, 디폴트 파일인 About.vue에 출력한다.) ","date":"2020-08-02","objectID":"https://colinder.github.io/05_vue_what-is-vuex/:0:0","tags":["Vue"],"title":"05_Vue_What is Vuex?","uri":"https://colinder.github.io/05_vue_what-is-vuex/"},{"categories":["Vue"],"content":"✋ 여기서 잠깐! Q. store에 저장된 데이터를 불러오는 방법은 무엇인가요? A. 여러방법이 있으나 가장 Basic한 방법으로 1. computed를 사용해 불러오는 방법과 2. data를 선언해 사용하는 방법을 알아보자. (이 두 방법을 추천하는 이유는 LifeCycle에서 정리되어 있다.) ## About.vue 방법.1 (computed를 사용하는 방법) \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e{{result}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'About', //Step 1. computed: { result() { return this.$store.state } } } \u003c/script\u003e ## About.vue 방법.2 (data 선언 후 store를 저장해 사용하는 방법) \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- Step. 3 --\u003e \u003ch1\u003e{{result}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'About', //Step. 1 data() { return { result: \"\", } }, //Step. 2 created() { this.result = this.$store.state } } \u003c/script\u003e ​ Thanks to ‘이서영'💑 ","date":"2020-08-02","objectID":"https://colinder.github.io/05_vue_what-is-vuex/:0:1","tags":["Vue"],"title":"05_Vue_What is Vuex?","uri":"https://colinder.github.io/05_vue_what-is-vuex/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4466_최대 성적표 만들기 for T in range(int(input())): N, K = map(int, input().split()) score = list(map(int, input().split())) score.sort(reverse=True) result = 0 for i in range(K): result += score[i] print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4406_모음이 보이지 않는 사람 for T in range(int(input())): sent = input() result = '' for i in sent: if i not in 'aeiou': result += i print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4299_태혁이의 사랑은 타이밍 for T in range(int(input())): D, H, M = map(int, input().split()) result = D*1440 + H*60 + M if result \u003e= 16511: print(f'#{T+1} {result-16511}') else: print(f'#{T+1} -1') ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["Vue"],"content":"​ 1. Vue CLI 란? (공식문서) 간단히 vue-cli 는 기본 vue 개발 환경을 설정해주는 도구입니다. 여기서 CLI 란 ? 명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. (위키백과) ​ 2. Vue router 프로젝트 생성 후 보통의 경우 편의를 위해 terminal에 vue add router를 입력해 router설치를 진행합니다. router를 설치하고 나면 기존의 vue 프로젝트의 tree구조에서 약간의 변화가 생기게 됩니다. router 설치 전: App.vue - components router 설치 후: App.vue - views - components ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/03_vue_cli/:0:0","tags":["Vue"],"title":"03_Vue_cli \u0026 router \u0026 histoyMode","uri":"https://colinder.github.io/03_vue_cli/"},{"categories":["Vue"],"content":"views 폴더 속 .vue 파일의 특징 1. views 폴더안의 .vue 파일들은 App.vue에 직접 연결되며, components들을 품을 수도 있다. 2. props(부모 → 자식으로 데이터 이동)와 emit(자식 → 부모으로 데이터 이동)을 이용해 데이터를 활용한다. 더 많은 특징 및 활용방법이 있을 것이나 상기 내용은 가장 기초이자 핵심입니다. ​ ✋ 여기서 잠깐! Q. A파일에 B파일을 적용(등록) 혹은 불러와서 사용하고 싶다면? A. 1. import / 2. components에 등록 / 3. template에 사용 (이중 하나라도 빼먹으면 오류발생!) ​ 🤷‍♂️ 1번 내용부터 실습해보자 부모(views)에 자식(components)를 품는 상황을 가정하고 코딩 (Step 1~3 으로 구성) Step 1. // App.vue \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e //Component에 등록한 name 사용법 (위 아래가 동일) \u003crouter-link :to=\"{ name: 'Parent' }\"\u003eParnet\u003c/router-link\u003e | //디폴트 사용법 \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e // 연결된 router의 내용을 보여주는 곳 \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e Step 2. // components/Child.vue (직접 생성) \u003ctemplate\u003e \u003cdiv class=\"child\"\u003e \u003ch2\u003e자식 컴포넌트\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'Child', } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .child { border: 3px solid blue; margin: 3px; padding: 3px; } \u003c/style\u003e Step 3. // views/Parent.vue (직접 생성) // views에 components 등록 ✨ Point! 1. views에서 components를 등록(Parent가 Child를 품고 싶다면)하고 싶다면, 1) components의 \u003cscript\u003e\u003c/script\u003e에 import 진행 2) \u003cscript\u003e\u003c/script\u003e안에 components: {Child}의 문법으로 등록 3) \u003ctemplate\u003e\u003c/template\u003e안에 components이름으로 탭을 만들면 해당 위치에 components 표현 가능 \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003ch1\u003e부모 컴포넌트\u003c/h1\u003e \u003c!-- step 3. 사용 (feat. 나중에 자식에게서도 데이터를 받음. this.$emit('hungry' 여기 값을 반영)) --\u003e \u003cChild/\u003e \u003ch2\u003e최하단입니다.\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e // step 1. import import Child from '../components/Child.vue' export default { name: 'Parent', // step 2. 등록 }, components: { // 'Child': Child, 키 벨류가 같으면 아래와 같이 사용가능 Child, } } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .parent { border: 3px solid red; margin: 3px; padding: 3px; } \u003c/style\u003e ​ ※ Vue 프로젝트를 생성해 components를 등록하고, 화면을 구성하다보면 각각의 components에서 작성 또는 변경된 데이터를 이리저리 보낼 수 있다면 더 다양한 것을 할 수 있어진다. 이를 위한 것이 props(부모에서 자식에게 데이터 이동)와 emit(자식에서 부모에게 데이터 이동)이다. ​ 🤷‍♀️ 2번 내용도 실습해보자 부모 views에서 자식 component간의 용돈을 주고 받는 상황을 가정하고 코딩해보자 (Step 1~4) Step 1. ## App.vue \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e \u003c!-- Component에 등록한 name 사용법 (위 아래가 동일) --\u003e \u003crouter-link :to=\"{ name: 'Parent' }\"\u003eParnet\u003c/router-link\u003e | \u003c!-- 기존 사용법 --\u003e \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e \u003c!-- 연결된 router의 내용을 보여주는 곳 --\u003e \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e... Step 2. ## views/Parent.vue (직접 생성) ## 부모에서 자식에게 데이터 전달 (views → components) ✨ Point! 1. views에서 components를 등록(Parent가 Child를 품고 싶다면)하고 싶다면, 1) components의 \u003cscript\u003e\u003c/script\u003e에 import 진행 2) \u003cscript\u003e\u003c/script\u003e안에 components: {Child}의 문법으로 등록 3) \u003ctemplate\u003e\u003c/template\u003e안에 components이름으로 탭을 만들면 해당 위치에 components 표현 가능 2. views에서 components에 데이터를 넘길때에는, 1) \u003ctemplate\u003e\u003c/template\u003e안에 components탭에 :내리고 싶은 데이터=\"데이터명\" `:propFromParentMsg=\"parentMsg\"`의 문법으로 전달 \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003ch1\u003e부모 컴포넌트\u003c/h1\u003e \u003c!-- step 3. 사용 --\u003e \u003cChild :propFromParentMsg=\"parentMsg\"/\u003e \u003ch2\u003e최하단입니다.\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e // step 1. import import Child from '../components/Child.vue' export default { name: 'Parent', // step 2. 등록 data () { return { parentMsg: '용돈 필요하니(부모가 전달한 메세지)' } }, components: { // 'Child': Child, 키 벨류가 같으면 아래와 같이 사용가능 Child, } } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .parent { border: 3px solid red; margin: 3px; padding: 3px; } \u003c/style\u003e Step 3. ## components/Child.vue (직접 생성) ## 1. views에서 components에 받은 데이터 노출 (부모에게서 받은 데이터 노출) ## 2. components에서 views에 데이터 전달 (자식에서 부모에게 데이터 전달) ✨ Point! 1. views에서 받은 데이터를 노출하고 싶다면, 1) \u003cscript\u003e\u003c/script\u003e에 전달받은 데이터의 자료형을 선언해주며 등록 ex) props: {propFromParentMsg: String,} 2) 보간법('{{}}')을 사용하여 노출. ex) {{ propFromParentMsg }} 2. components에서 views에 데이터를 넘길때에는 이벤트를 생성해 전달하는데, 1) 부모에게 전달한 메서드 만든다. methods: { moneySignal () {this.$emit('needMoney')} } : 📌 this.$emit() : 부모에게 전달하는 이벤트 이름 📌 2) 메서드를 작동시킬 이벤트를 만든다. ex) \u003cbutton @click=\"moneySignal\"\u003e용돈 필요해요!!!\u003c/button\u003e → 클릭시 moneySignal이라는 메서드 실행 \u003ctemplate\u003e \u003cdiv class=\"child\"\u003e \u003ch2\u003e자식 컴포넌트\u003c/h2\u003e \u003c!-- 부모에게서 받은 데이터 노출 --\u003e {{ p","date":"2020-07-17","objectID":"https://colinder.github.io/03_vue_cli/:1:0","tags":["Vue"],"title":"03_Vue_cli \u0026 router \u0026 histoyMode","uri":"https://colinder.github.io/03_vue_cli/"},{"categories":["Vue"],"content":"​ ","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:0:0","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"Vue의 기본 문법 및 동작 방법을 계속 알아보자 08_methods ✨Point 1. method는 methods: {}의 문법으로 구성한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eMethods\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e {{ message }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' }, methods: { alertWarning: function() { alert('WARNING') }, alertWarning () { // Syntactic Sugar : 위와 완전히 동일 alert(this.message) }, changeMessage() { this.message = 'CHANGED MESSAGE' } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 09_v-on 위에서 선언한 methods를 이제 실행한다. ✨Point (아주아주 중요) 1. 난, v-on은 이벤트(methods 등)를 실행시켜주는 트리거라고 이해했다. 2. 트리거를 발동시키는 내용은 여러가지가 있으니 이는 별도로 공부해야 한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-on\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003ch1\u003e{{ message }}\u003c/h1\u003e \u003cbutton v-on:click=\"alertWarning\"\u003eAlert warning\u003c/button\u003e \u003cbutton v-on:click=\"alertMessage\"\u003eAlert Message\u003c/button\u003e \u003cbutton v-on:click=\"changeMessage\"\u003eChange Message\u003c/button\u003e \u003c!-- v-on: 는 @ 로 축약해서 사용할 수 있다. --\u003e \u003cbutton @click=\"changeMessage\"\u003eChange Message\u003c/button\u003e \u003chr\u003e \u003cinput v-on:keyup.enter=\"onInputChange\" type=\"text\"\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' }, methods: { alertWarning: function() { alert('WARNING') }, alertMessage () { // Syntactic Sugar : 위와 완전히 동일 alert(this.message) }, changeMessage() { this.message = 'CHANGED MESSAGE' }, onInputChange(event) { // console.log(\"!!\") // if (event.key === 'Enter') { this.message = event.target.value // } }, } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 👍 v-on 이벤트 종류는 여기에 모두 있다. ​ 10_v-model ✨Point 1. data값과 input값을 실시간으로 연동(양방향 바인딩)해주는 디렉티브 2. v-on(@)과 value를 동시에 걸어주면 양방향 바인딩이 가능함. 3. v-model은 input, select, textarea에만 사용이 가능함. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-model\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ message }}\u003c/h1\u003e \u003ch4\u003e단반향 binding (input =\u003e data)\u003c/h4\u003e 1way \u003cinput @keyup.enter=\"onInputChange\" type=\"text\"\u003e \u003chr\u003e \u003ch4\u003e양방향 binding\u003c/h4\u003e 2way \u003cinput @keyup.enter=\"onInputChange\" type=\"text\" :value=\"message\"\u003e \u003chr\u003e \u003c!-- 단뱡향과 양방향을 구분하기 귀찮아서 model을 개발 --\u003e \u003ch4\u003ev-model 양방향 binding\u003c/h4\u003e v-model/2way \u003cinput v-model=\"message\" type=\"text\"\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el:'#app', data: { message: 'hi' }, methods: { onInputChange(event) { this.message = event.target.value } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 11_v-show ✨Point 1. v-if와 거의 유사하나 개발자 도구로 찍어보면 v-if는 조건에 따라 렌더링이 있다 없다 하지만, v-show의 요소는 항상 렌더링 되고 DOM에 남아있다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-show\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003c!-- v-if와 거의 유사!--\u003e \u003cbutton @click='changeF'\u003echangeF\u003c/button\u003e \u003cp v-if=\"t\"\u003eTrue\u003c/p\u003e \u003cp v-if=\"f\"\u003efalse\u003c/p\u003e \u003cp v-show=\"t\"\u003eshow True\u003c/p\u003e \u003cp v-show=\"f\"\u003eshow false\u003c/p\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: \"#app\", data: { t: true, f: false, }, methods: { changeF() { this.f = !this.f } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 12_computed ✨Point 1. computed는 페이지 시작시 별다른 선언없이도 자동으로 실행된다. 2. script태그 안에 computed: {} 와 같이 선언해 사용 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003ch1\u003eBankrruped\u003c/h1\u003e {{ getBankrrupedPeople }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { accounts: [ { name: 'neo', balance: 500, isBankrruped: tr","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:1:0","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"종합 실습(로또 번호 추천) \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003elotto\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cbutton @click=\"getLuckySix\"\u003egetLuckySix\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"number in myNumbers\"\u003e {{ number }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c!-- 수학적 커멘드는 lodash 활용 --\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: \"#app\", data: { allNumbers: _.range(1, 46), myNumbers: [] }, methods: { getLuckySix() { this.myNumbers = _.sampleSize(this.allNumbers, 6) // vue는 str로 자료를 보는데 이를 정수로 바꾸기 위한 코드는 아래와 같다. // vue에서 str과 str을 빼는 건 int로 값이 나오기 때문에 this.myNumbers.sort((a, b) =\u003e a - b) } }, }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:1:1","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"​ Vue Vue.js는 웹 애플리케이션의 사용자 인터페이스를 만들기 위해 사용하는 오픈 소스 프로그레시브 자바스크립트 프레임워크 간단히, 온라인 홈페이지를 만드는 프로그램입니다. 아래 정리할 내용들이 당장 크게 와닿지 않을 수 있습니다. 하지만 필요할 때 보면, 도움이 될 것입니다! ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:0:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"Vue의 이론적 구성 및 설명을 알아보자 1. Vue는 MVVM 패턴을 따른다. MVVM(Model-View-ViewModel) 패턴? 모델과 뷰 사이에 뷰모델이 위치하는 구조 ​ 2. Vue는 SPA (Single-Page Application) 서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션을 말한다. 내가 이해한 방식: 변경사항이 발생했을 때 새로고침을하며 매번 페이지를 새롭게 구성하는 것이 아니라, 서버를 돌릴 때 이미 모든 페이지가 제작되어 있고 이를 사용자의 선택에 따라 보여주는 것. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:1:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"Vue의 기본 문법 및 동작 방법을 알아보자 01_data 선언 ✨Point 1. data는 함수로 선언하여 등록하고 사용한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c/div\u003e \u003c!-- Vue를 사용하겠다는 CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', // component별로 data(변수등록)는 함수로 선언하여 사용한다. data: { message: 'Hello Vue' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 02_interpolation(보간법) ✨Point 1. 보간법: 두 점을 연결하는 방법 2. 난, `data(변수)는 script태그에 함수 형태로 선언하며, {{}} 2개의 중괄호 안에 변수명을 적어 사용한다.` 정도로 이해했다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e {{ message }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 03_v-text ✨Point 1. data에 선언된 변수를 그대로 가져와서 노출 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c!-- Vanilla JS. domElenment.innText --\u003e \u003c!-- v- 로 시작하는 것들은 모두 디렉티브(명령하는 것)라고 부른다. --\u003e \u003cp v-text='message'\u003e\u003c/p\u003e \u003cp\u003e{{ message }}\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: '완전히 같아요' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 04_v-if ✨Point 1. 태그 안 v-if가 true일 때만, 값이 노출된다. 2. vue에선 빈 리스트는 True값 반환 3. 이외에 false, 빈스트링(\"\"), 0은 False값 반환 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eVue-if\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cp v-if='bool1'\u003etrue는 참이니 노출\u003c/p\u003e \u003c!--bool1이 참이니까. true가 보인다.--\u003e \u003cp v-if='bool2'\u003efalse\u003c/p\u003e \u003c!--bool2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='str1'\u003e비어있지 않은 문자열은 True\u003c/p\u003e \u003c!--str1이 참이니까. true가 보인다.--\u003e \u003cp v-if='str2'\u003e비어있으면 false고 노출 안됨\u003c/p\u003e \u003c!--str2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='num1'\u003e1은 True\u003c/p\u003e \u003c!--num1이 참이니까. true가 보인다.--\u003e \u003cp v-if='num2'\u003e0은 false\u003c/p\u003e \u003c!--num2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='arr'\u003e빈 리스트는 arr_True!!!\u003c/p\u003e \u003c!-- vue는 빈배열이 true 평가 --\u003e \u003cp v-if='arr.length'\u003earr_false\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { bool1:true, bool2:false, str1:'Yes', str2:'', num1:1, num2:0, arr: [], } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 05_v-if-elseif-else ✨Point 1. vue에선 if / elseif / else을 나누어 사용 가능. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c!-- 조건식도 가능 --\u003e \u003cp v-if=\"username === master\"\u003ehello master\u003c/p\u003e \u003cp v-else\u003ehello user\u003c/p\u003e \u003chr\u003e \u003cp v-if=\"number \u003e 0\"\u003e양수\u003c/p\u003e \u003cp v-else-if=\"number \u003c 0\"\u003e음수\u003c/p\u003e \u003cp v-else\u003e영\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { username: 'master', number: 0, } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 06_v-for ✨Point (아주아주 중요) 1. list안에 담으면 for사용 가능 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cul\u003e \u003cli v-for='number in numbers'\u003e{{ number }}\u003c/li\u003e \u003c!-- 이런 것도 가능 --\u003e \u003cli v-for='number in numbers'\u003e{{ number + 1 }}\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli v-for='teacher in teachers'\u003e{{teacher}}\u003c/li\u003e \u003cli v-for='teacher in teachers'\u003e{{teacher.name}}\u003c/li\u003e \u003c/ol\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { numbers: [0,1,2,3,4,5], teachers: [ { name: 'neo'}, { name: 'tak'}, ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e v-for 연관된 key라는 것이 있","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:2:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"​ Vue Vue.js는 웹 애플리케이션의 사용자 인터페이스를 만들기 위해 사용하는 오픈 소스 프로그레시브 자바스크립트 프레임워크 간단히, 온라인 홈페이지를 만드는 프로그램입니다. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:0:0","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"1. 시작하기 ‘Vue’ VS ‘Django’ 어느 정도 공부를 하면서 체득한 가장 큰 구분점은 “Django는 App별로 응답을 구분하고, Vue는 Component별로 응답을 구분한다.“는 것입니다. 큰 차이가 없어보이고, 큰 의미가 없어보일 수 있으나 알아두면 좋습니다! ​ 💻 개발 환경 설정 vscode 설치 nodeJS 설치 # 🤔 안정적인 버전 vs 최신 버전 # 상관없으나 개인적으로 안정적인 버전을 추천합니다. # 😀 설치가 잘 되었나 확인 방법! # terminal창(cmd) -\u003e node -v (명령어 입력) # 버전 넘버가 보이면 정상 설치 된 것입니다. 프로젝트를 시작할 폴더에서 마우스 오른쪽 클릭 후 vscode 실행 =\u003e terminal에서 npm install 설치 이후 Terminal에서 추가로 npm i -g @vue/cli 설치 설치가 잘 되었나 vue --version으로 확인 (버전이 보이면 ok) (선택사항) vscode의 추천 Extensions Vetur Vue VSCode Snippets Auto Rename Tag Auto Close Tag ​ 🎉 프로젝트 생성 $ vue create myproject # myproject 프로젝트 생성 $ cd myproject # 생성한 myproject 폴더로 이동 $ vue add router # (선택사항) myproject 히스토리를 관리해줄 router기능 설치 $ npm run serve # myproject의 디폴트 서버 실행 App running at: - Local: http://localhost:8080/ - Network: http://192.168.219.164:8080/ 이후 Local로 접속하면 생성된 서버 페이지 확인이 가능하다. 또 같은 공유기를 사용하고 있는 기기에서 접속하여 서버 확인이 가능하다. ​ 생성된 프로젝트의 기본사항 파악 Terminal창에 vue create myproject 명령어 입력 후 이와 같은 창이 뜨는데 default로 설정하고 enter하고, 프로젝트를 시작한다. ​ 프로젝트 생성이 완료되면 (router 미설치) 이와 같은 폴더 구조를 확인할 수 있다. ​ vue add router를 한다면. 두번의 묻는데 전부 y 로 처리(router와 history mode 설정을 묻는 것) ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:0","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"여기서 잠깐✋ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:1","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"1. VUE CLI 란? (공식문서) 간단히 vue-cli 는 기본 vue 개발 환경을 설정해주는 도구 여기서 CLI 란 ? 명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. (출처: 위키백과) ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:2","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"2. vue add router 필요한가? 라우팅은 URI에 따라 해당하는 정적파일을 보여주는 방식. 이를 브라우저에서 구현 하는것이 SPA 개발의 핵심 아이디어는 간단하다. 요청 URI에 따라 브라우저에서 DOM을 변경하는 방식. 대부분의 경우 도움이 되는 기능이기 때문에 상당이 추천한다. (추가로 navbar? 도 생기니 더욱 추천) terminal에 vue add router 를 입력하면 history 모드를 사용하겠나고 묻는데 y 를 입력해주면 된다. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:3","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"3. vue add router 후 History Mode 설정은 왜 필요한가? vue add router를 설치하게 되면 해쉬백 모드와 히스토리 모드 중 디폴트로 해쉬백 모드가 적용된다. 만약 위의 그림에서 히스토리 모드를 사용하지 않더라도 나중에 URL에 있는 해쉬를 제거하기 위해 라우터의 히스토리 모드로 변경할 수 있다. # src/router/index.js const router = new VueRouter({ mode: 'history', 👈요거를 등록하면 history 모드 실행 routes: [...] }) ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:4","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4676_늘어지는 소리 만들기 for T in range(int(input())): sent = list(input()) # wow H = int(input()) po = sorted(list(map(int, input().split()))) # 2 3 2 for i in range(H): a = po[i]+i sent.insert(a,'-') print('#{} {}'.format(T+1, ''.join(sent))) # 단순 산수로 해결 ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4615_재미있는 오셀로 게임 dx = [0, 1, 1, 1, 0, -1, -1, -1] dy = [1, 1, 0, -1, -1, -1, 0, 1] def dfs(x, y, i ,stone): if board[x][y] == 0: return 0 elif board[x][y] == stone: return 1 else: if dfs(x+dx[i], y+dy[i], i, stone): board[x][y] = stone return 1 else: return 0 for T in range(int(input())): N, M = map(int, input().split()) command = [list(map(int, input().split())) for _ in range(M)] board = [[0]*(N+2) for _ in range(N+2)] board[N//2+1][N//2+1] = 2 board[N//2][N//2] = 2 board[N//2][N//2+1] = 1 board[N//2+1][N//2] = 1 for x, y, stone in command: for i in range(8): board[x][y] = stone dfs(x+dx[i], y+dy[i], i, stone) B = 0 W = 0 for i in range(N): for j in range(N): if board[i+1][j+1] == 1: B += 1 elif board[i+1][j+1] == 2: W += 1 print(f'#{T+1} {B} {W}') # dfs를 연습해볼 수 있는 좋은 문제라고 생각한다. # 추가적인 조건이 있어 dfs를 많이 사용해보지 못한 나는 해결하는데 오랜 시간이 걸렸다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4579_세상의 모든 팰린드롬 2 for T in range(int(input())): arr = input() result = 'Exist' for i in range(len(arr) // 2): if arr[i] == '*' or arr[-1 - i] == '*': result = 'Exist' break if arr[i] != arr[-1 - i]: result = 'Not exist' break print(f'#{T+1} {result}') # *이 등장하기 전까지 대칭을 이루고 있다면 무조건 'Exist'이고, # 만약 *가 없다면, 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4522_세상의 모든 팰린드롬 for T in range(int(input())): arr = list(map(str, input())) result = 'Exist' for i in range(len(arr)): if arr[i] == '?': arr[i] = arr[-i - 1] if arr != arr[::-1]: result = 'Not exist' print(f'#{T+1} {result}') # ?가 등장하면 무조건 해당 index의 반대쪽이 대칭을 이룬다고 생각할 수 있으니까, # ?의 index 반대쪽을 동일하게 변경해주고 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_5162_두가지 빵의 딜레마 for T in range(int(input())): A, B, C = map(int, input().split()) N = min(A, B) print(\"#{} {}\".format(T+1, int(C/N))) # 단순 산수로 해결 ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4789_성공적인 공연 기획 for T in range(int(input())): P = list(map(int, map(str, input()))) need = P[0] count = 0 for i in range(1, len(P)): if need \u003e= i: need += P[i] else: count += i - need need = i + P[i] print(f'#{T+1} {count}') # 문제를 이해하는 것이 Point였다. # 먼저 str로 input을 받아 개별 숫자로 나누고 바로 int 변경하여 인자를 받음. # # \"i번째 글자가 의미하는 바는 기립 박수를 하고 있는 사람이 i-1명 이상일 때 기립 박수를 하는 사람의 수\" # Test case3의 경우 (09) 9는 큰 의미 없이 2번째 글자임으로 기립박수를 하고 있는 사람이 1명일 이상일 때 기립박수를 친다. # 즉 index만 가지고 조건을 판단 하면 된다! ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4751_다솔이의 다이아몬드 장식 T= int(input()) for tc in range(T): text = input() n= len(text) for i in range(5): if i == 0 : print('..#.'*n+'.') elif i == 1 : print('.#'*(n*2)+'.') elif i == 2 : print('#',end='') for a in range(len(text)) : print(('.{}.#'.format(text[a])), end=\"\") elif i == 3 : print() print('.#'*(n*2)+'.') elif i == 4 : print('..#.' * n + '.') # 단순 작업이었으나, 반복되는 곳의 기준을 어디로 할 것인가를 잘 지정해야 함. ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5431_민석이의 과제 체크하기 for T in range(int(input())): N, K = map(int, input().split()) P = list(map(int, input().split())) result = [] for i in range(1,N+1): if i not in P: result.append(str(i)) print('#{} {}'.format(T+1, ' '.join(result))) # 제출한 수강생 리스트를 만들고(P) 이를 for로 돌리며 검증 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5356_의석이의 세로로 말해요 for T in range(int(input())): sent = [list(str(input())) for _ in range(5)] #입력받은 요소의 길이를 알아내야 한다. max = 0 for n in range(5): long = len(sent[n]) if long \u003e= max: max = long result = '' for i in range(max): for j in range(5): try: if sent[j][i] != \"\": result += sent[j][i] except IndexError: pass print(f'다시 풀이 #{T+1} {result}') # 입력받은 5개의 단어 중 가자 긴 단어의 길이를 저장하고(long) # long 길이 만큼 순회를 하면서 5개의 단어에 index로 접근하고 index값이 비어있지 않으면 result에 추가 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5293_이진 문자열 복원 for T in range(int(input())): A, B, C, D = map(int, input().split()) if B == 0 and C == 0 and A != 0 and D != 0: result = 'impossible' elif abs(B - C) \u003e 1: result = 'impossible' else: if B == 0 and C == 0: if A != 0: result = '0' * (A + 1) else: result = '1' * (D + 1) elif B \u003c C: result = '1' * D + '10' * C + '0' * A elif B \u003e C: result = '0' * A + '01' * B + '1' * D else: result = '0' * A + '01' * B + '1' * D + '0' print('#{} {}'.format(T+1, result)) # 하드코딩...ㅎㅎ ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5215_햄버거 다이어트 for T in range(int(input())): N, maxKcal = map(int, input().split()) Sum = [0] * (10**4 + 1) for _ in range(N): Point, Kcal = map(int, input().split()) for idx in range(maxKcal, Kcal + 1, -1): if Sum[idx] \u003c Sum[idx - Kcal] + Point: Sum[idx] = Sum[idx - Kcal] + Point print(f'#{T+1} {Sum[maxKcal]}') ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["Hugo"],"content":"​ 블로그를 만들면서… 최초 기술블로그를 제작하면서 바닥부터 모든 것을 스스로 만들어 보기로 결심하고 제작을 시작하지만, 결코 쉽지 않았다. 개인적으로 꼭 원했던 기능이었던 tag기능과 categories를 구현하지 못하면서… 결국 기존에 있는 라이브러리들을 활용하기로 한다. ​ 가장 많은 사용자가 존재하는 jekyll로 시작한다. ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:0:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"jekyll 기초 설정 Jekyll : Jekyll은 Ruby Gem으로 제공되며 템플릿과 템플릿의 구성요소, 인라인 코드, 마크다운과 같은 동적인 구성요소를 정적인 웹페이지로 만들어주는 파싱 엔진 ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:1:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"jekyll 서버 구동 방법 # 공식 홈페이지 설명 ~$ gem install bundler jekyll # jekyll 구동을 위한 프로그램 설치 ~$ jekyll new MYBLOG # MYBLOG 라는 이름의 블로그 폴더 \u0026 기초틀 생성 ~$ cd MYBLOG # MYBLOG 폴더로 이동 ~MYBLOG $ bundle exec jekyll serve # MYBLOG 서버 구동 # 이후 명령창에 Servuer address : http://127.0.0.1:4000/ #로 인터넷 접속하면 jekell의 디폴트 서버 모습이 보인다. ​ 포스팅을 하면서 이 내용을 정리할 때쯤. 알 수 없는 치명적인 오류로 인해 작성했던 .md파일과 git 서버가 폭파했다. 여러 방면으로 복구를 시도했지만, 모든 방법이 실패했고. 그리하여.. 난 jekyll을 떠나 Hugo로 이동하기로 했다. ​ Why Hugo? #1. window를 공식 지원한다. ( Jekyll은 window를 공식적으로 지원하진 않는다. ) → Hugo가 Jekyll 보다 window환경에서 안정적이지 않을까? #2. The world’s fastest framework for building websites → 빠르다. Hugo로 블로그를 구축하고 / 이를 git의 서버를 통해 배포한다. ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:1:1","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"Hugo로 github.io 블로그 만들기 ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"1. Git, Hugo 설치 Git 설치란? Git_bash설치를 뜻한다. 링크를 타고 들어가 적절한 버전을 선택해 설치를 진행한다. ​ 👉 bash를 실행시키고 git --version을 입력해서 version 정보가 확인되면 정상 설치가 된 것이다. ​ Hugo 설치 (공식홈페이지의 Quick_Start 참고) ​ 👉 난 Hugo_release에서 최신버전을 다운받아 직접 설치했다. C:\\Hugo\\bin\\에 압축을 해제. window + Q로 검색창을 연 뒤 변수를 검색해서 시스템 환경 변수 편집에 들어간다. 아래의 환경 변수(N)를 클릭. 위쪽 박스에서 Path를 더블클릭한다. 새로 만들기를 클릭 후, 아까 압축을 풀었던 곳인 C:\\Hugo\\bin를 등록. 닫고 배경화면에서 bash 실행 후 hugo version을 입력해서 version 정보가 나오면 잘 설치가 된 것. ​ 어마어마한 특이사항 발견..(20.10.17) 난 커스텀이 되는 테마를 받아서 사용했으나, 아무리 시도해도 커스텀이 적용되지 않았었는데 만약 내가 사용할 테마가 Sass/SCSS를 사용한다면 반드시 extended version으로 설치하여야 한다!! extended version은 기본 버전에서 Sass/SCSS 프로세싱을 지원이 추가된 버전이다! ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:1","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"2. Hugo 블로그 구축하기 프로젝트를 구축할 폴더(혹은 장소)에서 bash를 실행 hugo new site \u003c프로젝트 이름\u003e # ex) hugo new site MyBlog → MyBlog라는 프로젝트 폴더를 생성. hugo에서 site, theme, content를 만들때는 항상 new command를 사용하여 생성한다. 이때 생성된 폴더는 프로젝트폴더, root폴더, default폴더 등으로 불리며, 기본 구조는 이러하며, 먼저 테마를 설정해보자. 필자는 LoveIt 테마를 선택해 사용함. ​ Theme는 다운 → 적용의 2단계를 거친다. ​ ​ 1. 다운 먼저 LoveIt 테마 Git홈페이지에 가 clone을 떠온다. 프로젝트폴더에서 bash를 실행 후 cd theme # theme 폴더로 이동 git clone https://github.com/dillonzq/LoveIt.git # LoveIt 테마 클론(다운) ​ ​ 2. 적용 프로젝트폴더속 config.toml파일을 열어 수정을 하여 적용하는데 적용 방법은 각 Theme의 git_site에 정리 되어 있다. LoveIt theme의 경우 아래와 같은 방법으로 설정하며 추가 버전이 release되어 있어 이를 적용하는 방법은 공식 문서를 읽어보며 custom한다. baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" # Change the default theme to be use when building the site with Hugo theme = \"LoveIt\" ... ... ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:2","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5948_새샘이의 7-3-5 게임 for T in range(int(input())): N = list(map(int, input().split())) result = set() for i in range(5): for j in range(i+1, 6): for x in range(j+1, 7): result.add(N[i]+N[j]+N[x]) result = list(result) result.sort() print('#{} {}'.format(T+1, result[-5])) # 3수의 합을 정리하는데 set으로 중복을 제거하는 방법으로 result set을 정리 # set은 순서가 없기 때문에 result를 다시 list로 정리하고 .sort를 이용해 순서대로 나열 후 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5789_현주의 상자 바꾸기 for T in range(int(input())): N, Q = map(int, input().split()) arr = ['0' for _ in range(N)] for i in range(1, Q+1): L, R = map(int, input().split()) for _ in range(L-1, R): arr[_] = str(i) print('#{} {}'.format(T+1, ' '.join(arr))) # arr이라는 0이 적힌 상자 리스트를 생성 # index L~R에 _의 숫자를 입력(출력하기 쉽게 str형태로 입력) # join을 써서 str형태의 list인자를 붙여서 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5688_세제곱근을 찾아라 for T in range(int(input())): N = round(int(input())**(1/3), 2) print(\"#{} {}\".format(T+1, int(N) if int(N) == N else -1)) # 출력 방식에 조건을 넣어서 시도해봄 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5549_홀수일까 짝수일까 for T in range(int(input())): N = int(input()) print('#{} {}'.format(T+1, 'Even' if N%2 == 0 else 'Odd')) # 출력 방식에 조건을 넣어서 시도해봄 ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6190_정곤이의 단조 증가하는 수 for T in range(int(input())): N = int(input()) L = list(map(int, input().split())) result = -1 for i in range(N-1): for j in range(i+1, N): num = str(L[i]*L[j]) if len(num) \u003e 1 and '0' not in num and result \u003c int(num) and list(num) == sorted(num): result = int(num) print(f'#{T+1} {result}') # 단조증가하는 지를 검증하는 방법으로 sorted를 썼는데 이를 활용하기 위해서는 str형태로 변경해야 검증이 가능하다. # 한자리 숫자는 단조증가하는 수가 아니다. # 중간에 0이 있다면 볼 필요도 없이 단조증가수가 아니기 때문에 처리 속도 증가가 가능하다. ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6057_그래프의 삼각형 for T in range(int(input())): N, M = map(int,input().split()) # N: 정점, M: 간선 arr = [[0]*(N+1) for n in range(N+1)] # part1 for _ in range(M): X, Y = map(int,input().split()) arr[X][Y] = 1 arr[Y][X] = 1 # part2 result = 0 for i in range(1, N+1): for j in range(i+1, N+1): if arr[i][j] == 1: for r in range(j+1, N+1): if arr[j][r] == 1 and arr[r][i] == 1: result += 1 print(f\"#{T+1} {result}\") # part1에서 삼각형의 정점의 정보를 담는 arr을 만들고 # part2에서 만들어진 배열을 돌며 정점의 정보를 발견(1)하면 해당 정점을 기준으로 삼각형이 되는지 검증 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6019_기차 사이의 파리 for T in range(int(input())): D, A, B, F = map(int,input().split()) t = D / (B+A) print('#{} {}'.format(T+1, F*t)) #단순 수학으로 해결 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_5986_새샘이와 세 소수 for T in range(int(input())): N = int(input()) # part1 PN = set() for i in range(2, N+1): for j in range(2, i+1): if i % j == 0: break PN.add(j) PN =list(PN) pn = PN.sort(reverse=True) # part2 count = 0 for i in range(len(PN)): for j in range(i,len(PN)): for k in range(j,len(PN)): if N == PN[i]+PN[j]+PN[k]: count += 1 print('#{} {}'.format(T+1, count)) # part1에서 소수 리스트를 만들고(1과 자기 자신만을 약수로 가지는 수 리스트) # part2에서 세 소수의 합으로 나타낼 경우의 수를 종합. ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_9700_USB 꽂기의 미스터리 for T in range(int(input())): p, q = map(float, input().split()) s1 = (1-p)*q s2 = p*(1-q)*q if s1 \u003c s2: print(f'#{T+1} YES') else: print(f'#{T+1} NO') # 단순 수학을 통해 해결. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_7675_통역사 성경이 for T in range(int(input())): N = int(input()) sent = input() sent = sent.replace('.', ' @').replace('!', ' @').replace('?', ' @').split() #print(sent) result = \"\" count = 0 for i in sent: if i.isalpha() and i == i.capitalize(): count += 1 if i == '@': result += str(count) + ' ' count = 0 print(\"#{} {}\".format(T+1, result)) # 주어지는 문장을 띄어쓰기를 기준으로 나누기 위해 .split()을 사용하고 # 문제에서 주어진 `이름`의 조건이 `첫 알파벳이 대문자이고 나머진 소문자`이기 때문에 # 문자로만 이루어져있는 것인지 .isalpha()로 검증 (VS .isdigit() 주어진 문자열이 숫자인지 검증) # `이름`의 조건이 맞는지 .capitalize()로 검증 # 추가 공부 내용 # upper - 주어진 문자열에서 모든 알파벳들을 대문자로 변환시킨다. # capitalize - 주어진 문자열에서 맨 첫 글자를 대문자로 변환하고 나머지는 소문자로 변환시킨다. # title - 주어진 문자열에서 알파벳 외의 문자(숫자, 특수기호, 띄어쓰기 등)로 나누어져 있는 영단어들의 첫 글자를 모두 대문자로 변환시킨다. # .isalpha()와 .capitalize()를 알고나면 간단해지는 문제. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6692_다솔이의 월급 상자 for T in range(int(input())): tc = int(input()) result = 0 for _ in range(tc): P, X = map(float, input().split()) result += P*X print(f'#{T+1} {result}') # input을 float형으로 받으면서 단순 수학을 사용해 해결 ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6485_삼성시의 버스 노선 for T in range(int(input())): info = [0]*5001 for N in range(int(input())): st, la = map(int, input().split()) for x in range(st, la+1): info[x] +=1 station = [] for P in range(int(input())): station.append(str(info[int(input())])) print('#{} {}'.format(T+1, ' '.join(station))) # info로 정류장의 index를 기록(중복되는 위치를 표기하기 위해 +1 씩 진행) # P개의 버스 정류장을 확인하는데 저장되어있는 info의 정류장 정보를 가져와서 station리스트에 기록 # 주어진 문제에서 만약 범위?를 알려준다면 그만큼의 저장 리스트를 생성하는 것이 빠르다. # 예를 들어 info = [] 보다 info = [0]*5001 로 설정해 사용하는 것이 더 빠른 실행시간을 보여준다. ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"}]