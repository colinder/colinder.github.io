[{"categories":["langchain","langgraph"],"content":"LangChain \u0026 LangGraph 대화형 주문 인공지능을 개발하면서, 사용했던 프레임워크인 LangChain \u0026 Langgraph에 대하여 정리하고 사용방법을 정리한다. ​ ","date":"2026-02-20","objectID":"https://colinder.github.io/langchainnlanggraph/:1:0","tags":["langchain","langgraph"],"title":"langchain \u0026 langgraph","uri":"https://colinder.github.io/langchainnlanggraph/"},{"categories":["langchain","langgraph"],"content":"LangChain LangChain은 대형 언어 모델(LLM)을 중심으로 한 애플리케이션을 쉽게 구성할 수 있도록 하는 프레임워크이다. 풀어서 말하면 LLM을 API처럼 쓰는 것에 그치지 않고 프롬프트, 도구, 메모리, 외부 데이터(RAG) 등을 하나의 애플리케이션 구조로 묶어주는 추상화 계층 ​ ​ ","date":"2026-02-20","objectID":"https://colinder.github.io/langchainnlanggraph/:2:0","tags":["langchain","langgraph"],"title":"langchain \u0026 langgraph","uri":"https://colinder.github.io/langchainnlanggraph/"},{"categories":["langchain","langgraph"],"content":"LangGraph LangGraph는 상태(State)를 기반으로 LLM 애플리케이션의 실행 흐름을 그래프 구조로 정의하기 위한 프레임워크이다. (여기서 중요한 키워드는 “실행 흐름을 그래프 구조로 정의”) 풀어서 말하면 LLM 호출을 단순히 “한 번 실행”하는 게 아니라 상태를 가진 프로세스로 보고 각 단계를 노드(Node), 흐름을 엣지(Edge) 로 정의 ​ ​ ","date":"2026-02-20","objectID":"https://colinder.github.io/langchainnlanggraph/:3:0","tags":["langchain","langgraph"],"title":"langchain \u0026 langgraph","uri":"https://colinder.github.io/langchainnlanggraph/"},{"categories":["langchain","langgraph"],"content":"실제 개발 순서 실제 개발하는 데 진행했던 순서를 정리한다. 사용할 모델을 정의한다. state를 정의한다. 대략적인 그래프 구조를 고안한 후 필요한 node를 정리한다. 단일 기능으로 동작?할 노드 should_continue로 분기할 노드 그래프를 정의하고 컴파일한다. checkpointer 설정한다. api와 연동하여 .invoke()하여 사용한다. 보통 이런 순서로 진행하면 크게 문제 없이 동작할 것이며, 큰 흐름은 이해할 수 있다. (다만 이 흐름과 상관 없이 데이터를 저장하고 관리해야 하는데 이는 redis를 사용하는 등 분산 처리 및 관리하는 것을 권장한다.) ​ ​ 1. 사용할 모델을 정의한다. 필자는 azure에 있는 모델을 사용했으며 이를 불러오는 방법 등은 아래 코드를 참고하면 되겠다. # models.py from langchain_openai import AzureChatOpenAI from config import settings llm = AzureChatOpenAI( azure_deployment=\"gpt-4o\", api_version=\"2024-08-01-preview\", api_key=settings.AZURE_OPENAI_API_KEY, azure_endpoint=settings.AZURE_OPENAI_ENDPOINT, ) 여기서 중요한 값은 “azure_deployment”, “api_version\"가 홈페이지에 등록된 내용과 정확히 일치해야 한다. ​ ​ 2. state를 정의한다. 사실상 지금 단계에서 이를 완벽히 수행하기는 어렵다고 생각한다. 다만 어떤 값들을 주고 받을 것이며, 어떤 데이터 들을 다룰 것인지 미리 정의 한다고 생각. (경험상 반드시 구조가 강제되지는 않는 부분이다.) # schemas.py from typing import Any, Dict, List from langgraph.graph import MessagesState class AgentSystemSchema(MessagesState): \"\"\" 에이전트 전반에서 공통으로 참조하는 시스템 상태 정의 (비즈니스 컨텍스트 및 시스템 고정 정보) \"\"\" system_message: str # LLM에게 전달되는 시스템 프롬프트 products: List[Dict[str, Any]] # 주문 가능한 상품 목록 (상품명, 가격, 옵션 등 비즈니스 정보) previous_orders: str # 사용자의 이전 주문 내역 요약 정보 # 대화 맥락 유지 및 재주문/추천 판단에 활용 class AgentState(MessagesState): \"\"\" 단일 대화 흐름에서 변경되며 누적되는 에이전트 실행 상태 \"\"\" message: str # 가장 최근 사용자 또는 에이전트의 발화 messages: List[Any] # 전체 대화 이력 # 메시지 누적 관리 및 LLM 컨텍스트 제공 용도 summary: str # messages가 과도하게 누적되는 것을 방지하기 위한 # 기존 대화 요약 정보 (컨텍스트 압축 목적) system: AgentSystemSchema # 시스템 전역 상태 # 대화 중 변경되지 않거나 드물게 변경되는 비즈니스/환경 정보 ​ ​ 3. 대략적인 그래프 구조를 고안한 후 필요한 node를 정리한다. node는 역할 기준으로 다음 두 가지로 구성하였다. 작업 수행 노드 단일 책임을 가지는 로직을 수행하며 state를 갱신하고 다음 단계로 전달할 결과를 반환한다. 분기 판단 노드 (should_continue) 현재 state를 기준으로 그래프의 실행 흐름을 제어한다. ​ 작업 수행 노드 예시 ## 사용자의 발화가 주문인지 아닌지 판단 from langchain_core.output_parsers import JsonOutputParser from langchain_core.prompts import PromptTemplate from ..llm.models import llm from ..schemas import AgentState order_detection_prompt = PromptTemplate.from_template(\"\"\" 당신은 사용자의 입력이 주문인지(혹은 주문의 수정, 삭제인지) 아닌지 판별하는 주문 판별 전문 AI 어시스턴트입니다. 무조건 아래 schema를 준수해서 JSON 형태로 답을 해야 합니다. class OrderState(str, Enum): right_order = \"right_order\" wrong_order = \"wrong_order\" not_order = \"not_order\" class OrderDetectionSchema(BaseModel): is_order: OrderState system_message: str 사용자 입력: {messages} 구매할 수 있는 제품목록: {available_products} 이전 주문 내역: {previous_orders} 주문 여부를 판단 기준 1. 제품명이 존재하는지? - '사용자 입력'에는 반드시 상품명과 수량이 포함되어 있어야 함 - 사용자는 공식 상품명을 그대로 쓰지 않고, 약어나 고유 키워드만으로 표현하는 경우가 많으므로 이 점을 반드시 고려할 것 - '유사한 상품명'에 대한 정보와 반드시 비교해서 유사한 상품이 있는지 알아본 후 주문인지 아닌지 고려할 것. - '제품 목록'에 100% 일치하는 상품이 있는 경우, 이 상품을 주문하는 것으로 판단할 것 - 사용자가 입력한 상품명은 제공된 '구매할 수 있는 제품목록'과 반드시 연관성이 있어야 하며, 부분적으로 일치하거나 키워드 유사도(예: \"만두\"가 \"고기 만두\" 또는 \"김치 만두\"와 부분적으로 일치하는 경우)가 있다면, 정확히 일치하지 않아도 유효한 상품명으로 인식하세요. 유사한 제품이 복수일 때에도 주문으로 간주할 것 - 주문 여부 판단 시, 상품명이 매우 추상적일 수 있음을 염두에 두고, 연관성이 다소 낮더라도 제품 정보에 유사한 단어나 키워드가 있으면 '주문'을 한거라고 판단할 것 2. 수량이 존재하는지? - 수량은 상품명에 직접 붙어 있을 수도 있고, 별도의 단위와 함께 숫자로 표기될 수도 있습니다. 단, 수량은 항상 정수로 표현됩니다. - 수량이 각각의 상품명 끝에 직접 붙어 있을 수 있으며, 이 경우 각 숫자를 해당 상품의 주문 수량으로 해석해야 합니다(예: \"갓김치1\"은 제품 '갓김치 1개 주문', \"참이슬1\"은 제품 '참이슬 1개 주문'). - 상품명 뒤에 공백 없이 숫자가 바로 따라오면(예: \"배추김치103\"), 그 숫자를 해당 상품의 주문 수량으로 해석해야 합니다. 즉, \"배추김치103\"은 상품명 \"배추김치\"에 수량 103개로 인식해야 합니다. - 수량은 1, 10, 100, 1000, 10000 이상도 가능하며, 이는 특이한 케이스가 아니고 수량을 의미한다고 판단할 것 - 이전 주문 내역(previous_orders)을 참고해서 주문 여부를 판단할 것. 이전 주문 내역과 유사한 형태로 입력했다면 이는 주문일 확률이 높습니다. - 주문할 수 없는 상품에 대한 주문으로 판단되면, 해당되는 상품 전체를 언급하며 다시 정확히 주문해달라고 system_message 필드에 작성해 주세요. (ex. 말씀하신 {messages}는 주문으로 판단되지 않습니다.) 주의사항 위 기준을 바탕으로 입력을 꼼꼼히 분석한 뒤, 주문이면 is_order 필드에 주어진 Enum에 맞는 값으로 반환해주세요. is_order에는 \u003cclass 'str'\u003e타입의 'right_order', 'wrong_order', 'not_order' 이외에는 어떤 값도 들어갈 수 없습니다. 또 다른 어떤 문자나 특수문자를 추가하지 마세요. 꼭 \u003cclass 'str'\u003e로 값이 들어와야 합니다. system_message에는 \u003cclass 'str'\u003e 타입으로 반환해야 합니다. 당부사항 ❗system_message에는 사용자의 입력을 왜 주문으로 판단했는지, 어떤 상품 정보를 비교했는지, 어떤 상품에 유사하다고 판단했는지, 상품명과 수량이 잘 표시되었는지, 결과적으로 왜 주문으로 판단했는지 그 근거를 반드시 한글로 작성해 주세요. \"\"\") async def is_order_should_continue(state:","date":"2026-02-20","objectID":"https://colinder.github.io/langchainnlanggraph/:4:0","tags":["langchain","langgraph"],"title":"langchain \u0026 langgraph","uri":"https://colinder.github.io/langchainnlanggraph/"},{"categories":["langchain","langgraph"],"content":"마무리 해당 구조를 활용해 RAG나 프롬프트 엔지니어링 등 다양한 기법을 적용할 수 있으니 큰 흐름과 구조만 잘 알아두자. ​ ​ ​ ​ ​ ​ ","date":"2026-02-20","objectID":"https://colinder.github.io/langchainnlanggraph/:5:0","tags":["langchain","langgraph"],"title":"langchain \u0026 langgraph","uri":"https://colinder.github.io/langchainnlanggraph/"},{"categories":["vscode","lint"],"content":"​ ","date":"2026-01-21","objectID":"https://colinder.github.io/vscode_lint/:0:0","tags":["vscode","lint"],"title":"내가 쓰는 vscode lint 설정","uri":"https://colinder.github.io/vscode_lint/"},{"categories":["vscode","lint"],"content":"방법 정리 vscode에서 확장프로그램 ruff를 설치 user setting으로 가서 아래 내용 입력 \"[python]\": { \"editor.formatOnSave\": true, \"editor.codeActionsOnSave\": { \"source.organizeImports\": \"explicit\" }, \"editor.defaultFormatter\": \"charliermarsh.ruff\" }, ​ ​ ​ ​ ","date":"2026-01-21","objectID":"https://colinder.github.io/vscode_lint/:1:0","tags":["vscode","lint"],"title":"내가 쓰는 vscode lint 설정","uri":"https://colinder.github.io/vscode_lint/"},{"categories":null,"content":"​ 국세청 전자세금계산서 발급_part.2 앞선 문서에서는 국세청에 부서사용자 신청하고, 부서사용자에서 지원하는 표준인증검증 통과하기까지 필요한 개발사항을 정리했다. 지난번에 이어서 단계별로 정리한다. ​ 2-3 암호화 추출한 인증서 정보와 암호화할 세금계산서들을 묶어서 하나의 리스트로 만들고 이를 같이 암호화했다. 여기서는 국세청 공개키를 가져와 사용해야한다. # import EncryptWithCMS = jpype.JClass(\"com.barostudio.eTaxInvoice.EncryptWithCMS\") j_xml_list = jpype.JClass(\"java.util.ArrayList\")() java_signed_xml = bytes(signed_bytes) j_xml_list.add(JByteArray(java_signed_xml)) # - encoding하지 않은 binary 상태 (표준지침에 따라) java_cms_encrypted_bytes = EncryptWithCMS.encrypt( bytearray(rvalue_bytes), # rvalue 바이트 j_xml_list, # 서명된 XML 바이트 묶음 homeTax_cert_path, # 국세청 공개키 위치 ) EncryptWithCMS.java package com.barostudio.eTaxInvoice; import java.io.BufferedInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.InputStream; import java.security.Security; import java.security.cert.CertificateException; import java.security.cert.CertificateFactory; import java.security.cert.X509Certificate; import java.util.List; // import org.bouncycastle.asn1.DEROutputStream; import org.bouncycastle.asn1.ASN1OutputStream; import org.bouncycastle.cms.CMSAlgorithm; import org.bouncycastle.cms.CMSEnvelopedData; import org.bouncycastle.cms.CMSEnvelopedDataGenerator; import org.bouncycastle.cms.CMSProcessableByteArray; import org.bouncycastle.cms.CMSTypedData; import org.bouncycastle.cms.jcajce.JceCMSContentEncryptorBuilder; import org.bouncycastle.cms.jcajce.JceKeyTransRecipientInfoGenerator; import org.bouncycastle.jce.provider.BouncyCastleProvider; import com.barostudio.nts.asn1.TaxInvoiceData; import com.barostudio.nts.asn1.TaxInvoicePackage; // import org.bouncycastle.asn1.kisa.KISAObjectIdentifiers; // public class EncryptWithCMS { /** * 여러 건의 rvalue/xml 페어를 국세청 표준에 맞는 ASN.1 구조체로 합친 뒤 * CMS(EnvelopedData) 포맷으로 암호화한다. * * @param rvalueBytesList rvalue 바이트 배열 리스트 (서명 vID 검증값, XML 개수와 1:1) * @param xmlBytesList 전자세금계산서(서명 포함) XML 바이트 배열 리스트 * @param homeTaxCertPath 수신자(국세청) 인증서 파일 경로 * @return 암호화된 CMS DER 바이너리 * @throws Exception */ public static byte[] encrypt( byte[] rvalueBytes, List\u003cbyte[]\u003e xmlBytesList, String homeTaxCertPath ) throws Exception { byte[] _package = getTaxInvoicePackageAsBytes(rvalueBytes, xmlBytesList); CMSTypedData msg = new CMSProcessableByteArray(_package); CMSEnvelopedDataGenerator edGen = new CMSEnvelopedDataGenerator(); // 국세청 공개키 import edGen.addRecipientInfoGenerator( new JceKeyTransRecipientInfoGenerator( kmCert(homeTaxCertPath) ) .setProvider(\"BC\")); // 3DES 암호화 CMSEnvelopedData ed = edGen.generate(msg, new JceCMSContentEncryptorBuilder(CMSAlgorithm.DES_EDE3_CBC) .setProvider(\"BC\").build()); // 암호화된 CMS(EnvelopedData) 객체를 ASN.1 DER 바이너리로 직렬화 byte[] cmsEncryptedBytes = ed.getEncoded(); return cmsEncryptedBytes; } public static byte[] getTaxInvoicePackageAsBytes( byte[] rvalueBytes, List\u003cbyte[]\u003e xmlBytesList ) throws Exception { if (xmlBytesList == null || xmlBytesList.isEmpty()) { throw new IllegalArgumentException(\"xmlBytesList must not be empty.\"); } int count = xmlBytesList.size(); TaxInvoiceData[] dataArr = new TaxInvoiceData[count]; for (int i = 0; i \u003c count; i++) { dataArr[i] = new TaxInvoiceData(rvalueBytes, xmlBytesList.get(i)); } TaxInvoicePackage pkg = new TaxInvoicePackage(dataArr); ByteArrayOutputStream baos = new ByteArrayOutputStream(); // ASN.1 DER 형식의 바이너리로 인코딩 (필수 요소) ASN1OutputStream out = ASN1OutputStream.create(baos); out.writeObject(pkg); out.close(); return baos.toByteArray(); } // kmCert private static X509Certificate kmCert( String hometaxCertPath ) throws FileNotFoundException, CertificateException { Security.addProvider(new BouncyCastleProvider()); FileInputStream ksfis = new FileInputStream(hometaxCertPath); BufferedInputStream ksbufin = new BufferedInputStream(ksfis); X509Certificate certificate = (X509Certificate) CertificateFactory.getInstance(\"X.509\").generateCertificate(ksbufin); return certificate; } } ​ 2-4 SOAP 패키징 SOAP도 이번에 처음 들어봤다. SOAP(Simpl","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_02/:0:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.2","uri":"https://colinder.github.io/etax_process_02/"},{"categories":null,"content":"전체 프로세스 국세청에 부서사용자 신청하기 부서사용자에서 지원하는 표준인증검증 통과하기 실사기술검증 통과하기 등기로 국세청 실서버에 대한 정보 수신하기 실서비스 운영 ​ 표준인증검사를 마치면 표준인증서를 전달받을 수 있다. 이러면 이제 내 회사(혹은 사업자)가 속한 지역 세무서에 가서 ASP 사업자 등록?을 진행한다. 그러면 이후 실사검증 진행일정을 잡게 된다. ​ 이미 표준인증을 통과했다면, 실사검증에 대한 개발사항은 비교적 간단히 진행이 가능하다. 항목이 지역?이나 세무소?마다 다른지는 모르겠지만, 검증사항의 기능들을 몇몇개 소개하자면 다음과 같다. 공급가액, 세액, 합계금액 자동게산 여부 지연발생 시 가산세 대상 안내를 제공하는지 여부 예약 발행 가능 여부 시스템상 미래일자로 발행 가능하지 여부(법적으로 허용안됨) … ​ 표준인증은 국세청과의 통신을 위해 최소한이자 모든 기능이 동작하는지 점검하는 느낌이라면, 실사검증은 시스템운영적으로 국세청에 해가되게(무분별하게) 발급이 되지 않는지, 법적 규제 및 안내가 적절히 이루어 지고 있는지 점검하는 느낌이다. ​ ​ ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_02/:1:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.2","uri":"https://colinder.github.io/etax_process_02/"},{"categories":null,"content":"마무리 혼자서 5개월 동안 열심히 개발했다. 진짜 열심히 했다. ​ ​ ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_02/:2:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.2","uri":"https://colinder.github.io/etax_process_02/"},{"categories":null,"content":"​ 국세청 전자세금계산서 발급_part.1 국세청의 전자세금계산서 발급 기능을 혼자 개발하면서 확인한 프로세스, 문서 및 개인적인 노하우 등을 정리한다. 사실 국가에서 제공하는 여타 api처럼 매우 간단할 것으로 예상했었다. (하지만 복잡하다..) 또한 이 기능을 개발하는데 https://github.com/ruseel/kr-etax-sample 안내가 도움이 되었다. ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_01/:0:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.1","uri":"https://colinder.github.io/etax_process_01/"},{"categories":null,"content":"전체 프로세스 국세청에 부서사용자 신청하기 부서사용자에서 지원하는 표준인증검증 통과하기 실사기술검증 통과하기 등기로 국세청 실서버에 대한 정보 수신하기 실서비스 운영 ​ 국세청 전자세금계산서 발급기능의 개발 및 연동을 위해서는 우선 국세청에 해당 기능을 개발 및 사용하겠다는 신청을 해야 한다. 그 시작이 부서사용자 신청이다. 세금계산서 발급을 지원해주는 경우는 두 가지가 있다. 자체 시스템을 보유한 경우 (A) ASP(Application Service Provider, 전자세금계산서 발급 기능을 제공하는 업체)를 사용하는 경우 (B) 이 둘의 흐름을 간략히 표현하자면 아래와 같다. (A) 의 경우 ​ (B) 의 경우 해당 문서는 이 중 (B), 즉 ASP의 개발을 설명한다. ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_01/:1:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.1","uri":"https://colinder.github.io/etax_process_01/"},{"categories":null,"content":"1. 국세청에 부서사용자 신청하기 국세청 전자세금계산서 발급기능을 개발하겠다고 국세청에게 신고하는 단계 (신청에 따른 행정 절차는 생략한다.) 이때 참고해야 하는 문서는 표준전자세금계산서개발지침(17년8월).pdf이다. 작성된지 매우 오래된 문서이고 간간히 잘못기재된 내용, 잘못된 내용이 섞여있어, 참과 거짓을 분석하며 봐야 한다. 국세청에서도 현재 기준(25년 12월) 관리되고 있지 않아, 의문점을 문의해도 해답을 받을 수 없었다. 하지만 전자세금계산서를 발급하기 위한 유일한 가이드 문서라 이를 무시할 수도 없다. 달달 외울 정도로 봐야 한다. ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_01/:1:1","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.1","uri":"https://colinder.github.io/etax_process_01/"},{"categories":null,"content":"2. 부서사용자에서 지원하는 표준인증검증 통과하기 국세청 전자세금계산서 발급기능의 개발 및 연동을 위해서 단위 기능 테스트하는 단계 필자는 python이 주 언어라, fastapi를 써서 개발했으며, xml 파일을 다루어야 하는데 이는 java의 라이브러리들을 활용했다. python 라이브러리에도 “signxml” 등을 써봤으나 여러 문제들이 발생했고, 오랬동안 문제없이 사용되었던 java 라이브러리들을 사용해 개발하는게 믿을 수 있고 속도감있게 개발이 가능했다. (“signxml\"을 쓰면 안된다 라기보다, 필자가 깊이있게 써보지 않아서 이게 되는지 안되는지 모르겠다.) 하지만, java 라이브러리를 python에 호환해서 사용하려면 배포시 docker 파일이 복잡해지는 등 어려움이 있지만, 이를 감수하고 그냥 사용했다. 여기서부터 헬이었다. 혼자 해당 기능을 개발해야 하는 상황이어서, 국세청 담당자랑도 통화를 많이하고, 혼자 표준지침 문서를 달달 외울 정로도 봤다. ​ 필작 생각하기에 표준인증검증은 크게 4가지 파트인 것 같다. 전자세금계산서 제작 전자세금계산서 암호화 전자세금계산서 패키징 국세청에게 전송 및 응답 ​ 또한 발급 프로세스를 도식화하면 아래와 같다. ​ 2-1 XML 전자세금계산서 제작 XML(eXtensible Markup Language(확장 가능한 마크업 언어)) 매우 낯선 언어였다. 필자가 이해한 건 그냥 데이터를 주고 받는 과거의 표준?정도의 느낌이다. 현재 테이터 통신을 위한 구조로 JSON이 사실상 표준인 상황에서 xml을 조금 알아두면 표준지침을 이해하는데 도움이 된다. 먼저 세금계산서를 제작하기 위해서 python의 lxml 라이브러리를 사용했다. from lxml import etree TAX_NS = \"urn:kr:or:kec:standard:Tax:ReusableAggregateBusinessInformationEntitySchemaModule:1:0\" XSI_NS = \"http://www.w3.org/2001/XMLSchema-instance\" # 일부러 둘의 순서를 뒤틈 \u003e 정규화함수가 정상적으로 동작하는지 확인하기 위함. NSMAP = { \"xsi\": XSI_NS, None: TAX_NS, # 기본 네임스페이스 } # root 생성 tax_invoice = etree.Element( \"TaxInvoice\", nsmap=NSMAP, attrib={ \"{%s}schemaLocation\" % XSI_NS: f\"{TAX_NS} http://www.kec.or.kr/standard/Tax/TaxInvoiceSchemaModule_1.0.xsd\", }, ) ### [element 순서 중요] ## \u003cExchangedDocument\u003e exchanged_doc = etree.SubElement(tax_invoice, \"ExchangedDocument\") 이후 정규화를 해야 한다. 필자는 함수를 만들어서 사용했다. 정규화 방식은 표준지침에 명시되어있고 그 방법대로 해야 한다. ​ from lxml import etree def canonicalize(xml_str, input_type: str) -\u003e bytes: parser = etree.XMLParser() root = etree.fromstring(xml_str, parser=parser) c14n_bytes = etree.tostring( root, method=\"c14n\", # Canonical XML ) return c14n_bytes ​ 2-2 XML 전자서명 여기서부터는 java 라이브러리들을 사용한다. python의 구조를 먼저 보자면, # import SignXML = jpype.JClass(\"com.barostudio.eTaxInvoice.SignXML\") # 03. 서명된 XML 생성 signed_bytes = SignXML.sign( bytearray(canonicalized_etax), # XML bytes seller_private_key_java, seller_x509_certificate_cert_java, ) 여기서. seller_private_key_java와 seller_x509_certificate_cert_java는 공급한 자의 인증서 정보를 넣으면 된다. 공급한 자의 인증서 정보를 추출함에 있어 front와 back 두 곳에서 추출해야 했기에 javascript와 python 둘 다 인증서를 열어보는 코드를 만들었다. 인증서에서 pem 키들은 상대적으로 쉽게 꺼낼 수 있는데, Rvalue는 생각보다 애먹었다. python은 subprocess를 써서, javascript는 node-forge를 써서 찾을 수 있었다. 이후 암호화를 하는데 서명하는 것은 java를 사용했다. (사실 이 부분은 단일 언어로도 할 수 있었을 것 같다.) SignXML.java package com.barostudio.eTaxInvoice; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import java.security.KeyStore; import java.security.PrivateKey; import java.security.Security; import java.security.Signature; import java.security.cert.X509Certificate; import java.util.Enumeration; import javax.xml.crypto.dsig.DigestMethod; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.apache.xml.security.signature.XMLSignature; import org.apache.xml.security.transforms.Transforms; import org.apache.xml.security.utils.Constants; import org.apache.xml.security.utils.XMLUtils; import org.apache.xpath.XPathAPI; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; // import org.apache.xml.security.c14n.Canonicalizer; public class SignXML { public static byte[] sign( byte[] unsignedXmlBytes, PrivateKey privateKey, X509Certificate cert ) throws Exception { // 메모리 기반 처리 try (InputStream is = new ByteArrayInputStream(unsignedXmlBytes); ByteArrayOutputStream os = new ByteArrayOutputStream()) { // 서명 수행 signn(privateKey, cert, is, os); return os.toByteArray(); } } public static void signn( PrivateKey privateKey, X509Certificate cert, InputStream is, OutputStream os ) throws Exception { org.apache.xml.security.Init.init(); // Document // 입력 스트림에서 XML을 읽어 DOM(Document Object Model) 객체로 파싱 DocumentBuilderFactory dbf = DocumentBuilderFactory","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_01/:1:2","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.1","uri":"https://colinder.github.io/etax_process_01/"},{"categories":null,"content":"뒤에 계속 혼자 여기까지 오는데 꽤 오랜 시간이 걸렸다. 다양한 사유가 있지만, 인증서 정보 추출, python과 java를 같이 사용하다보니 타입의 변환에도 신경쓸 것이 많았고, 표준지침에 있는 예시의 구조를 세심히 봐야 하는 점.. 등이 어려웠다. 하지만 개발이 그러하듯 성공하고 보면 별거 아닌 것 같다. ​ ​ ​ ","date":"2026-01-19","objectID":"https://colinder.github.io/etax_process_01/:2:0","tags":["etax","hometax"],"title":"전자(세금)계산서 발급 api 개발기 part.1","uri":"https://colinder.github.io/etax_process_01/"},{"categories":["REST","api","면접대비"],"content":"​ REST ful API RESTful API는 Representational State Transfer(표현 상태 전이)를 기반으로 하는 웹 서비스의 설계 원칙을 따르는 API입니다. REST는 분산 시스템에서 리소스 간 상태 전이를 위한 아키텍처 스타일로, 간결하고 확장 가능한 디자인을 제공합니다. RESTful API는 HTTP를 통해 자원을 나타내고 상호 작용하는 방식을 규정하며, REST의 기본 원칙을 따라야 합니다. ​ RESTful API의 주요 특징과 원칙은 다음과 같습니다: 자원 (Resource): 모든 것을 리소스로 표현합니다. 각 리소스는 고유한 식별자(URI)를 가지며, 이를 통해 리소스에 접근합니다. 예를 들어, 사용자, 제품, 주문 등이 리소스가 될 수 있습니다. 표현 (Representation): 리소스의 상태는 여러 형태로 표현될 수 있습니다. JSON 또는 XML 형식의 데이터로 표현되며, 클라이언트와 서버 간의 통신에서 이러한 표현이 교환됩니다. 무상태 (Stateless): 각 요청은 클라이언트의 상태를 서버에 저장하지 않고, 모든 필요한 정보를 요청 자체에 포함하여 처리합니다. 이러한 상태 전이는 시스템의 확장성과 성능을 향상시킵니다. 통일된 인터페이스 (Uniform Interface): RESTful API는 통일된 인터페이스를 가지며, 이를 통해 일관성을 유지합니다. 통일된 인터페이스에는 리소스 식별, 메시지 교환을 위한 표준 연산, 자원의 표현을 위한 하이퍼미디어 등이 포함됩니다. 무계층 아키텍처 (Layered System): 클라이언트와 서버 사이에는 계층화된 구조를 가질 수 있습니다. 이는 시스템의 확장성과 유연성을 높이는 데 도움이 됩니다. 캐싱 (Caching): 클라이언트는 서버로부터 받은 응답을 캐싱할 수 있습니다. 이는 서버 부하를 감소시키고 네트워크 성능을 향상시킵니다. ​ RESTful API는 이러한 원칙을 따라 설계되며, 이를 통해 클라이언트와 서버 간의 효율적이고 일관된 통신이 가능해집니다. 대부분의 웹 서비스와 마이크로서비스 아키텍처에서 RESTful API가 널리 사용되고 있습니다. ​ ​ ​ ​ ","date":"2024-01-31","objectID":"https://colinder.github.io/restapi/:0:0","tags":["REST","api"],"title":"what is REST api?","uri":"https://colinder.github.io/restapi/"},{"categories":null,"content":"​ 데코레이터를 사용하는 이유와 장점 데코레이터는 코드에 메타데이터를 첨부하고, 이를 기반으로 코드를 변형하거나 행동을 추가하는 강력한 도구입니다. ​ 여러 이유로 데코레이터를 사용할 수 있지만 주된 이점은 다음과 같습니다: 메타프로그래밍(Metaprogramming): 데코레이터를 사용하면 코드에 대한 정보를 주석(annotation)으로 첨부할 수 있습니다. 이 메타데이터를 기반으로 코드를 동적으로 변형하거나 특정 동작을 추가할 수 있습니다. 가독성과 모듈성 향상: 데코레이터를 사용하면 코드를 더 읽기 쉽게 만들 수 있습니다. 특히 프레임워크나 라이브러리에서 자주 사용되는 패턴이나 행동을 명시적으로 표현할 수 있습니다. 코드 재사용 및 중복 제거: 데코레이터를 사용하면 여러 곳에서 반복되는 코드를 중앙에서 관리하고 재사용할 수 있습니다. 이는 코드의 중복을 방지하고 유지보수성을 향상시킵니다. 분리된 관심사(Separation of Concerns): 데코레이터를 사용하면 다양한 관심사를 분리하고 각 관심사에 맞게 모듈화할 수 있습니다. 이는 높은 응집도와 낮은 결합도를 유지하는 데 도움이 됩니다. 프레임워크 및 라이브러리 확장성: 많은 프레임워크와 라이브러리에서 데코레이터를 사용하여 확장성을 제공합니다. 사용자가 특정 기능을 확장하거나 변경할 때, 데코레이터를 이용하여 프레임워크 또는 라이브러리의 동작을 쉽게 수정할 수 있습니다. ​ 이러한 이유로 데코레이터는 코드의 품질을 향상시키고, 유지보수성을 높이며, 확장성을 강화하는 데 중요한 역할을 합니다. ​ ​ ​ ​ ","date":"2024-01-31","objectID":"https://colinder.github.io/decorator/:0:0","tags":["decorator"],"title":"why use a decorator? And what's the benefit?","uri":"https://colinder.github.io/decorator/"},{"categories":["Nest"],"content":"​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:0:0","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Guards 가드(Guard)는 라우트 핸들러 메서드의 실행 여부를 결정하는 역할을 합니다. 특히, 가드는 특정 조건이 충족되지 않으면 요청을 처리하기 전에 실행을 막습니다. 이는 권한 검사, 인증, 혹은 다양한 비즈니스 규칙을 적용할 때 유용합니다. 간단한 예로, 사용자의 권한을 확인하는 가드를 상상해볼 수 있습니다. 특정 엔드포인트에 접근하려는 사용자의 역할이나 권한이 충족되지 않으면 가드가 요청을 차단할 수 있습니다. 이를 통해 요청이 핸들러 메서드에 도달하기 전에 필요한 조건을 검사하고 처리할 수 있습니다. 가드는 @Injectable() 데코레이터로 주석이 달린 클래스로, CanActivate 인터페이스를 구현합니다. 가드(Guards)는 단일 책임을 가지고 있습니다. 특정 조건(권한, 역할, ACL(access control list; 접근 제어 목록) 등)이 실행 시점에 존재하는지 여부에 따라 주어진 요청이 라우트 핸들러에 의해 처리될지 여부를 결정합니다. 이는 일반적으로 인가(authorization)로 언급되며 종종 인증(authentication)과 함께 작동합니다. 전통적인 Express 애플리케이션에서는 middleware를 통해 일반적으로 이러한 작업이 처리되었습니다. 미들웨어는 토큰 유효성 검사 및 request 객체에 속성을 추가하는 것과 같은 작업이 특정 라우트 컨텍스트(및 해당 메타데이터)와 강하게 연결되어 있지 않기 때문에 인증에 대한 좋은 선택입니다. 그러나 미들웨어는 본질적으로 무지합니다. next() 함수를 호출한 후에 어떤 핸들러가 실행될지를 알지 못합니다. 반면에 가드는 ExecutionContext 인스턴스에 액세스할 수 있으며 따라서 정확히 다음에 실행될 것을 알고 있습니다. 이들은 예외 필터, 파이프, 인터셉터와 마찬가지로 요청/응답 주기에서 처리 로직을 정확한 지점에 삽입하고 선언적으로 수행할 수 있도록 설계되었습니다. 이는 코드를 DRY(Don’t Repeat Yourself)하고 선언적으로 유지하는 데 도움이 됩니다. HINT Guards are executed after all middleware, but before any interceptor or pipe. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:0","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Authorization guard# 언급한 대로 권한 부여는 가드의 좋은 사용 사례입니다. 특정 라우트는 호출자(일반적으로 특정 인증된 사용자)가 충분한 권한을 가질 때만 사용 가능해야 합니다. 이제 구축할 AuthGuard는 인증된 사용자를 가정하고 (따라서 토큰이 요청 헤더에 첨부되어 있다고 가정합니다) 토큰을 추출하고 유효성을 검사한 다음 추출된 정보를 사용하여 요청이 계속 진행할 수 있는지 여부를 결정합니다. //auth.guard.ts import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { const request = context.switchToHttp().getRequest(); return validateRequest(request); } } HINT 만약 애플리케이션에 인증 메커니즘을 구현하는 실제 예제를 찾고 있다면, 이 장을 참조하세요. 마찬가지로 더 정교한(sophisticated ) 권한 부여 예제를 원한다면 이 페이지를 확인하세요. validateRequest() 함수 내부의 로직은 필요에 따라 간단하거나 복잡할 수 있습니다. 이 예제의 주요 포인트는 가드가 요청/응답 주기에 어떻게 맞아 떨어지는지를 보여주는 것입니다. 모든 가드는 canActivate() 함수를 구현해야 합니다. 이 함수는 현재 요청이 허용되는지 여부를 나타내는 boolean 값을 반환해야 합니다. 이 함수는 동기적으로 또는 비동기적으로 (Promise나 Observable을 통해) 응답을 반환할 수 있습니다. Nest는 반환된 값을 사용하여 다음 동작을 제어합니다: true를 반환하면 요청이 처리됩니다. false를 반환하면 Nest는 요청을 거부합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:1","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Execution context# canActivate() 함수는 단일 인수인 ExecutionContext 인스턴스를 받습니다. ExecutionContext는 ArgumentsHost에서 상속됩니다. 이전에 예외 필터 챕터에서 ArgumentsHost를 보았습니다. 위의 예제에서는 이전에 사용한 것과 동일한 ArgumentsHost에서 정의된 도우미 메서드를 사용하여 Request 객체에 대한 참조를 가져 오고 있습니다. 이 주제에 대한 자세한 내용은 exception filters 챕터의 Arguments host 섹션을 참조할 수 있습니다. ExecutionContext는 ArgumentsHost를 확장함으로써 현재 실행 프로세스에 대한 추가적인 세부 정보를 제공하는 여러 개의 새로운 도우미 메서드를 추가합니다. 이러한 세부 정보는 더 일반적인 가드를 작성할 때 도움이 될 수 있으며 이 가드는 다양한 컨트롤러, 메서드 및 실행 컨텍스트 집합에서 작동할 수 있습니다. ExecutionContext에 대한 자세한 내용은 여기에서 확인할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:2","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Role-based authentication# 특정 역할을 가진 사용자만 액세스를 허용하는 더 기능적인 가드를 만들어보겠습니다. 기본 가드 템플릿에서 시작하고 이후 섹션에서 이를 확장해 나갈 것입니다. 현재는 모든 요청을 허용하는 기본적인 구조입니다: //roles.guard.ts import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() export class RolesGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { return true; } } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:3","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Binding guards# 파이프와 예외 필터와 마찬가지로 가드는 컨트롤러 범위(controller-scoped), 메서드 범위, 또는 전역 범위로 설정할 수 있습니다. 아래에서는 @UseGuards() 데코레이터를 사용하여 컨트롤러 범위의 가드를 설정합니다. 이 데코레이터는 단일 인수나 쉼표로 구분된 인수 목록을 받을 수 있습니다. 이를 통해 하나의 선언으로 적절한 가드 집합을 쉽게 적용할 수 있습니다. @Controller('cats') @UseGuards(RolesGuard) export class CatsController {} HINT The @UseGuards() decorator is imported from the @nestjs/common package. 위에서는 인스턴스 대신 RolesGuard 클래스를 전달하여 인스턴스화 책임을 프레임워크에게 맡기고 의존성 주입을 활성화했습니다. 파이프와 예외 필터와 마찬가지로 인스턴스를 직접 전달할 수도 있습니다: @Controller('cats') @UseGuards(new RolesGuard()) export class CatsController {} 위의 구성은 이 컨트롤러에서 선언된 모든 핸들러에 가드를 연결합니다. 가드를 하나의 메서드에만 적용하려면 @UseGuards() 데코레이터를 메서드 레벨에서 적용합니다. 전역 가드를 설정하려면 Nest 애플리케이션 인스턴스의 useGlobalGuards() 메서드를 사용하세요: //main.ts const app = await NestFactory.create(AppModule); app.useGlobalGuards(new RolesGuard()); NOTICE 하이브리드 앱의 경우 useGlobalGuards() 메서드는 기본적으로 게이트웨이 및 마이크로 서비스에 가드를 설정하지 않습니다. (이 동작을 변경하는 방법에 대한 정보는 Hybrid application을 참조하세요.) “표준” (비-하이브리드) 마이크로서비스 앱의 경우 useGlobalGuards()는 가드를 전역으로 마운트합니다. 전역 가드는 전체 애플리케이션, 모든 컨트롤러 및 모든 라우트 핸들러에 걸쳐 사용됩니다. 의존성 주입 측면에서 모듈 외부에서 등록된 전역 가드 (useGlobalGuards()를 사용한 예제와 같이)는 어떤 모듈의 컨텍스트 외부에서 수행되므로 종속성을 주입할 수 없습니다. 이 문제를 해결하려면 다음 구성을 사용하여 모듈에서 직접 가드를 설정할 수 있습니다: //app.module.ts import { Module } from '@nestjs/common'; import { APP_GUARD } from '@nestjs/core'; @Module({ providers: [ { provide: APP_GUARD, useClass: RolesGuard, }, ], }) export class AppModule {} HINT 이 방법을 사용하여 가드에 대한 종속성 주입을 수행할 때 어떤 모듈에서 이 구성을 사용하든지 간에 이 가드는 사실상 전역입니다. 어디에서 이 작업을 수행해야 할까요? 가드 (RolesGuard는 위의 예제에서와 같이)가 정의된 모듈을 선택하세요. 또한, useClass는 사용자 정의 공급자 등록을 다루는 유일한 방법이 아닙니다. 여기에서 자세히 알아보세요. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:4","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Setting roles per handler# RolesGuard가 작동하지만 아직 충분히 스마트하지 않습니다. 가장 중요한 가드 기능 중 하나인 실행 컨텍스트를 아직 활용하고 있지 않습니다. 아직 역할이나 각 핸들러에 대한 허용된 역할에 대한 정보를 알지 못합니다. 예를 들어 CatsController는 다른 라우트에 대해 다른 권한 체계를 가질 수 있습니다. 어떤 라우트는 관리자 사용자만 사용할 수 있고 다른 라우트는 모두에게 열려 있을 수 있습니다. 어떻게 역할을 유연하고 재사용 가능한 방식으로 라우트에 매핑할 수 있을까요? 여기서 사용자 정의 메타데이터가 등장합니다 (여기에서 더 알아보세요). Nest는 Reflector#createDecorator 정적 메서드를 통해 생성된 데코레이터 또는 내장된 @SetMetadata() 데코레이터를 통해 라우트 핸들러에 사용자 정의 메타데이터를 첨부할 수 있는 기능을 제공합니다. 예를 들어 Reflector#createDecorator 메서드를 사용하여 핸들러에 메타데이터를 첨부할 @Roles() 데코레이터를 만들어봅시다. Reflector는 프레임워크에서 기본적으로 제공되며 @nestjs/core 패키지에서 노출됩니다. //roles.decorator.ts import { Reflector } from '@nestjs/core'; export const Roles = Reflector.createDecorator\u003cstring[]\u003e(); The Roles decorator here is a function that takes a single argument of type string[]. Now, to use this decorator, we simply annotate the handler with it: //cats.controller.ts @Post() @Roles(['admin']) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } 여기서는 create() 메서드에 Roles 데코레이터 메타데이터를 첨부했습니다. 이는 해당 라우트에는 admin 역할을 가진 사용자만 액세스할 수 있어야 함을 나타냅니다. 대신에 Reflector#createDecorator 메서드 대신 내장된 @SetMetadata() 데코레이터를 사용할 수도 있습니다. 여기에서 더 자세히 알아보세요. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:5","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Putting it all together# 이제 RolesGuard와 함께 이를 연결해 보겠습니다. 현재 RolesGuard는 모든 경우에 true를 반환하여 모든 요청을 진행시킵니다. 우리는 현재 사용자에게 할당된 역할을 현재 처리 중인 라우트에서 필요로 하는 실제 역할과 비교하여 반환 값을 조건부로 만들고 싶습니다. 라우트의 역할(사용자 정의 메타데이터)에 액세스하려면 다시 Reflector 도우미 클래스를 사용하겠습니다. 아래와 같이: //roles.guard.ts import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Reflector } from '@nestjs/core'; import { Roles } from './roles.decorator'; @Injectable() export class RolesGuard implements CanActivate { constructor(private reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { const roles = this.reflector.get(Roles, context.getHandler()); if (!roles) { return true; } const request = context.switchToHttp().getRequest(); const user = request.user; return matchRoles(roles, user.roles); } } HINT Node.js 세계에서는 흔히 권한이 부여된 사용자를 request 객체에 첨부하는 것이 일반적입니다. 따라서 위의 샘플 코드에서는 request.user가 사용자 인스턴스와 허용된 역할을 포함하고 있다고 가정하고 있습니다. 여러분의 앱에서는 이러한 연관성을 사용자 정의 인증 가드나 미들웨어에서 설정할 것으로 예상됩니다. 이 주제에 대한 자세한 정보는 이 장을 참조하세요. WARNING\rmatchRoles() 함수 내의 로직은 필요에 따라 간단하거나 복잡하게 구성할 수 있습니다. 이 예제의 주요 목적은 가드가 요청/응답 주기에 어떻게 적합한지를 보여주는 것입니다.\rReflector를 컨텍스트에 맞게 활용하는 방법에 대한 자세한 내용은 Execution context 장의 Reflection and metadata 섹션을 참조하십시오. 권한이 부족한 사용자가 엔드포인트를 요청하면 Nest는 자동으로 다음과 같은 응답을 반환합니다: { \"statusCode\": 403, \"message\": \"Forbidden resource\", \"error\": \"Forbidden\" } Note that behind the scenes, 가드가 false를 반환하면 프레임워크가 ForbiddenException을 throw합니다. 다른 오류 응답을 반환하려면 자신만의 특정 예외를 던져야 합니다. 예를 들면: throw new UnauthorizedException(); 가드에서 throw된 예외는 예외 레이어 에서 처리됩니다.(전역 예외 필터 및 현재 컨텍스트에 적용된 모든 예외 필터) HINT If you are looking for a real-world example on how to implement authorization, check this chapter. ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:1:6","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Interceptors 인터셉터는 요청과 응답 처리의 중간에 위치하여, 해당 요청 및 응답을 수정하거나 변형할 수 있는 클래스입니다. 인터셉터는 특정 기능을 추상화하고 재사용 가능한 비즈니스 로직을 캡슐화하는 데 사용됩니다. 인터셉터는 주로 다음과 같은 작업을 수행할 수 있습니다: 전처리 및 후처리 작업: 요청이나 응답을 처리하기 전이나 후에 특정 작업을 수행할 수 있습니다. 예를 들어, 데이터 로깅, 트래킹, 또는 요청/응답 수정 등이 가능합니다. 예외 처리: 요청 또는 응답 중에 예외가 발생하면 인터셉터에서 해당 예외를 처리하고 특정한 형태로 응답을 조작할 수 있습니다. 캐싱: 일부 요청의 결과를 캐싱하여 성능을 향상시킬 수 있습니다. 트랜스포메이션: 요청이나 응답을 필요에 따라 변환하거나 가공할 수 있습니다. 권한 검사: 특정한 권한을 가진 사용자만이 특정한 요청에 접근할 수 있도록 제어할 수 있습니다. 인터셉터는 모듈, 컨트롤러, 메서드 수준에서 적용될 수 있으며, 각각의 인터셉터는 특정한 용도에 맞게 설계될 수 있습니다. 인터셉터는 @Injectable() 데코레이터로 주석이 달린 클래스이며 NestInterceptor 인터페이스를 구현하는 클래스입니다. 인터셉터는 Aspect Oriented Programming (AOP) 기법에서 영감을 받은 유용한 기능을 제공합니다. 이를 통해 다음과 같은 작업이 가능해집니다: 메서드 실행 전/후에 추가 로직 바인딩 함수에서 반환된 결과를 변환 함수에서 발생한 예외를 변환 기본 함수 동작 확장 특정 조건에 따라 함수 완전히 재정의 (예: 캐싱 목적) ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:0","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Basics# 각 인터셉터는 두 개의 인자를 받는 intercept() 메소드를 구현합니다. 첫 번째 인자는 ExecutionContext 인스턴스로 가드에서 사용되는 것과 동일한 객체입니다. ExecutionContext는 ArgumentsHost에서 상속됩니다. 우리는 이전에 예외 필터 챕터에서 ArgumentsHost를 보았습니다. 거기에서 원래 핸들러에 전달된 인자를 래핑하고 응용 프로그램의 유형에 따라 다른 인자 배열을 포함한다는 것을 알았습니다. 이 주제에 대한 자세한 내용은 예외 필터를 참조할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:1","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Execution context# ExecutionContext는 ArgumentsHost를 확장함으로써 현재 실행 프로세스에 대한 추가적인 세부 정보를 제공하는 여러 개의 헬퍼 메서드를 추가합니다. 이러한 세부 정보는 더 일반적인 인터셉터를 작성할 때 도움이 될 수 있으며, 이 인터셉터는 다양한 컨트롤러, 메서드 및 실행 컨텍스트에서 작동할 수 있습니다. ExecutionContext에 대한 더 자세한 내용은 여기에서 확인할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:2","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Call handler# 두 번째 인수는 CallHandler입니다. CallHandler 인터페이스는 interceptor에서 라우트 핸들러 메서드를 어느 시점에서든 호출할 수 있도록 handle() 메서드를 구현합니다. intercept() 메서드에서 handle() 메서드를 호출하지 않으면 라우트 핸들러 메서드가 전혀 실행되지 않습니다. 이 접근 방식은 intercept() 메서드가 요청/응답 스트림을 효과적으로 랩한다는 것을 의미합니다. 그리고 최종 라우트 핸들러 실행 전후에 사용자 정의 로직을 사용하고 싶을 수도 있습니다. intercept() 메서드에서 handle()을 호출하기 전에 코드를 작성하는 것은 명확하지만, 이후에 어떻게 영향을 미칠 수 있을까요? handle() 메서드는 Observable을 반환하므로 RxJS 연산자를 사용하여 응답을 추가로 조작할 수 있습니다. Aspect Oriented Programming 용어를 사용하면 라우트 핸들러를 호출하는 것(즉, handle()을 호출하는 것)은 Pointcut이라고 하며, 여기에 추가로직이 삽입되는 지점을 나타냅니다. 예를 들어, 들어오는 POST /cats 요청이 있습니다. 이 요청은 CatsController 내에 정의된 create() 핸들러를 대상으로 합니다. handle() 메서드를 호출하지 않는 인터셉터가 코드 중간 어디에서든(along the way) 사용되면 create() 메서드가 실행되지 않습니다. handle()이 호출되면 (그리고 그 Observable이 반환된 후에), create() 핸들러가 트리거됩니다. 그리고 Observable을 통해 수신한 응답 스트림을 사용하여 추가 작업을 수행하고 최종 결과를 호출자에게 반환할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:3","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Aspect interception# 첫 번째 사용 사례는 인터셉터를 사용하여 사용자 상호 작용을 기록하는 것입니다. 예를 들어 사용자 호출을 저장하거나 이벤트를 비동기적으로 디스패치하거나 타임스탬프를 계산하는 등의 상호 작용을 기록하는 간단한 LoggingInterceptor를 아래에 표시합니다: //logging.interceptor.ts import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'; import { Observable } from 'rxjs'; import { tap } from 'rxjs/operators'; @Injectable() export class LoggingInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { console.log('Before...'); const now = Date.now(); return next .handle() .pipe( tap(() =\u003e console.log(`After... ${Date.now() - now}ms`)), ); } } HINT The NestInterceptor\u003cT, R\u003e is a generic interface in which T indicates the type of an Observable\u003cT\u003e (supporting the response stream), and R is the type of the value wrapped by Observable\u003cR\u003e. NOTICE 인터셉터는 컨트롤러, 프로바이더, 가드 등과 마찬가지로 constructor를 통해 의존성을 주입할 수 있습니다. handle()가 RxJS Observable을 반환하기 때문에 우리는 스트림을 조작하기 위해 다양한 오퍼레이터를 선택할 수 있습니다. 위의 예제에서는 tap() 오퍼레이터를 사용했는데, 이는 우리의 익명 로깅 함수를 옵저버블 스트림이 정상적이거나 예외적으로 종료될 때 호출하지만 그 외에는 응답 주기에 간섭하지 않습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:4","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Binding interceptors# 인터셉터를 설정하기 위해서는 @nestjs/common 패키지에서 가져온 @UseInterceptors() 데코레이터를 사용합니다. 파이프와 가드와 마찬가지로 인터셉터는 컨트롤러 범위, 메서드 범위 또는 글로벌 범위로 설정할 수 있습니다. //cats.controller.ts @UseInterceptors(LoggingInterceptor) export class CatsController {} HINT The @UseInterceptors() decorator is imported from the @nestjs/common package. 위의 구조를 사용하면 CatsController에 정의된 각 라우트 핸들러는 LoggingInterceptor를 사용합니다. 누군가 GET /cats 엔드포인트를 호출하면 표준 출력에서 다음과 같은 출력을 볼 수 있습니다: Before... After... 1ms 앞서 언급한 대로 LoggingInterceptor 타입을 전달하여 (인스턴스 대신에) 프레임워크에 인스턴스화 책임을 맡기고 의존성 주입을 활성화했습니다. 파이프, 가드, 예외 필터와 마찬가지로 현장에서 직접 인스턴스를 전달할 수도 있습니다: //cats.controller.ts @UseInterceptors(new LoggingInterceptor()) export class CatsController {} 앞서 언급했듯이 위의 구성은 이 인터셉터를 이 컨트롤러에서 선언된 모든 핸들러에 첨부합니다. 인터셉터의 범위를 단일 메서드로 제한하려면 데코레이터를 메서드 레벨에서 적용하면 됩니다. 전역 인터셉터를 설정하려면 Nest 애플리케이션 인스턴스의 useGlobalInterceptors() 메서드를 사용합니다: //main.ts const app = await NestFactory.create(AppModule); app.useGlobalInterceptors(new LoggingInterceptor()); 전역 인터셉터는 전체 애플리케이션에서 모든 컨트롤러와 라우트 핸들러에 사용됩니다. 의존성 주입 측면에서 위 예제와 같이 외부에서 useGlobalInterceptors()를 사용하여 등록한 전역 인터셉터는 어떤 모듈의 컨텍스트에서도 의존성을 주입할 수 없습니다. 이 문제를 해결하기 위해 다음 구성을 사용하여 모듈에서 직접 인터셉터를 설정할 수 있습니다: //app.module.ts import { Module } from '@nestjs/common'; import { APP_INTERCEPTOR } from '@nestjs/core'; @Module({ providers: [ { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor, }, ], }) export class AppModule {} HINT 이 접근 방식을 사용하여 인터셉터에 대한 의존성 주입을 수행할 때, 이 구성이 적용된 모듈과 관계없이 해당 인터셉터는 사실상 전역적입니다. 어디에서 이 작업을 수행해야 할까요? 위의 예제에서 나온대로 인터셉터가 정의된 모듈을 선택하세요. 또한, useClass는 사용자 정의 제공자 등록을 다루는 유일한 방법이 아닙니다. 더 자세한 내용은 여기에서 알아보세요. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:5","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Response mapping# 우리는 이미 handle()이 Observable을 반환한다는 것을 알고 있습니다. 이 스트림에는 route handler에서 반환된 값이 포함되어 있으므로 RxJS의 map() 연산자를 사용하여 쉽게 변형할 수 있습니다. WARNING\r매핑 기능은 라이브러리별 응답 전략과 함께 작동하지 않습니다 (@Res() 객체를 직접 사용하는 것은 금지).\r다음은 TransformInterceptor를 만들어보겠습니다. 이 인터셉터는 간단한 방식으로 각 응답을 수정하여 프로세스를 보여줍니다. RxJS의 map() 연산자를 사용하여 응답 객체를 새로 생성된 객체의 data 속성에 할당하고, 이 새로운 객체를 클라이언트에 반환합니다. //transform.interceptor.ts import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; export interface Response\u003cT\u003e { data: T; } @Injectable() export class TransformInterceptor\u003cT\u003e implements NestInterceptor\u003cT, Response\u003cT\u003e\u003e { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cResponse\u003cT\u003e\u003e { return next.handle().pipe(map(data =\u003e ({ data }))); } } HINT Nest 인터셉터는 동기 및 비동기 intercept() 메서드와 함께 작동합니다. 필요한 경우 메서드를 async로 전환할 수 있습니다. 위의 구성으로 누군가 GET /cats 엔드포인트를 호출하면, 응답은 다음과 같을 것입니다 (루트 핸들러가 빈 배열 []을 반환하는 경우를 가정합니다): { \"data\": [] } 인터셉터는 전체 애플리케이션에 걸쳐 발생하는 요구 사항에 대한 재사용 가능한 솔루션을 만드는 데 큰 가치가 있습니다. 예를 들어 null 값을 빈 문자열 ''로 변환해야 하는 경우를 상상해보세요. 한 줄의 코드로 이를 수행하고 인터셉터를 전역으로 바인딩하여 각 등록된 핸들러에서 자동으로 사용하도록 설정할 수 있습니다. import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; @Injectable() export class ExcludeNullInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { return next .handle() .pipe(map(value =\u003e value === null ? '' : value )); } } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:6","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Exception mapping# 또 다른 흥미로운 사용 사례는 RxJS의 catchError() 연산자를 활용하여 던져진 예외를 재정의하는 것입니다. //errors.interceptor.ts import { Injectable, NestInterceptor, ExecutionContext, BadGatewayException, CallHandler, } from '@nestjs/common'; import { Observable, throwError } from 'rxjs'; import { catchError } from 'rxjs/operators'; @Injectable() export class ErrorsInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { return next .handle() .pipe( catchError(err =\u003e throwError(() =\u003e new BadGatewayException())), ); } } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:7","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Stream overriding# 핸들러 호출을 완전히 방지하고 대신에 다른 값을 반환하는 이유가 몇 가지 있습니다. 명백한 예로 응답 시간을 개선하기 위해 캐시를 구현하는 것이 있습니다. 캐시에서 응답을 반환하는 간단한 캐시 인터셉터를 살펴보겠습니다. 현실적인 예제에서는 TTL, 캐시 무효화, 캐시 크기 등과 같은 다른 요소도 고려해야 합니다. 하지만 이것은 이 토론의 범위를 벗어납니다. 여기서는 주요 컨셉을 보여주는 기본적인 예제를 제공하겠습니다. //cache.interceptor.ts import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common'; import { Observable, of } from 'rxjs'; @Injectable() export class CacheInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { const isCached = true; if (isCached) { return of([]); } return next.handle(); } } 우리의 CacheInterceptor에는 하드코딩된 isCached 변수와 하드코딩된 응답 []이 있습니다. 주목해야 할 중요한 점은 RxJS의 of() 연산자에 의해 여기서 생성된 새로운 스트림을 반환하므로 라우트 핸들러는 전혀 호출되지 않을 것입니다. CacheInterceptor를 사용하는 엔드포인트를 호출하면 응답(하드코딩된 빈 배열)이 즉시 반환됩니다. 일반적인 솔루션을 만들려면 Reflector를 활용하여 사용자 정의 데코레이터를 만들 수 있습니다. Reflector는 guards 챕터에서 잘 설명되어 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:8","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"More operators# RxJS 연산자를 사용하여 스트림을 조작할 수 있는 가능성은 많은 기능을 제공합니다. 또 다른 일반적인 사용 사례를 살펴보겠습니다. 엔드포인트가 일정 시간이 지나서 아무것도 반환하지 않는 경우에, 에러를 반환 하고 싶을 것입니다. 다음 구성은 이를 가능하게 합니다. //timeout.interceptor.ts import { Injectable, NestInterceptor, ExecutionContext, CallHandler, RequestTimeoutException } from '@nestjs/common'; import { Observable, throwError, TimeoutError } from 'rxjs'; import { catchError, timeout } from 'rxjs/operators'; @Injectable() export class TimeoutInterceptor implements NestInterceptor { intercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e { return next.handle().pipe( timeout(5000), catchError(err =\u003e { if (err instanceof TimeoutError) { return throwError(() =\u003e new RequestTimeoutException()); } return throwError(() =\u003e err); }), ); }; }; 5초 후에 요청 처리가 취소됩니다. RequestTimeoutException을 throw하기 전에 사용자 지정 논리를 추가할 수도 있습니다(예: 리소스 해제). ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:2:9","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Custom route decorators Nest는 데코레이터라는 언어 기능을 중심으로 구축되었습니다. 데코레이터는 많은 일반적으로 사용되는 프로그래밍 언어에서 잘 알려진 개념이지만 JavaScript 세계에서는 여전히 비교적 새로운 개념입니다. 데코레이터 작동 방식을 더 잘 이해하기 위해 이 기사를 읽는 것이 좋습니다. 여기에 간단한 정의가 있습니다: ES2016(ES7) 데코레이터는 함수를 반환하는 표현식으로, 대상(target), 이름(name), 및 속성 기술자(property descriptor)를 인수로 받을 수 있습니다. 데코레이터를 적용하려면 데코레이터를 @ 문자로 접두사로 붙이고 이를 꾸며주려는 대상의 맨 위에 배치하면 됩니다. 데코레이터는 클래스, 메서드 또는 속성에 대해 정의할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:3:0","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Param decorators# Nest는 HTTP 라우트 핸들러와 함께 사용할 수 있는 유용한 파라미터 데코레이터 세트를 제공합니다. 아래는 제공되는 데코레이터와 해당하는 일반적인 Express (또는 Fastify) 객체의 목록입니다. @Request(), @Req() req @Response(), @Res() res @Next() next @Session() req.session @Param(param?: string) req.params / req.params[param] @Body(param?: string) req.body / req.body[param] @Query(param?: string) req.query / req.query[param] @Headers(param?: string) req.headers / req.headers[param] @Ip() req.ip @HostParam() req.hosts 추가로 사용자는 자신만의 커스텀 데코레이터를 만들 수도 있습니다. 왜 이것이 유용할까요? node.js 세상에서는 요청 개체에 속성을 첨부하는 것이 일반적인 방법입니다. 그런 다음 각 라우터 핸들러에서 다음과 같은 코드를 사용하여 속성을 수동으로 추출합니다: const user = req.user; 코드를 더 읽기 쉽고 깔끔하게 만들기 위해 @User() 데코레이터를 만들고 모든 컨트롤러에서 코드를 재사용할 수 있습니다. //user.decorator.ts import { createParamDecorator, ExecutionContext } from '@nestjs/common'; export const User = createParamDecorator( (data: unknown, ctx: ExecutionContext) =\u003e { const request = ctx.switchToHttp().getRequest(); return request.user; }, ); Then, you can simply use it wherever it fits your requirements. @Get() async findOne(@User() user: UserEntity) { console.log(user); } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:3:1","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Passing data# 데코레이터의 동작이 어떤 조건에 따라 달라질 때 data 매개변수를 사용하여 데코레이터 팩토리 함수에 인수를 전달할 수 있습니다. 이러한 경우 중 하나는 요청 객체에서 키별로 속성을 추출하는 사용자 정의 데코레이터입니다. 예를 들어 인증 레이어가 요청을 유효성 검사하고 사용자 엔터티를 요청 객체에 첨부하는 경우, 인증된 요청에 대한 사용자 엔터티는 다음과 같을 수 있습니다: { \"id\": 101, \"firstName\": \"Alan\", \"lastName\": \"Turing\", \"email\": \"alan@email.com\", \"roles\": [\"admin\"] } 해당 예제에서는 키로 속성 이름을 받아 해당 값이 있으면 반환하고 (없으면 undefined 반환하거나 user 객체가 생성되지 않은 경우도 해당), 사용자 엔터티의 특정 속성을 추출하는 데코레이터를 정의합니다. //user.decorator.ts import { createParamDecorator, ExecutionContext } from '@nestjs/common'; export const User = createParamDecorator( (data: string, ctx: ExecutionContext) =\u003e { const request = ctx.switchToHttp().getRequest(); const user = request.user; return data ? user?.[data] : user; }, ); 다음은 컨트롤러에서 @User() 데코레이터를 사용하여 특정 속성에 액세스하는 방법의 예시입니다: @Get() async findOne(@User('firstName') firstName: string) { console.log(`Hello ${firstName}`); } 같은 데코레이터를 다른 키와 함께 사용하여 다양한 속성에 액세스할 수 있습니다. user 객체가 깊거나 복잡한 경우, 이렇게 함으로써 더 쉽고 가독성 있는 요청 핸들러를 구현할 수 있습니다. HINT TypeScript 사용자들을 위해 createParamDecorator\u003cT\u003e()가 제네릭임을 주목하세요. 이는 명시적으로 타입 안전성을 강제할 수 있음을 의미합니다. 예를 들어 createParamDecorator\u003cstring\u003e((data, ctx) =\u003e ...)와 같이 사용할 수 있습니다. 또는 팩토리 함수에서 매개변수 타입을 지정할 수도 있습니다. 예를 들어 createParamDecorator((data: string, ctx) =\u003e ...)와 같이 사용할 수 있습니다. 둘 다 생략하는 경우 data의 타입은 any가 됩니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:3:2","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Working with pipes# Nest는 사용자 정의된 매개 변수 데코레이터를 내장된 것들 (@Body(), @Param() 및 @Query())과 동일한 방식으로 처리합니다. 이는 사용자 정의 주석이 달린 매개 변수에 대해서도 파이프가 실행된다는 것을 의미합니다 (우리의 예제에서는 user 인자). 더 나아가 직접 사용자 정의 데코레이터에 파이프를 적용할 수도 있습니다: @Get() async findOne( @User(new ValidationPipe({ validateCustomDecorators: true })) user: UserEntity, ) { console.log(user); } HINT 주의: validateCustomDecorators 옵션을 true로 설정해야 합니다. ValidationPipe은 기본적으로 사용자 정의 데코레이터로 주석이 달린 인수를 유효성 검사하지 않습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:3:3","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"Decorator composition# Nest는 여러 데코레이터를 결합하는 데 사용할 수 있는 도우미 메서드를 제공합니다. 예를 들어 인증과 관련된 모든 데코레이터를 하나의 데코레이터로 결합하려면 다음 구조를 사용할 수 있습니다: //auth.decorator.ts import { applyDecorators } from '@nestjs/common'; export function Auth(...roles: Role[]) { return applyDecorators( SetMetadata('roles', roles), UseGuards(AuthGuard, RolesGuard), ApiBearerAuth(), ApiUnauthorizedResponse({ description: 'Unauthorized' }), ); } You can then use this custom @Auth() decorator as follows: @Get('users') @Auth('admin') findAllUsers() {} 이렇게 하면 한 번의 선언으로 네 개의 데코레이터가 모두 적용됩니다. WARNING @nestjs/swagger 패키지의 @ApiHideProperty() 데코레이터는 합성 가능하지 않으며 applyDecorators 함수와 제대로 작동하지 않을 것입니다. ​ ​ ​ ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/:3:4","tags":["Nest"],"title":"Nest Official_03_(Guards, Interceptors, Custom_decorators)","uri":"https://colinder.github.io/nest-official_03_guards-interceptors-custom_decorators/"},{"categories":["Nest"],"content":"​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:0:0","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Modules 모듈은 @Module() 데코레이터로 주석이 달린 클래스입니다. @Module() 데코레이터는 Nest가 애플리케이션 구조를 구성하는 데 사용하는 메타데이터를 제공합니다. 각 어플리케이션은 최소한 하나의 모듈, 루트 모듈을 가지고 있습니다. 루트 모듈은 Nest가 어플리케이션 그래프를 구축하는데 사용하는 시작점입니다. 어플리케이션 그래프는 Nest가 Modules 및 Providers 간의 관계와 의존성을 해결하는 데 사용하는 내부 데이터 구조입니다. 매우 작은 애플리케이션의 경우 이론적으로 루트 모듈만을 가질 수 있지만, 이는 일반적인 경우가 아닙니다. 모듈은 구성 요소를 효과적으로 구성하는 데 강력하게 권장되는 방법이며, 대부분의 애플리케이션에서는 각각이 밀접한 관련성을 가진 일련의 기능을 캡슐화하는 여러 모듈을 사용하는 결과로서의 아키텍처가 형성됩니다. @Module() 데코레이터는 모듈을 설명하는 속성들이 담긴 단일 객체를 인자로 받습니다. providers the providers that will be instantiated by the Nest injector and that may be shared at least across this module controllers the set of controllers defined in this module which have to be instantiated imports the list of imported modules that export the providers which are required in this module exports the subset of providers that are provided by this module and should be available in other modules which import this module. You can use either the provider itself or just its token (provide value) 기본적으로 모듈은 프로바이더를 캡슐화합니다. 이는 현재 모듈에 직접 속하지 않거나 가져온 모듈에서 내보내지지 않은 프로바이더를 주입하는 것이 불가능하다는 것을 의미합니다. 따라서 모듈에서 내보내는 프로바이더를 모듈의 공개 인터페이스 또는 API로 간주할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:0","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Feature modules# CatsController와 CatsService는 동일한 애플리케이션 도메인에 속합니다. 서로 밀접하게 관련되어 있기 때문에 이들을 feature module로 이동하는 것이 합리적입니다. feature module은 단순히 특정 기능에 관련된 코드를 조직하는 역할을 합니다. 코드를 조직하고 명확한 경계를 정의함으로써 복잡성을 관리하고 애플리케이션 또는 팀의 규모가 커짐에 따라 SOLID 원칙에 따라 개발하는 데 도움이 됩니다. 이를 구현하기 위해 CatsModule을 만듭니다. //cats/cats.module.ts import { Module } from '@nestjs/common'; import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; @Module({ controllers: [CatsController], providers: [CatsService], }) export class CatsModule {} HINT To create a module using the CLI, simply execute the $ nest g module cats command. 위에 우리는 cats.module.ts파일 안에 CatsModule을 정의하고, 이 모듈과 관련된 모든 것을 cats 디렉토리로 이동했습니다. 마지막으로 해야 할 일은 이 모듈을 루트 모듈(app.module.ts 파일에서 정의된 AppModule)에 가져오는 것입니다. // app.module.ts import { Module } from '@nestjs/common'; import { CatsModule } from './cats/cats.module'; @Module({ imports: [CatsModule], }) export class AppModule {} 이제 우리 폴더 구조는 아래와 같습니다. src └ cats └ dto └ create-cat.dto.ts └ interfaces └ cat.interface.ts └ cats.controller.ts └ cats.module.ts 👈 └ cats.service.ts app.module.ts main.ts ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:1","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Shared modules# Nest에서는 모듈이 기본적으로 싱글톤이며, 따라서 동일한 프로바이더 인스턴스를 여러 모듈 간에 손쉽게 공유할 수 있습니다. 모든 모듈은 자동적으로 공유된 모듈입니다. 한 번 생성되면 어떤 모듈안에서든지 재사용이 가능합니다. 여러 다른 모듈 간에 CatsService의 인스턴스를 공유하고자 한다면, 먼저 해당 모듈의 exports 배열에 CatsService 프로바이더를 추가하여 내보내야 합니다. 아래와 같이 작성됩니다: //cats.module.ts import { Module } from '@nestjs/common'; import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; @Module({ controllers: [CatsController], providers: [CatsService], exports: [CatsService] 👈 }) export class CatsModule {} 이제 CatsModule을 가져오는 모든 모듈은 CatsService에 접근할 수 있으며, 이를 가져오는 다른 모든 모듈과 동일한 인스턴스를 공유합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:2","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Module re-exporting# 위에서 볼 수 있듯이 모듈은 내부 프로바이더를 내보낼 수 있습니다. 또한, 가져온 모듈을 다시 내보낼 수도 있습니다. 아래 예시에서는 CommonModule이 CoreModule에 가져와지고 동시에 내보내져서, 이를 가져오는 다른 모듈에서 사용할 수 있게 됩니다. @Module({ imports: [CommonModule], exports: [CommonM odule], }) export class CoreModule {} ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:3","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Dependency injection# 모듈 클래스는 providers에게 주입할 수 있습니다.(e.g., for configuration purposes): // cats.module.ts import { Module } from '@nestjs/common'; import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; @Module({ controllers: [CatsController], providers: [CatsService], }) export class CatsModule { constructor(private catsService: CatsService) {} } 그러나 모듈 클래스 자체는 원형 의존성(circular dependency)으로 인해 프로바이더로 주입될 수 없습니다 ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:4","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Global modules# 만약 항상 동일한 모듈 세트를 어디서나 가져와야 하는 경우 번거로워질 수 있습니다. Nest에서 Angular와 달리 providers는 전역 범위에 등록되지 않습니다. 한 번 정의되면 해당 providers는 어디에서나 사용 가능합니다. 그러나 Nest는 providers를 모듈 스코프 내에 캡슐화합니다. 캡슐화된 모듈을 가져오지 않고는 해당 모듈의 providers를 다른 곳에서 사용할 수 없습니다. 만약 어디서나 사용 가능한 프로바이더 집합을 제공하려면 (예: 헬퍼, 데이터베이스 연결 등) 모듈에 @Global() 데코레이터를 사용하여 전역으로 설정하세요. import { Module, Global } from '@nestjs/common'; import { CatsController } from './cats.controller'; import { CatsService } from './cats.service'; @Global() 👈 @Module({ controllers: [CatsController], providers: [CatsService], exports: [CatsService], }) export class CatsModule {} @Global() 데코레이터는 모듈을 전역 범위로 설정합니다. 전역 모듈은 일반적으로 루트 또는 코어 모듈에서 한 번만 등록되어야 합니다. 위의 예제에서 CatsService providers는 어디서나 사용 가능하며, 서비스를 주입하려는 모듈은 imports 배열에 CatsModule을 가져오지 않아도 될 것입니다. HINT Making everything global is not a good design decision. Global modules are available to reduce the amount of necessary boilerplate. The imports array is generally the preferred way to make the module’s API available to consumers. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:5","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Dynamic modules# Nest 모듈 시스템에는 동적 모듈이라는 강력한 기능이 포함되어 있습니다. 이 기능을 사용하면 동적으로 프로바이더를 등록하고 구성할 수 있는 사용자 정의 가능한 모듈을 쉽게 만들 수 있습니다. 동적 모듈은 here에서 자세하게 다루어져 있습니다. 이 장에서는 모듈 소개를 완료하기 위해 간략한 개요를 제공합니다. 다음은 DatabaseModule의 동적 모듈 정의 예시입니다: import { Module, DynamicModule } from '@nestjs/common'; import { createDatabaseProviders } from './database.providers'; import { Connection } from './connection.provider'; @Module({ providers: [Connection], }) export class DatabaseModule { static forRoot(entities = [], options?): DynamicModule { const providers = createDatabaseProviders(options, entities); return { module: DatabaseModule, providers: providers, exports: providers, }; } } HINT forRoot() 메서드는 동기적으로 또는 비동기적으로(즉, Promise를 통해) 동적 모듈을 반환할 수 있습니다. 이 모듈은 기본적으로 Connection provider를 정의하지만(@Module() 데코레이터 메타데이터에서), 추가로 forRoot() 메서드에 전달된 entities 및 options 객체에 따라 provider 컬렉션을 노출합니다.(예를 들면 리포지토리들) 동적 모듈에서 반환된 속성은 @Module() 데코레이터에서 정의된 기본 모듈 메타데이터를 확장(override가 아닌)하는 것에 주목하세요. 이것이 정적으로 선언된 Connection provider와 동적으로 생성된 리포지토리 provider가 모듈에서 내보내지는 방식입니다. 동적 모듈을 전역 범위에서 등록하려면 global 속성을 true로 설정하세요. { global: true, module: DatabaseModule, providers: providers, exports: providers, } WARNING As mentioned above, making everything global is not a good design decision. DatabaseModule은 다음과 같은 방식으로 가져와 구성될 수 있습니다: import { Module } from '@nestjs/common'; import { DatabaseModule } from './database/database.module'; import { User } from './users/entities/user.entity'; @Module({ imports: [DatabaseModule.forRoot([User])], }) export class AppModule {} 만약 동적 모듈을 다시 내보내려면, exports 배열에서 forRoot() 메서드 호출을 생략할 수 있습니다: import { Module } from '@nestjs/common'; import { DatabaseModule } from './database/database.module'; import { User } from './users/entities/user.entity'; @Module({ imports: [DatabaseModule.forRoot([User])], exports: [DatabaseModule], }) export class AppModule {} The Dynamic modules chapter covers this topic in greater detail, and includes a working example. HINT Learn how to build highly customizable dynamic modules with the use of ConfigurableModuleBuilder here in this chapter. ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:1:6","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Middleware 미들웨어는 라우트 핸들러 이전에 호출되는 함수입니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며, 애플리케이션의 요청-응답 주기에서 next() 미들웨어 함수에 액세스할 수 있습니다. 다음 미들웨어 함수는 일반적으로 next라는 변수로 표시됩니다. Nest 미들웨어는 기본적으로 express 미들웨어와 동등합니다. 다음은 공식 express 문서에서 가져온 미들웨어의 기능에 대한 설명입니다: Middleware functions can perform the following tasks: execute any code. make changes to the request and the response objects. end the request-response cycle. call the next middleware function in the stack. if the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging. (현재의 미들웨어 함수가 요청-응답 주기를 종료하지 않으면 next()를 호출하여 제어를 다음 미들웨어 함수로 전달해야 합니다. 그렇지 않으면 요청이 미해결 상태로 남게 됩니다.) Nest 미들웨어는 함수로도, 또는 @Injectable() 데코레이터를 사용한 클래스로 구현할 수 있습니다. 클래스는 NestMiddleware 인터페이스를 구현해야 하며, 함수는 특별한 요구사항이 없습니다. 간단한 미들웨어 기능을 클래스 방법을 사용하여 구현하는 것으로 시작해보겠습니다. WARNING Express and fastify handle middleware differently and provide different method signatures, read more here. //logger.middleware.ts import { Injectable, NestMiddleware } from '@nestjs/common'; import { Request, Response, NextFunction } from 'express'; @Injectable() export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log('Request...'); next(); } } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:0","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Dependency injection# Nest 미들웨어는 완전히 의존성 주입(Dependency Injection)을 지원합니다. 마치 프로바이더(Providers)와 컨트롤러(Controllers)와 마찬가지로, 미들웨어도 동일한 모듈 내에서 사용 가능한 의존성을 주입할 수 있습니다. 전통적으로 이는 생성자(Constructor)를 통해 이루어집니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:1","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Applying middleware# Nest.js에서는 @Module() 데코레이터에 미들웨어를 직접 설정할 수 있는 장소가 없습니다. 대신, 모듈 클래스의 configure() 메서드를 사용하여 미들웨어를 설정합니다. 미들웨어를 포함하는 모듈은 NestModule 인터페이스를 구현해야 합니다. AppModule 수준에서 LoggerMiddleware를 설정해 보겠습니다. //app.module.ts import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common'; import { LoggerMiddleware } from './common/middleware/logger.middleware'; import { CatsModule } from './cats/cats.module'; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes('cats'); } } 위의 예제에서는 이전에 CatsController 내에서 정의된 /cats 라우트 핸들러에 대해 LoggerMiddleware를 설정했습니다. 또한, 미들웨어를 특정 요청 메서드로 제한할 수 있으며, 이는 미들웨어를 구성할 때 forRoutes() 메서드에 라우트 경로와 요청 메서드를 포함하는 객체를 전달하여 수행할 수 있습니다. 아래 예제에서는 원하는 요청 메서드 유형을 참조하기 위해 RequestMethod열거형을 가져오는 것에 주목하세요. //app.module.ts import { Module, NestModule, RequestMethod, MiddlewareConsumer } from '@nestjs/common'; 👈 import { LoggerMiddleware } from './common/middleware/logger.middleware'; import { CatsModule } from './cats/cats.module'; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes({ path: 'cats', method: RequestMethod.GET }); 👈 } } HINT configure() 메서드는 async/await를 사용하여 비동기적으로 만들 수 있습니다. 즉, configure() 메서드 본문 내에서 비동기 작업의 완료를 await할 수 있습니다. WARNING express 어댑터를 사용할 때, NestJS 앱은 기본적으로 body-parser 패키지에서 제공하는 json 및 urlencoded 미들웨어를 등록합니다. 따라서 MiddlewareConsumer를 통해 이 미들웨어를 사용자 정의하려면 NestFactory.create()로 애플리케이션을 생성할 때 bodyParser 플래그를 false로 설정하여 전역 미들웨어를 비활성화해야 합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:2","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Route wildcards# 패턴 기반 라우트도 지원됩니다. 예를 들어, 별표(*)는 와일드카드로 사용되며 어떠한 문자 조합이든 일치합니다: forRoutes({ path: 'ab*cd', method: RequestMethod.ALL }); 'ab*cd' 라우트 경로는 abcd, ab_cd, abecd 등과 일치합니다. 라우트 경로에는 ? , + , * 및 ()와 같은 문자가 사용될 수 있으며, 이들은 정규 표현식과 관련된 부분 집합입니다. 하이픈(-)과 점(.)은 문자열 기반 경로에서 글자 그대로 해석됩니다. WARNING The fastify package uses the latest version of the path-to-regexp package, which no longer supports wildcard asterisks *. Instead, you must use parameters (e.g., (.*), :splat*). ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:3","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Middleware consumer# MiddlewareConsumer은 도우미 클래스로, 미들웨어를 관리하기 위한 여러 내장 메서드를 제공합니다. 이들은 모두 간편하게 fluent style로 연결될 수 있습니다. forRoutes() 메서드는 단일 문자열, 여러 문자열, RouteInfo 객체, 컨트롤러 클래스, 심지어 여러 컨트롤러 클래스를 인수로 받을 수 있습니다. 대부분의 경우 쉼표로 구분된 컨트롤러 목록을 전달할 것입니다. 아래는 단일 컨트롤러를 사용한 예제입니다: //app.moduls.ts import { Module, NestModule, MiddlewareConsumer } from '@nestjs/common'; import { LoggerMiddleware } from './common/middleware/logger.middleware'; import { CatsModule } from './cats/cats.module'; import { CatsController } from './cats/cats.controller'; @Module({ imports: [CatsModule], }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes(CatsController); } } HINT apply() 메서드는 단일 미들웨어를 취할 수도 있고, 다중 미들웨어를 지정하기 위해 여러 인수를 취할 수도 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:4","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Excluding routes# 때로는 특정 라우트에서 미들웨어를 적용하지 않도록 하고 싶을 때가 있습니다. exclude() 메서드를 사용하여 특정 라우트를 쉽게 제외할 수 있습니다. 이 메서드는 제외할 라우트를 식별하는 단일 문자열, 여러 문자열 또는 RouteInfo 객체를 인수로 받을 수 있습니다. 아래는 예시입니다: consumer .apply(LoggerMiddleware) .exclude( { path: 'cats', method: RequestMethod.GET }, { path: 'cats', method: RequestMethod.POST }, 'cats/(.*)', ) .forRoutes(CatsController); // forRoutes 뒤에 exclude를 사용하면 에러발생 HINT The exclude() method supports wildcard parameters using the path-to-regexp package. 위의 예제에서는 LoggerMiddleware가 CatsController 내에서 정의된 모든 라우트에 바인딩되지만, exclude() 메서드에 전달된 세 개의 라우트를 제외한 나머지 라우트에 적용될 것입니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:5","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Functional middleware# 우리가 사용한 LoggerMiddleware 클래스는 매우 간단합니다. 멤버나 추가적인 메서드, 의존성이 없습니다. 왜 클래스 대신에 간단한 함수로 정의할 수 없을까요? 사실, 가능합니다. 이러한 유형의 미들웨어를 함수형 미들웨어라고 합니다. 클래스 기반의 LoggerMiddleware를 함수형 미들웨어로 변환해보겠습니다. 그러면 두 방식의 차이점을 이해할 수 있습니다: import { Request, Response, NextFunction } from 'express'; export function logger(req: Request, res: Response, next: NextFunction) { console.log(`Request...`); next(); }; HINT 당신의 미들웨어가 어떠한 의존성도 필요로하지 않을 때에는, 더 간단한 대안인 함수형 미들웨어 사용을 고려하세요. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:6","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Multiple middleware# 위에서 언급한대로 여러 미들웨어를 순차적으로 실행하려면, apply() 메서드 내부에 쉼표로 구분된 목록을 제공하면 됩니다: consumer.apply(cors(), helmet(), logger).forRoutes(CatsController); ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:7","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Global middleware# 만약 모든 등록된 라우트에 미들웨어를 한 번에 바인딩하려면, INestApplication인스턴스에서 제공하는 use() 메서드를 사용할 수 있습니다: //main.ts const app = await NestFactory.create(AppModule); app.use(logger); await app.listen(3000); HINT 전역 미들웨어에서 *DI container에 접근하는 것은 불가능합니다. app.use()를 사용할 때는 대신 함수형 미들웨어를 사용할 수 있습니다. 또는 클래스 미들웨어를 사용하고 AppModule (또는 다른 모듈) 내에서 .forRoutes('*')를 사용하여 소비할 수 있습니다. *DI container : DI(Dependency Injection) 컨테이너는 의존성 주입을 관리하고 제공하는 메커니즘입니다. NestJS에서는 내장된 DI 컨테이너를 사용하여 애플리케이션의 여러 부분 간에 의존성을 주입하고 관리합니다. DI는 코드를 더 모듈화하고 재사용 가능하게 만들며, 테스트와 같은 측면에서도 이점을 제공합니다.DI 컨테이너는 클래스 인스턴스를 생성하고, 클래스의 생성자에 필요한 의존성을 해결하여 객체 간의 의존성을 자동으로 처리합니다. 이를 통해 코드는 느슨한 결합을 유지하고, 유연성과 테스트 용이성을 증가시킵니다. 간단히 말해, DI 컨테이너는 애플리케이션에서 사용되는 다양한 서비스, 컴포넌트, 및 의존성들을 효율적으로 관리하는 역할을 합니다. NestJS에서는 이 DI 컨테이너를 통해 의존성을 주입하고 모듈을 효과적으로 조직화할 수 있습니다. ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:2:8","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Exception filters Nest는 애플리케이션 전반에 걸쳐 모든 처리되지 않은 예외를 처리하는 내장 예외 레이어를 제공합니다. 애플리케이션 코드에서 처리되지 않은 예외가 발생하면 이 레이어에 의해 잡히며, 자동으로 적절한 사용자 친화적인 응답을 전송합니다. 기본적으로 이 동작은 내장된 전역 예외 필터에 의해 수행됩니다. 이 예외 필터는 HttpException 형식의 예외 (그 하위 클래스 포함)를 처리합니다. 예외가 인식되지 않을 때 (HttpException이나 HttpException에서 상속되지 않은 클래스), 내장된 예외 필터는 다음과 같은 기본 JSON 응답을 생성합니다: { \"statusCode\": 500, \"message\": \"Internal server error\" } HINT 전역 예외 필터는 http-errors 라이브러리를 일부 지원합니다. 기본적으로 statusCode 및 message 속성을 포함하는 모든 발생한 예외는 적절하게 채워져 응답으로 반환됩니다 (인식되지 않은 예외에 대한 기본 InternalServerErrorException 대신). ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:0","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Throwing standard exceptions# Nest는 @nestjs/common 패키지에서 노출되는 내장 HttpException 클래스를 제공합니다. 전형적인 HTTP REST/GraphQL API 기반 애플리케이션에서는 특정 오류 조건이 발생할 때 표준 HTTP 응답 객체를 보내는 것이 좋은 관행입니다. 예를 들어, CatsController에는 findAll() 메서드(한 GET 라우트 핸들러)가 있습니다. 이 라우트 핸들러가 어떤 이유로든 예외를 throw한다고 가정해 봅시다. 이를 시연하기 위해 다음과 같이 하드 코딩해 보겠습니다: //cats.controller.ts import { Controller, Get, HttpException, HttpStatus } from '@nestjs/common'; @Get() async findAll() { throw new HttpException('Forbidden', HttpStatus.FORBIDDEN); } HINT We used the HttpStatus here. This is a helper enum imported from the @nestjs/common package. 클라이언트가 이 엔드포인트를 호출하면 응답은 다음과 같을 것입니다: { \"statusCode\": 403, \"message\": \"Forbidden\" } HttpException 생성자는 응답을 결정하는 두 가지 필수 인수를 받습니다: response 인수는 JSON 응답 본문을 정의합니다. 아래에 설명된대로 문자열 또는 객체가 될 수 있습니다. status 인수는 HTTP status code를 정의합니다. 기본적으로 JSON 응답 본문은 두 가지 속성을 포함합니다: statusCode: status 인수에서 제공된 HTTP 상태 코드로 기본 설정됩니다. message: status를 기반으로 한 HTTP 오류에 대한 간단한 설명 JSON 응답 본문의 메시지 부분만 덮어쓰려면 response 인수에 문자열을 제공하면 됩니다. 전체 JSON 응답 본문을 덮어쓰려면 response 인수에 객체를 전달하면 됩니다. Nest는 객체를 직렬화하고 이를 JSON 응답 본문으로 반환합니다. 두 번째 생성자 인수인 status는 유효한 HTTP 상태 코드여야 합니다. 관례적으로 @nestjs/common에서 가져온 HttpStatus 열거형을 사용하는 것이 좋습니다. 세 번째 생성자 인수 (선택적) options는 오류 cause을 제공하는 데 사용할 수 있습니다. 이 원인 객체는 응답 객체로 직렬화되지 않지만 HttpException이 throw되는 데 원인이 된 내부 오류에 대한 유용한 정보를 제공하는 데 유용할 수 있습니다. 전체 응답 본문을 덮어쓰고 오류 원인을 제공하는 예시입니다: //cats.controller.ts @Get() async findAll() { try { await this.service.findAll() } catch (error) { throw new HttpException({ status: HttpStatus.FORBIDDEN, error: 'This is a custom message', }, HttpStatus.FORBIDDEN, { cause: error }); } } Using the above, this is how the response would look: { \"status\": 403, \"error\": \"This is a custom message\" } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:1","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Custom exceptions# 대부분의 경우 사용자 정의 예외를 작성할 필요가 없으며, 다음 섹션에서 설명하는대로 내장된 Nest HTTP 예외를 사용할 수 있습니다. 사용자 정의 예외를 만들어야 하는 경우에는 사용자 정의 예외를 기본 HttpException 클래스에서 상속하는 예외 계층을 만드는 것이 좋은 관행입니다. 이 접근 방식을 사용하면 Nest가 사용자 정의 예외를 인식하고 오류 응답을 자동으로 처리할 것입니다. 이러한 사용자 정의 예외를 구현해 보겠습니다: //forbidden.exception.ts export class ForbiddenException extends HttpException { constructor() { super('Forbidden', HttpStatus.FORBIDDEN); } } ForbiddenException이 기본 HttpException을 확장하므로 내장된 예외 처리기와 원활하게 작동하며, 따라서 findAll() 메서드 내에서 사용할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:2","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Built-in HTTP exceptions# Nest는 기본 HttpException을 상속하는 일련의 표준 예외를 제공합니다. 이 예외들은 @nestjs/common 패키지에서 노출되며, 가장 일반적인 HTTP 예외 중 많은 것들을 나타냅니다: BadRequestException UnauthorizedException NotFoundException ForbiddenException NotAcceptableException RequestTimeoutException ConflictException GoneException HttpVersionNotSupportedException PayloadTooLargeException UnsupportedMediaTypeException UnprocessableEntityException InternalServerErrorException NotImplementedException ImATeapotException MethodNotAllowedException BadGatewayException ServiceUnavailableException GatewayTimeoutException PreconditionFailedException 내장 예외들은 options 매개변수를 사용하여 오류 원인과 오류 설명을 모두 제공할 수도 있습니다: throw new BadRequestException('Something bad happened', { cause: new Error(), description: 'Some error description' }) 위의 내용을 사용하면 응답은 다음과 같이 보일 것입니다: { \"message\": \"Something bad happened\", \"error\": \"Some error description\", \"statusCode\": 400, } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:3","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Exception filters# 기본(내장) 예외 필터는 많은 경우를 자동으로 처리할 수 있지만 예외 레이어에 대한 완전한 제어가 필요한 경우가 있습니다. 예를 들어 로깅을 추가하거나 어떤 동적 요소를 기반으로 다른 JSON 스키마를 사용하고 싶을 수 있습니다. 예외 필터는 정확히 이러한 목적으로 설계되었습니다. 이를 사용하면 흐름 제어와 클라이언트로 보내는 응답의 내용을 정확하게 제어할 수 있습니다. HttpException 클래스의 인스턴스인 예외를 catch하고 해당 예외에 대해 사용자 정의 응답 로직을 구현하는 예외 필터를 만들어 보겠습니다. 이를 위해 기본 플랫폼 Request 및 Response 객체에 액세스해야 합니다. 원본 url을 가져와 로깅 정보에 포함시키기 위해 Request 객체에 액세스합니다. response.json() 메서드를 사용하여 직접 전송되는 응답을 제어하기 위해 Response 객체를 사용할 것입니다. //http-exception.filter.ts import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch(HttpException) //1️⃣ export class HttpExceptionFilter implements ExceptionFilter { catch(exception: HttpException, host: ArgumentsHost) { //2️⃣ const ctx = host.switchToHttp(); const response = ctx.getResponse\u003cResponse\u003e(); const request = ctx.getRequest\u003cRequest\u003e(); const status = exception.getStatus(); response .status(status) .json({ statusCode: status, timestamp: new Date().toISOString(), path: request.url, }); } } HINT 모든 예외 필터는 일반적인 ExceptionFilter\u003cT\u003e 인터페이스를 구현해야 합니다. 이것은 catch(exception: T, host: ArgumentsHost) 메서드를 해당 시그니처와 함께 제공해야 한다는 것을 요구합니다. T는 예외의 유형을 나타냅니다. WARNING If you are using @nestjs/platform-fastify you can use response.send() instead of response.json(). Don’t forget to import the correct types from fastify. 1️⃣@Catch(HttpException) 데코레이터는 예외 필터에 필요한 메타데이터를 바인딩하며, 이를 통해 Nest에게 이 특정 필터가 HttpException 유형의 예외를 찾고 있으며 다른 유형의 예외는 찾지 않는다고 알려줍니다. @Catch() 데코레이터는 단일 매개변수 또는 쉼표로 구분된 목록을 허용할 수 있습니다. 이를 통해 한 번에 여러 유형의 예외에 대한 필터를 설정할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:4","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Arguments host# 2️⃣ catch() 메서드의 매개변수를 살펴보겠습니다. exception 매개변수는 현재 처리 중인 예외 객체입니다. host 매개변수는 ArgumentsHost 객체입니다. ArgumentsHost는 *실행 컨텍스트 장에서 자세히 살펴볼 강력한 유틸리티 객체입니다. 이 코드 샘플에서는 ArgumentsHost에 대한 참조를 사용하여 원본 요청 핸들러에 전달되는 Request 및 Response 객체에 대한 참조를 얻습니다(예외가 발생한 컨트롤러에서). 이 코드 샘플에서는 ArgumentsHost의 몇 가지 도우미 메서드를 사용하여 원하는 Request 및 Response 객체를 가져왔습니다. ArgumentsHost에 대해 더 알아보려면 여기를 참조하세요. *이 추상화 수준의 이유는 ‘ArgumentsHost’가 모든 컨텍스트에서 기능하기 때문입니다(예를 들어 현재 작업 중인 HTTP 서버 컨텍스트 뿐만 아니라 Microservices 및 WebSockets도 포함됨). 실행 컨텍스트 장에서는 ArgumentsHost 및 해당 도우미 함수의 강력함을 활용하여 모든 실행 컨텍스트에 대한 기본 인수에 액세스하는 방법을 살펴볼 것입니다. 이를 통해 모든 컨텍스트에서 작동하는 일반적인 예외 필터를 작성할 수 있게 됩니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:5","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Binding filters# 새로운 HttpExceptionFilter를 CatsController의 create() 메서드에 연결해 보겠습니다. //cats.controller.ts import { Controller, Post, UseFilters } from '@nestjs/common'; @Post() @UseFilters(new HttpExceptionFilter()) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); } HINT The @UseFilters() decorator is imported from the @nestjs/common package. 여기서 @UseFilters() 데코레이터를 사용했습니다. @Catch() 데코레이터와 유사하게 단일 필터 인스턴스 또는 필터 인스턴스의 쉼표로 구분된 목록을 사용할 수 있습니다. 여기서는 HttpExceptionFilter의 인스턴스를 생성했습니다. 또는 클래스를 전달하고 (인스턴스 대신) 프레임워크에 인스턴스화 책임을 남기고 의존성 주입을 활성화할 수 있습니다. //cats.controller.ts @Post() @UseFilters(HttpExceptionFilter) async create(@Body() createCatDto: CreateCatDto) { throw new ForbiddenException(); } HINT 가능하면 인스턴스 대신 클래스를 사용하여 필터를 적용하는 것이 좋습니다. 이렇게 하면 Nest가 동일한 클래스의 인스턴스를 모듈 전체에서 쉽게 재사용할 수 있어 메모리 사용량이 감소합니다. 위의 예제에서는 HttpExceptionFilter가 단일 create() 라우트 핸들러에만 적용되어 메서드 범위로 설정되었습니다. 예외 필터는 메서드 범위의 컨트롤러/리졸버/게이트웨이, 컨트롤러 범위, 또는 전역 범위에서 범위를 설정할 수 있습니다. 예를 들어 필터를 컨트롤러 범위로 설정하려면 다음과 같이 할 수 있습니다: //cats.controller.ts @UseFilters(new HttpExceptionFilter()) export class CatsController {} 이 구성은 CatsController 내에서 정의된 모든 라우트 핸들러에 대해 HttpExceptionFilter를 설정합니다. 글로벌 범위의 필터를 만들려면 다음을 수행합니다: //main.ts async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000); } bootstrap(); WARNING The useGlobalFilters() method does not set up filters for gateways or hybrid applications. 글로벌 범위의 필터는 모든 컨트롤러 및 모든 라우트 핸들러에 걸쳐 전체 애플리케이션에서 사용됩니다. 의존성 주입 측면에서 모듈의 컨텍스트 외부에서 등록된 글로벌 필터 (위의 예제와 같이 useGlobalFilters()를 사용함)는 모듈의 컨텍스트 외부에서 수행되므로 종속성을 주입할 수 없습니다. 이 문제를 해결하려면 다음 구성을 사용하여 어떤 모듈에서든 직접 글로벌 범위의 필터를 등록할 수 있습니다: //app.module.ts import { Module } from '@nestjs/common'; import { APP_FILTER } from '@nestjs/core'; @Module({ providers: [ { provide: APP_FILTER, useClass: HttpExceptionFilter, }, ], }) export class AppModule {} HINT 이 방법을 사용하여 필터에 대한 종속성 주입을 수행할 때 이 구조가 사용되는 모듈에 관계없이 필터는 사실상 전역적입니다. 이 작업은 어디에서 수행해야 할까요? 필터(위 예제의 HttpExceptionFilter)가 정의된 모듈을 사용(Choose)하십시오. 또한 useClass가 사용자 지정 공급자 등록을 처리하는 유일한 방법은 아닙니다. 자세한 내용은 여기를 참조하십시오. 이 기술을 사용하여 필요한 만큼 많은 필터를 추가할 수 있습니다. 각각을 providers 배열에 추가하면 됩니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:6","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Catch everything# 관리하지 않은 모든 예외를 잡기 위해서는 (예외 유형과 관계없이) @Catch()데코레이터의 매개변수 목록을 비워둡니다. 예: @Catch() 아래 예제에서는 HTTP adapter를 사용하여 응답을 전달하며 플랫폼에 구애받지 않는 코드입니다. 또한 플랫폼별 객체 (Request 및 Response)를 직접 사용하지 않습니다. import { ExceptionFilter, Catch, ArgumentsHost, HttpException, HttpStatus, } from '@nestjs/common'; import { HttpAdapterHost } from '@nestjs/core'; @Catch() export class AllExceptionsFilter implements ExceptionFilter { constructor(private readonly httpAdapterHost: HttpAdapterHost) {} catch(exception: unknown, host: ArgumentsHost): void { // In certain situations `httpAdapter` might not be available in the // constructor method, thus we should resolve it here. const { httpAdapter } = this.httpAdapterHost; const ctx = host.switchToHttp(); const httpStatus = exception instanceof HttpException ? exception.getStatus() : HttpStatus.INTERNAL_SERVER_ERROR; const responseBody = { statusCode: httpStatus, timestamp: new Date().toISOString(), path: httpAdapter.getRequestUrl(ctx.getRequest()), }; httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus); } } WARNING When combining an exception filter that catches everything with a filter that is bound to a specific type, the “Catch anything” filter should be declared first to allow the specific filter to correctly handle the bound type. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:7","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Inheritance(상속)# 일반적으로 애플리케이션 요구 사항을 충족하는 데 사용되는 완전히 사용자 정의된 예외 필터를 만들 것입니다. 그러나 특정 요소를 기반으로 내용을 덮어쓰기 위해 내장된 기본 글로벌 예외 필터를 확장하기를 원하는 경우가 있을 수 있습니다. 예외 처리를 기본 필터에 위임하려면 BaseExceptionFilter를 확장하고 상속된 catch()메서드를 호출해야 합니다. //all-exceptions.filter.ts import { Catch, ArgumentsHost } from '@nestjs/common'; import { BaseExceptionFilter } from '@nestjs/core'; @Catch() export class AllExceptionsFilter extends BaseExceptionFilter { catch(exception: unknown, host: ArgumentsHost) { super.catch(exception, host); } } WARNING BaseExceptionFilter를 확장하는 메서드 및 컨트롤러 범위 필터는 new로 인스턴스화해서는 안됩니다. 대신 프레임워크가 자동으로 인스턴스화하도록 해야 합니다. 위의 구현은 접근 방식을 보여주는 뼈대일 뿐입니다. 확장된 예외 필터의 실제 구현에는 특정한 비즈니스 로직이 포함됩니다(예: 여러 조건을 처리). 전역 필터는 기본 필터를 확장할 수 있습니다. 이는 두 가지 방법 중 하나로 수행될 수 있습니다. 첫 번째 방법은 사용자 정의 전역 필터를 인스턴스화할 때 HttpAdapter 참조를 주입하는 것입니다. async function bootstrap() { const app = await NestFactory.create(AppModule); const { httpAdapter } = app.get(HttpAdapterHost); app.useGlobalFilters(new AllExceptionsFilter(httpAdapter)); await app.listen(3000); } bootstrap(); 두 번째 방법은 APP_FILTER 토큰을 사용하는 것입니다. as shown here. ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:3:8","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Pipes 클라이언트로부터 받은 데이터를 애플리케이션에서 사용할 수 있는 형식으로 변환하거나, 유효성 검사, 가공 등의 작업을 수행하는데 사용되는 중간 레이어 파이프는 @Injectable() 데코레이터로 주석이 달린 클래스로, PipeTransform 인터페이스를 구현합니다. “Pipes\"는 주로 두 가지 사용 사례가 있습니다: 변환 (Transformation): 입력 데이터를 원하는 형식으로 변환하는 역할을 합니다. 예를 들어, 문자열에서 정수로 변환하거나, 날짜 형식을 변경하는 등의 작업이 여기에 해당됩니다. 유효성 검사 (Validation): 입력 데이터를 평가하고 유효한 경우에는 변경 없이 그대로 전달하며, 그렇지 않으면 예외를 발생시킵니다. 입력 데이터의 유효성을 확인하는 역할을 수행합니다. 두 경우 모두 파이프는 컨트롤러 라우트 핸들러에서 처리되는 인수에 작용합니다. Nest는 메서드가 호출되기 직전에 파이프를 삽입하고, 파이프는 해당 메서드에 전달되는 인수에서 작동합니다. 변환 또는 유효성 검사 작업은 그때 수행되며, 이후 라우트 핸들러는 (가능한 경우) 변환된 인수로 호출됩니다. Nest에는 즉시 사용할 수 있는 여러 내장 파이프가 제공됩니다. 또한 사용자 정의 파이프를 만들 수도 있습니다. 이 장에서는 내장 파이프를 소개하고 이를 라우트 핸들러에 바인딩하는 방법을 보여줄 것입니다. 그런 다음 몇 가지 처음부터 파이프를 만드는 방법을 살펴보겠습니다. HINT 파이프는 예외 영역 내에서 실행됩니다. 즉, 파이프에서 예외가 발생하면 예외 레이어 (전역 예외 필터 및 현재 컨텍스트에 적용된 모든 예외 필터)에서 처리됩니다. 위의 내용을 고려하면 파이프에서 예외가 발생하면 후속으로 컨트롤러 메서드가 실행되지 않음을 명확히 알 수 있습니다. 이는 외부 소스에서 애플리케이션으로 들어오는 데이터를 시스템 경계에서 유효성 검사하는 데 사용되는 최선의 실천 기법을 제공합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:0","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Built-in pipes# Nest는 기본적으로 아래 9개의 파이프를 제공합니다: ValidationPipe: 기본적인 형식 유효성 검사를 제공합니다. 유효성 검사 실패 시 예외를 throw합니다. ParseIntPipe: 전달된 값이 유효한 정수인지 확인하고, 정수로 변환합니다. 실패 시 예외를 throw합니다. ParseFloatPipe: 전달된 값이 유효한 부동 소수점 숫자인지 확인하고, 부동 소수점으로 변환합니다. 실패 시 예외를 throw합니다. ParseBoolPipe: 전달된 값이 유효한 부울 값인지 확인하고, 부울 값으로 변환합니다. 실패 시 예외를 throw합니다. ParseUUIDPipe: 전달된 값이 UUID 형식인지 확인하고, UUID로 변환합니다. 실패 시 예외를 throw합니다. DefaultValuePipe: 기본값을 지정할 수 있습니다. 값이 주어지지 않은 경우, 지정된 기본값을 사용합니다. TransformPipe: 사용자 정의 변환 함수를 적용하여 값을 변환합니다. ValidationPipe: 전달된 값이 유효한 DTO(Data Transfer Object)인지 확인하고, 실패 시 예외를 throw합니다. ValidationPipe: DTO의 생성자에서 자동으로 타입 유효성을 검사합니다. 실패 시 예외를 throw합니다. They’re exported from the @nestjs/common package. Let’s take a quick look at using ParseIntPipe. This is an example of the transformation use case, where the pipe ensures that a method handler parameter is converted to a JavaScript integer (or throws an exception if the conversion fails). Later in this chapter, we’ll show a simple custom implementation for a ParseIntPipe. The example techniques below also apply to the other built-in transformation pipes (ParseBoolPipe, ParseFloatPipe, ParseEnumPipe, ParseArrayPipe and ParseUUIDPipe, which we’ll refer to as the Parse* pipes in this chapter). ParseIntPipe를 사용하는 간단한 예제를 살펴보겠습니다. 이는 변환(use case)의 예시로, 파이프는 메서드 핸들러의 매개변수를 JavaScript 정수로 변환하는 것을 보장하거나(변환이 실패하면 예외를 throw), 나중에 이 장에서는 ParseIntPipe에 대한 간단한 사용자 정의 구현을 보여줄 것입니다. 아래의 예제 기법은 이 장에서 다루는 다른 내장 변환 파이프(ParseBoolPipe, ParseFloatPipe, ParseEnumPipe, ParseArrayPipe 및 ParseUUIDPipe, 여기서는 Parse* 파이프로 참조합니다)에도 적용됩니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:1","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Binding pipes# 파이프를 사용하려면 파이프 클래스의 인스턴스를 적절한 컨텍스트에 연결(바인딩)해야 합니다. ParseIntPipe 예제에서는 파이프를 특정 라우트 핸들러 메서드와 연관시키고, 해당 메서드가 호출되기 전에 파이프가 실행되도록 하려고 합니다. 이를 메서드 매개변수 레벨에서 파이프를 바인딩한다고 표현하겠습니다. @Get(':id') async findOne(@Param('id', ParseIntPipe) id: number) { return this.catsService.findOne(id); } 이러면 두 조건 중 하나가 참이라는 것을 보장합니다. findOne() 메서드에서 받는 매개변수가 숫자이거나(as expected in our call to this.catsService.findOne()), 라우터 핸들러에서 예외를 전달했거나. 예를 들어, 다음과 같이 라우트가 호출된다고 가정해보겠습니다: GET localhost:3000/abc Nest는 아래와 같은 예외를 줄 것입니다. { \"statusCode\": 400, \"message\": \"Validation failed (numeric string is expected)\", \"error\": \"Bad Request\" } 예외는 findOne()메서드의 본문 실행을 방지할 것입니다. 위의 예제에서는 클래스(ParseIntPipe)를 인스턴스로 전달하는 것이 아니라 프레임워크에 인스턴스화 책임을 맡겨 의존성 주입을 가능하게 합니다. 파이프와 가드와 마찬가지로 대신 in-place instance를 전달할 수 있습니다. in-place instance를 전달하는 것은 옵션을 전달하여 내장 파이프의 동작을 사용자 정의하고 싶을 때 유용합니다. @Get(':id') async findOne( @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE })) id: number, ) { return this.catsService.findOne(id); } 다른 변환 파이프들 (Parse* 파이프들)을 바인딩하는 방법도 유사합니다. 이러한 파이프들은 모두 라우트 매개변수, 쿼리 문자열 매개변수 및 요청 본문 값의 유효성을 검사하는 맥락에서 작동합니다. 예를 들어 쿼리 문자열 매개변수와 함께 사용할 때: @Get() async findOne(@Query('id', ParseIntPipe) id: number) { return this.catsService.findOne(id); } 여기에서는 ParseUUIDPipe를 사용하여 문자열 매개변수를 구문 분석하고 해당 값이 UUID인지 유효성을 검사하는 예제입니다. @Get(':uuid') async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) { return this.catsService.findOne(uuid); } HINT When using ParseUUIDPipe() you are parsing UUID in version 3, 4 or 5, if you only require a specific version of UUID you can pass a version in the pipe options. 위에서는 다양한 내장 파이프인 Parse* 패밀리를 바인딩하는 예제를 살펴보았습니다. 유효성 검사 파이프를 바인딩하는 것은 조금 다릅니다. 다음 섹션에서 이에 대해 논의하겠습니다. HINT Validation techniques 섹션에서는 유효성 검사 파이프에 대한 포괄적인 예제를 자세히 살펴볼 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:2","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Custom pipes# 언급한대로 사용자 정의 파이프를 만들 수 있습니다. Nest는 강력한 내장 ParseIntPipe와 ValidationPipe를 제공하지만, 각각을 처음부터 간단한 사용자 정의 버전으로 만들어보면 어떻게 사용자 정의 파이프가 구성되는지 확인할 수 있습니다. 먼저 간단한 ValidationPipe부터 시작하겠습니다. 처음에는 입력 값을 받아들이고 즉시 동일한 값을 반환하는 식별 함수처럼 동작하도록 만들어 보겠습니다. //validation.pipe.ts import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'; @Injectable() export class ValidationPipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { return value; } } HINT PipeTransform\u003cT, R\u003e은 어떠한 파이프든 반드시 구현해야 하는 제네릭 인터페이스입니다. 이 제네릭 인터페이스는 변환 로직을 정의하기 위한 구조를 제공합니다. 제네릭 타입 T는 입력 value의 타입을 나타내고, R은 transform() 메서드의 반환 타입을 나타냅니다. 각 파이프는 PipeTransform 인터페이스 계약을 충족시키기 위해 transform() 메서드를 구현해야 합니다. 이 메서드는 두 개의 매개변수를 갖습니다: value metadata value 매개변수는 현재 처리 중인 메서드 인자(argument)를 나타내며(라우트 처리 메서드에서 수신되기 전), metadata는 현재 처리 중인 메서드 인자(argument)의 메타데이터를 나타냅니다. 메타데이터 객체에는 다음과 같은 속성들이 있습니다: export interface ArgumentMetadata { type: 'body' | 'query' | 'param' | 'custom'; metatype?: Type\u003cunknown\u003e; data?: string; } 이러한 속성들은 현재 처리 중인 인자(argument)를 설명합니다. type 해당 속성은 현재 처리 중인 매개변수가 body @Body(), query @Query(), param @Param() 또는 사용자 정의 매개변수인지 여부를 나타냅니다. (자세한 내용은 여기에서 확인하세요.) metatype 이 속성은 인자(argument)의 메타타입을 제공합니다. 예를 들어 String일 수 있습니다. 주의: 라우트 핸들러 메서드 시그니처에서 타입 선언을 생략하거나 일반 JavaScript를 사용한 경우 값은 undefined입니다. data 데코레이터에 전달된 문자열, 예를 들면 @Body('string')에서의 'string'입니다. 데코레이터 괄호를 비워 둔 경우 undefined입니다. WARNING TypeScript 인터페이스는 트랜스파일 중에 사라집니다. 따라서 메서드 매개변수의 타입이 클래스 대신 인터페이스로 선언된 경우 metatype 값은 Object가 될 것입니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:3","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Schema based validation# 우리의 유효성 검사 파이프를 좀 더 유용하게 만들어 봅시다. 아마도 CatsController의 create() 메서드를 자세히 살펴보면, 서비스 메서드를 실행하기 전에 게시 본문 객체가 유효한지 확인하고 싶을 것입니다. @Post() async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } Let’s focus in on the createCatDto body parameter. Its type is CreateCatDto: //create-cat.dto.ts export class CreateCatDto { name: string; age: number; breed: string; } 우리는 create 메서드로 들어오는 모든 요청이 유효한 body를 포함하고있다고 보장하고자 합니다. 따라서 createCatDto 객체의 세 멤버를 검증해야 합니다. 이 작업을 라우트 핸들러 메서드 내부에서 수행할 수 있지만, 이렇게 하는 것은 단일 책임 원칙(single responsibility principle (SRP))을 깨뜨리게 됩니다. 또 다른 접근 방법은 validator class를 만들고 해당 작업을 거기에 위임하는 것입니다. 이 방법은 각 메서드의 시작 부분에서이 유효성 검사기를 호출하는 것을 기억해야 한다는 단점이 있습니다. 유효성 검사 미들웨어를 생성하는 것은 어떨까요? 이는 작동할 수 있지만 유감스럽게도 애플리케이션 전체에서 모든 컨텍스트에서 사용할 수 있는 generic middleware를 생성하는 것은 불가능합니다. 이는 미들웨어가 execution context, 호출될 핸들러 및 해당 매개변수 등에 대해 알지 못하기 때문입니다. 물론 이런 상황이 파이프가 설계된 정확한 사용 사례입니다. 그러니 이제 우리의 유효성 검사 파이프를 더 정교하게 만들어 봅시다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:4","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Object schema validation# 객체 유효성 검사를 깨끗하고 DRY(Don’t Repeat Yourself)한 방식으로 수행하는 여러 가지 접근 방법이 있습니다. 일반적인 접근 방법 중 하나는 스키마 기반 유효성 검사를 사용하는 것입니다. 이 접근 방법을 시도해 보겠습니다. Zod 라이브러리를 사용하면 읽기 쉬운 API로 간단하게 스키마를 생성할 수 있습니다. Zod 기반 스키마를 활용하는 유효성 검사 파이프를 만들어 보겠습니다. 먼저 필요한 패키지를 설치하겠습니다: $ npm install --save zod 아래의 코드 샘플에서는 스키마를 constructor 인자로 받는 간단한 클래스를 만듭니다. 그런 다음 스키마를 통해 들어오는 인수를 검증하는 schema.parse() 메서드를 적용합니다. 앞서 언급한 대로 validation pipe 파이프는 값이 변경되지 않거나 예외를 throw하는 두 가지 동작 중 하나를 수행합니다. 다음 섹션에서는 @UsePipes() 데코레이터를 사용하여 특정 컨트롤러 메서드에 적절한 스키마를 제공하는 방법을 볼 것입니다. 이를 통해 목표로한 대로 유효성 검사 파이프를 다양한 컨텍스트에서 재사용할 수 있게 됩니다. import { PipeTransform, ArgumentMetadata, BadRequestException } from '@nestjs/common'; import { ZodSchema } from 'zod'; export class ZodValidationPipe implements PipeTransform { constructor(private schema: ZodSchema) {} transform(value: unknown, metadata: ArgumentMetadata) { try { const parsedValue = this.schema.parse(value); return parsedValue; } catch (error) { throw new BadRequestException('Validation failed'); } } } ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:5","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Binding validation pipes# 이전에는 변환 파이프(ParseIntPipe 및 나머지 Parse* 파이프와 같은)를 바인딩하는 방법을 살펴보았습니다. 유효성 검사 파이프를 바인딩하는 것도 매우 간단합니다. 이 경우에는 메서드 호출 수준에서 파이프를 바인딩하고자 합니다. 현재 예제에서 ZodValidationPipe를 사용하려면 다음과 같은 작업을 수행해야 합니다: ZodValidationPipe의 인스턴스 생성 파이프의 클래스 생성자에서 컨텍스트별 Zod 스키마 전달 파이프를 메서드에 바인딩 Zod 스키마 예제: import { z } from 'zod'; export const createCatSchema = z .object({ name: z.string(), age: z.number(), breed: z.string(), }) .required(); export type CreateCatDto = z.infer\u003ctypeof createCatSchema\u003e; We do that using the @UsePipes() decorator as shown below: //cats.controller.ts @Post() @UsePipes(new ZodValidationPipe(createCatSchema)) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } HINT The @UsePipes() decorator is imported from the @nestjs/common package. WARNING zod 라이브러리를 사용하려면 tsconfig.json 파일에서 strictNullChecks 구성이 활성화되어 있어야 합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:6","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Class validator# WARNING The techniques in this section require TypeScript and are not available if your app is written using vanilla JavaScript. 우리의 유효성 검사 기술에 대한 대안적인 구현을 살펴봅시다. Nest는 class-validator 라이브러리와 잘 동작합니다. 이 강력한 라이브러리를 사용하면 데코레이터 기반 유효성 검사를 수행할 수 있습니다. 데코레이터 기반 유효성 검사는 특히 Nest의 Pipe기능과 결합될 때 매우 강력합니다. 왜냐하면 우리는 처리된 프로퍼티의 메타타입에 접근할 수 있기 때문입니다. 시작하기 전에 필요한 패키지를 설치해야 합니다: $ npm i --save class-validator class-transformer 이러한 패키지를 설치한 후에는 CreateCatDto 클래스에 몇 가지 데코레이터를 추가할 수 있습니다. 이 기술의 중요한 장점 중 하나는 CreateCatDto 클래스가 Post 본문 객체의 단일 진실의 소스로 유지된다는 것입니다 (별도의 유효성 검사 클래스를 만들 필요가 없습니다). //create-cat.dto.ts import { IsString, IsInt } from 'class-validator'; export class CreateCatDto { @IsString() name: string; @IsInt() age: number; @IsString() breed: string; } HINT Read more about the class-validator decorators here. Now we can create a ValidationPipe class that uses these annotations. //validation.pipe.ts import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToInstance } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform\u003cany\u003e { async transform(value: any, { metatype }: ArgumentMetadata) { if (!metatype || !this.toValidate(metatype)) { return value; } const object = plainToInstance(metatype, value); const errors = await validate(object); if (errors.length \u003e 0) { throw new BadRequestException('Validation failed'); } return value; } private toValidate(metatype: Function): boolean { const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); } } HINT ValidationPipe은 Nest에서 기본적으로 제공되기 때문에 사용자 정의 유효성 검사 파이프를 직접 작성할 필요는 없습니다. 내장된 ValidationPipe에는 이 장에서 만든 샘플보다 더 많은 옵션이 제공되며, 이 샘플은 사용자 정의 파이프의 메커니즘을 설명하기 위해 기본적으로 유지되었습니다. 자세한 내용 및 다양한 예제는 여기에서 확인할 수 있습니다. NOTICE We used the class-transformer library above which is made by the same author as the class-validator library, and as a result, they play very well together. 이 코드를 살펴보겠습니다. 먼저, transform() 메서드가 async로 표시되어 있습니다. 이는 Nest가 동기적 및 비동기적 파이프를 모두 지원하기 때문에 가능합니다. 이 메서드를 async로 만든 이유는 class-validator의 일부 검증이 비동기일 수 있기 때문입니다 (Promises를 사용합니다). 다음으로 destructuring을 사용하여 metatype 필드를 (ArgumentMetadata에서 이 멤버만 추출하여) metatype 매개변수로 할당하고 있습니다. 이는 ArgumentMetadata 전체를 얻는 대신 추가 문을 추가하여 metatype 변수를 할당하는 단축 표기법일 뿐입니다. 다음으로 toValidate()라는 도우미 함수에 주목하세요. 이 함수는 현재 처리 중인 인수가 기본 JavaScript 타입인 경우 (이들에는 유효성 검사 데코레이터가 연결될 수 없으므로 유효성 검사 단계를 실행할 필요가 없습니다) 검증 단계를 우회하는 역할을 합니다. 다음으로 plainToInstance() 함수를 사용하여 일반 JavaScript 인수 객체를 타입이 지정된 객체로 변환하여 유효성을 적용합니다. 이를 수행해야 하는 이유는 네트워크 요청에서 역직렬화된 들어오는 post body 객체에는 어떤 타입 정보도 없기 때문입니다 (이는 Express와 같은 기본 플랫폼의 동작 방식입니다). Class-validator는 앞서 DTO에 정의한 유효성 데코레이터를 사용해야 하므로 이 변환을 수행하여 들어오는 본문을 적절히 데코레이트된 객체로 처리해야 합니다. 마지막으로 앞서 언급했듯이 이는 유효성 검사 파이프이기 때문에 값이 변경되지 않거나 예외를 throw하는 두 가지 동작 중 하나를 수행합니다. 마지막 단계는 ValidationPipe를 바인딩하는 것입니다. 파이프는 매개변수 스코프, 메서드 스코프, 컨트롤러 스코프 또는 글로벌 스코프로 바인딩될 수 있습니다. 앞서 Zod 기반의 유효성 검사 파이프에서 메서드 레벨에서 파이프를 바인딩하는 예제를 보았습니다. 아래의 예제에서는 파이프 인스턴스를 라우트 핸들러의 @Body() 데코레이터에 바인딩하여 파이프가 호출되어 post body를 유효성 검사하도록 만듭니다. //cats.controller.ts @Post() async create( @Body(new ValidationPipe()) createCatDto: CreateCatDto, ) { this.catsService.create(createCatDto); } 매개변수 스코프 파이프는 유효성 검사 로직이 특정 매개변수에만 관련된 경우 유용합니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:7","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Global scoped pipes# ValidationPipe은 가능한 한 일반적으로 만들어졌기 때문에 전역 스코프 파이프로 설정하여 전체 애플리케이션에서 모든 라우트 핸들러에 적용할 수 있습니다. //main.ts async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000); } bootstrap(); NOTICE hybrid apps의 경우 useGlobalPipes() 메서드는 게이트웨이 및 마이크로서비스를 위한 파이프를 설정하지 않습니다. “표준” (비하이브리드) 마이크로서비스 앱의 경우 useGlobalPipes()는 파이프를 전역으로 마운트합니다. 전역 파이프는 전체 애플리케이션, 모든 컨트롤러 및 모든 라우트 핸들러에서 사용됩니다. 의존성 주입 관점에서 주의할 점은 모듈 외부에서 등록된 전역 파이프(useGlobalPipes()를 사용한 경우와 같이)는 모듈의 컨텍스트 외부에서 바인딩되었기 때문에 의존성을 주입할 수 없습니다. 이 문제를 해결하기 위해 이 구성을 사용하여 어떤 모듈에서든 직접 전역 파이프를 설정할 수 있습니다: //app.module.ts import { Module } from '@nestjs/common'; import { APP_PIPE } from '@nestjs/core'; @Module({ providers: [ { provide: APP_PIPE, useClass: ValidationPipe, }, ], }) export class AppModule {} HINT 파이프에 대한 의존성 주입을 수행하기 위해이 접근 방식을 사용할 때, 이 구성이 사용된 모듈에 관계없이 파이프는 사실상 전역입니다. 이를 어디에 설정해야 할까요? 파이프(위의 예제에서는 ValidationPipe)가 정의된 모듈을 선택하세요. 또한 useClass는 사용자 지정 프로바이더 등록을 다루는 유일한 방법이 아닙니다. 여기에서 더 알아보세요. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:8","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"The built-in ValidationPipe# 기억하세요. ValidationPipe은 Nest에서 기본적으로 제공되기 때문에 사용자 정의 유효성 검사 파이프를 직접 작성할 필요는 없습니다. 내장된 ValidationPipe은 이 장에서 만든 샘플보다 더 많은 옵션을 제공하며, 이 샘플은 사용자 정의 파이프의 메커니즘을 설명하기 위해 기본으로 유지되었습니다. 자세한 내용과 다양한 예제는 여기에서 확인할 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:9","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Transformation use case# 유효성 검사는 사용자 정의 파이프의 유일한 사용 사례가 아닙니다. 이 장의 시작에서 파이프가 입력 데이터를 원하는 형식으로 변환할 수도 있다고 언급했습니다. 이는 transform 함수에서 반환된 값이 인수의 이전 값 전체를 완전히 대체할 수 있기 때문에 가능합니다. 이것이 유용한 경우는 언제일까요? 때로는 클라이언트에서 전달된 데이터가 라우트 핸들러 메서드에서 적절하게 처리되기 전에 어떠한 변경을 거쳐야 하는 경우가 있습니다. 예를 들어 문자열을 정수로 변환해야 할 수 있습니다. 또한 일부 필수 데이터 필드가 누락된 경우 기본값을 적용하고 싶을 수 있습니다. 변환 파이프는 이러한 기능을 수행할 수 있으며 클라이언트 요청과 요청 핸들러 사이에 처리 함수를 끼워넣어 작동합니다. 다음은 문자열을 정수 값으로 파싱하는 역할을 담당하는 간단한 ParseIntPipe의 예제입니다. (앞서 언급한 대로 Nest에는 더 정교한 내장 ParseIntPipe가 있습니다. 이것은 사용자 정의 변환 파이프의 간단한 예로 포함되어 있습니다). //parse-int.pipe.ts import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'; @Injectable() export class ParseIntPipe implements PipeTransform\u003cstring, number\u003e { transform(value: string, metadata: ArgumentMetadata): number { const val = parseInt(value, 10); if (isNaN(val)) { throw new BadRequestException('Validation failed'); } return val; } } We can then bind this pipe to the selected param as shown below: @Get(':id') async findOne(@Param('id', new ParseIntPipe()) id) { return this.catsService.findOne(id); } 또 다른 유용한 변환 사례는 요청에서 제공된 ID를 사용하여 데이터베이스에서 기존 사용자 엔터티를 선택하는 것일 수 있습니다: @Get(':id') findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) { return userEntity; } 이 파이프의 구현은 독자에게 맡겨둡니다. 그러나 다른 모든 변환 파이프와 마찬가지로 이는 입력 값(id)을 받아 출력 값(UserEntity 객체)을 반환합니다. 이렇게 하면 공통 파이프로 핸들러에서의 반복 코드를 추상화하여 코드를 더 선언적이고 DRY하게 만들 수 있습니다. ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:10","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["Nest"],"content":"Providing defaults# Parse* 파이프들은 매개변수의 값을 정의되어 있다고 기대합니다. null 또는 undefined 값을 받으면 예외를 throw합니다. 쿼리 문자열 매개변수 값이 누락된 경우에 대비해 엔드포인트가 이를 처리하도록 하려면 Parse* 파이프가 이러한 값을 처리하기 전에 주입될 기본값을 제공해야 합니다. 이를 위해 DefaultValuePipe가 사용됩니다. 간단히 아래와 같이 관련된 Parse* 파이프 앞에 @Query() 데코레이터에서 DefaultValuePipe를 인스턴스화하면 됩니다: @Get() async findAll( @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean, @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number, ) { return this.catsService.findAll({ activeOnly, page }); } ​ ​ ​ ​ ​ ","date":"2024-01-14","objectID":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/:4:11","tags":["Nest"],"title":"Nest Official_02_(Modules, Middleware, Exception_filters, Pipes)","uri":"https://colinder.github.io/nest-official_02_modules-middleware-exception_filters-pipes/"},{"categories":["static type","dynamic type"],"content":"​ ","date":"2024-01-03","objectID":"https://colinder.github.io/staticdynamictype/:0:0","tags":["static type","dynamic type"],"title":"what is 정적(static) \u0026 동적(dynamic) Type","uri":"https://colinder.github.io/staticdynamictype/"},{"categories":["static type","dynamic type"],"content":"정의 정적 타입과 동적 타입은 프로그래밍 언어에서 변수나 값의 타입에 대한 접근 방식을 나타내는 두 가지 주요 패러다임. ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/staticdynamictype/:1:0","tags":["static type","dynamic type"],"title":"what is 정적(static) \u0026 동적(dynamic) Type","uri":"https://colinder.github.io/staticdynamictype/"},{"categories":["static type","dynamic type"],"content":"정적 타입 (Static Typing): 타입 선언: 정적 타입 언어에서는 변수의 타입을 컴파일 시점에 명시적으로 선언합니다. 변수가 어떤 타입을 가질지 사전에 정의해야 합니다. 컴파일 시 타입 체크: 코드를 실행하기 전에 컴파일러가 변수의 타입을 검사합니다. 이로 인해 컴파일러는 타입과 일치하지 않는 연산이나 잘못된 타입의 변수 사용을 사전에 감지할 수 있습니다. 명확한 에러 메시지: 정적 타입 언어에서는 타입 에러가 발생하면 컴파일러가 명확한 에러 메시지를 제공하여 개발자가 런타임에 발생할 수 있는 오류를 사전에 파악할 수 있게 합니다. 예시 언어: Java, C++, TypeScript // TypeScript에서의 정적 타입 예시 // 정적 타입 (TypeScript) let number: number = 42; // 숫자 타입 명시 let text: string = \"Hello, TypeScript\"; // 문자열 타입 명시 // 컴파일러가 타입 오류를 감지할 수 있음 // 아래 코드는 오류를 발생시킴 // number = \"42\"; // 에러: 숫자 타입에 문자열 할당 불가 ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/staticdynamictype/:2:0","tags":["static type","dynamic type"],"title":"what is 정적(static) \u0026 동적(dynamic) Type","uri":"https://colinder.github.io/staticdynamictype/"},{"categories":["static type","dynamic type"],"content":"동적 타입 (Dynamic Typing): 타입 추론: 동적 타입 언어에서는 변수의 타입을 명시적으로 선언하지 않아도 됩니다. 변수는 실행 중에 할당된 값에 따라 동적으로 타입이 결정됩니다. 런타임 시 타입 체크: 코드 실행 중에 변수의 타입이 동적으로 결정되므로 런타임에 타입 오류가 발생할 수 있습니다. 유연성: 동적 타입 언어는 더 유연하며, 변수의 타입을 중간에 변경할 수 있습니다. 이는 편리할 수 있지만, 예측하기 어려운 동작을 초래할 수도 있습니다. 예시 언어: JavaScript, Python, Ruby // JavaScript에서의 동적 타입 예시 // 동적 타입 (JavaScript) let number = 42; // 숫자 let text = \"Hello, JavaScript\"; // 문자열 // 자유로운 타입 변경 number = \"42\"; // 동적으로 타입이 문자열로 변경 ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/staticdynamictype/:3:0","tags":["static type","dynamic type"],"title":"what is 정적(static) \u0026 동적(dynamic) Type","uri":"https://colinder.github.io/staticdynamictype/"},{"categories":["static type","dynamic type"],"content":"차이점: 선언 시점: 정적 타입은 변수를 선언하는 시점에 타입을 명시하고, 동적 타입은 명시적인 선언 없이 런타임에 동적으로 타입이 결정됩니다. 타입 체크 시점: 정적 타입은 컴파일 시점에 타입을 체크하며, 동적 타입은 런타임에 타입을 체크합니다. 에러 발견 시점: 정적 타입은 컴파일 시점에 타입 오류를 발견하므로 런타임 중에는 타입 관련 에러가 발생하지 않습니다. 반면 동적 타입은 런타임 중에도 타입 에러가 발생할 수 있습니다. ​ 두 접근 방식은 각각 장단점이 있으며, 언어의 특성과 개발자의 선호도에 따라 선택됩니다. 정적 타입은 타입 안정성을 높일 수 있지만 코드 작성 시 더 많은 타입 정보를 추가해야 합니다. 동적 타입은 런타임 플렉시빌리티를 제공하지만 런타임 에러 발생 가능성이 높아질 수 있습니다. ​ ​ ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/staticdynamictype/:4:0","tags":["static type","dynamic type"],"title":"what is 정적(static) \u0026 동적(dynamic) Type","uri":"https://colinder.github.io/staticdynamictype/"},{"categories":["typescript","javascript"],"content":"​ Typescript(JS) 함수 선언 방식과 차이 TypeScript는 JavaScript를 기반으로 하는 언어이기 때문에 JavaScript의 함수 선언 방식을 따르면서 몇 가지 추가적인 기능을 제공합니다. 주요 함수 선언 방식은 다음과 같습니다. ​ 함수 선언문 (Function Declaration): function add(a: number, b: number): number { return a + b; } TypeScript에서도 JavaScript와 마찬가지로 함수 선언문을 사용할 수 있습니다. 함수 선언문은 function 키워드로 시작하며, 함수 이름이 바로 뒤에 나옵니다. 호이스팅(hoisting)에 영향을 받습니다. 즉, 선언 전에 호출할 수 있습니다. 함수의 매개변수와 반환값에 타입을 명시할 수 있습니다. ​ 함수 표현식 (Function Expression): const multiply = function(x: number, y: number): number { return x * y; }; TypeScript에서도 JavaScript의 함수 표현식을 그대로 사용할 수 있습니다. 함수 표현식은 변수에 함수를 할당하는 형태입니다. 호이스팅에 영향을 받습니다. 변수 선언은 호이스팅되지만 함수는 그렇지 않습니다. 변수에 함수를 할당하고 타입을 명시할 수 있습니다. ​ 화살표 함수 (Arrow Function): const divide = (x: number, y: number): number =\u003e x / y; TypeScript에서도 JavaScript의 화살표 함수를 그대로 사용할 수 있습니다. 매개변수와 반환값에 타입을 명시할 수 있습니다. ES6에서 도입된 화살표 함수는 간결하고 익명 함수를 간편하게 작성할 수 있는 형태입니다. 함수 내부의 this는 화살표 함수를 감싸고 있는 가장 가까운 함수의 this를 가져옵니다. ​ 메서드 (Method): class Calculator { add(a: number, b: number): number { return a + b; } } TypeScript에서는 클래스 내에 메서드를 정의할 수 있습니다. 메서드는 클래스에 속하며, 인스턴스 또는 클래스 자체에 호출할 수 있습니다. ​ 생성자 함수 (Constructor Function): class Person { constructor(public name: string, public age: number) {} } const person1 = new Person(\"John\", 30); TypeScript에서도 JavaScript와 동일하게 클래스를 이용하여 생성자 함수를 만들 수 있습니다. 생성자 함수로 객체를 생성할 때 매개변수의 타입과 속성을 명시할 수 있습니다. new 키워드를 사용하여 객체를 생성하는 함수입니다. 생성된 객체의 프로토타입은 해당 생성자 함수의 프로토타입과 연결됩니다. ​ TypeScript의 주요 특징은 정적 타입 검사를 통한 안정성을 제공하는 것이므로, 함수의 매개변수와 반환값에 명시적으로 타입을 지정하여 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. ​ ​ ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/js_method/:0:0","tags":["typescript","javascript"],"title":"Typesciprt(JS)_함수선언방법과 차이","uri":"https://colinder.github.io/js_method/"},{"categories":["Nest"],"content":"​ Introduction Nest.js 는 효율적이고 확장가능한 node.js SSR을 구축하기 위한 프레임워크. Nest.js는 *progressive(점진적인) JavaScript를 사용하며. TypeScript를 지원(javascript로 개발도 가능) 그리고 OOP(객체 지향 프로그래밍), FP(기능적 프로그래밍), FRP(기능적 반응 프로그래밍)의 요소들을 결합합니다. 후드 아래에서 Nest는 Express(기본값)와 같은 강력한 HTTP 서버 프레임워크를 사용하며 Fastify를 사용하도록 구성할 수도 있습니다! Nest는 이러한 일반적인 Node.js 프레임워크(Express/Fastify) 이상의 추상화 수준을 제공하지만 개발자에게 API를 직접 노출시킵니다. 이를 통해 개발자는 기본 플랫폼에 수많은 타사 모듈을 사용할 수 있습니다. *progressive JavaScript: 웹과 네이티브 엡을 모두 대응하는 등 점진적인 방법론을 javascript를 통해 개발하는 개념. ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:0:0","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Philosophy 최근 몇년, node.js 덕분에 javascript는 프론트와 백엔드 애플리케이션 모두의 *lingua franca가 되었습니다. 이것은 개발자의 생산성을 향상시키고 빠르고 테스트 가능하며 확장 가능한 프론트엔드 애플리케이션의 생성을 가능하게 하는 Angular, React 및 Vue와 같은 멋진 프로젝트를 탄생시켰습니다. 그러나 Node(그리고 서버측 자바스크립트)를 위한 훌륭한 라이브러리, 도우미 및 도구는 많이 존재하지만, 그 중 어느 것도 아키텍처의 주요 문제를 효과적으로 해결하지는 못합니다. Nest는 *Out-of-the-box 애플리케이션 아키텍처를 제공하여 개발자와 팀이 고도로 테스트 가능하고 확장 가능하며 느슨하게 결합되고 쉽게 유지 관리할 수 있는 애플리케이션을 만들 수 있습니다. 이 아키텍처는 Angular에서 많은 영감을 받았습니다. *lingua franca: 서로 다른 모어를 사용하는 화자들이 의사소통을 하기 위해 국제어 *Out-of-the-box: 해당 제품이나 서비스를 추가적인 구성이나 변경 없이도 바로 사용할 수 있는 상태) ​ ​ ​ Overview ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:1:0","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"First step ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:2:0","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"step 설치된 NPM을 활용해 Nest CLI로 새로운 프로젝트를 실행하는 것은 쉽습니다. $ npm i -g @nestjs/cli $ nest new project-name HINT To create a new project with TypeScript’s stricter feature set, pass the --strict flag to the nest new command. ‘project-name’ 디렉토리가 생성되고, 노드 모듈 및 기타 몇 개의 보일러 플레이트 파일이 설치되며, ‘src/’ 디렉토리가 생성되고 여러 개의 코어 파일로 채워집니다. src └ app.controller.spec.ts └ app.controller.ts └ app.module.ts └ app.service.ts └ main.ts ​ 다음은 이러한 핵심 파일에 대한 간략한 개요입니다: app.controller.ts A basic controller with a single route. app.controller.spec.ts The unit tests for the controller. app.module.ts The root module of the application. app.service.ts A basic service with a single method. main.ts The entry file of the application which uses the core function NestFactory to create a Nest application instance. ​ main.ts에는 비동기 기능이 포함되어 있어 애플리케이션을 부트스트랩(초기화)합니다: // main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); } bootstrap(); Nest 응용 프로그램 인스턴스를 생성하기 위해 코어 NestFactory 클래스를 사용합니다. NestFactory는 응용 프로그램 인스턴스를 생성할 수 있는 몇 가지 정적 메서드를 공개합니다. create() 메서드는 INestApplication 인터페이스를 충족하는 응용 프로그램 객체를 반환합니다. 이 객체는 다음 장에서 설명하는 일련의 메서드를 제공합니다. 위의 main.ts 예제에서는 간단히 HTTP 수신기를 시작하여 응용 프로그램이 인바운드 HTTP 요청을 대기하도록 합니다. Nest CLI로 프로젝트를 생성하면 각 모듈을 별도의 디렉터리에 유지하는 규칙을 따르도록 하는 초기 프로젝트 구조가 생성됩니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:2:1","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Running the application 설치 프로세스가 완료되면 OS 명령 프롬프트에서 다음 명령을 실행하여 인바운드 HTTP 요청에 대한 응용 프로그램 수신을 시작할 수 있습니다: $ npm run start HINT To speed up the development process (x20 times faster builds), you can use the SWC builder by passing the -b swc flag to the start script, as follows npm run start -- -b swc. 여러분의 파일이 변경되는 것을 바로 확인하고 싶다면, 아래 명령어로 실행하세요 $ npm run start:dev 이 명령어는 파일의 변화를 추적할 것이며, 서버를 자동으로 재컴파일하고, 다시 실행 합니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:2:2","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Linting and formatting CLI는 최선을 다해 규모에 따라 신뢰할 수 있는 개발 워크플로우의 기틀을 제공합니다. 따라서, 생성된 Nest 프로젝트는 코드 라이너와 포맷터(respectively eslint and prettier)가 미리 설치되어 있습니다. HINT Not sure about the role of formatters vs linters? Learn the difference here. 최대한의 안정성과 확장성을 보장하기 위해 기본 에슬린트와 더 예쁜 클리 패키지를 사용합니다. 이 설정을 통해 디자인에 의한 공식 확장 기능과 깔끔한 IDE 통합이 가능합니다. IDE와 관련이 없는 헤드리스 환경(Continuous Integration, Git hook 등)의 경우 Nest 프로젝트는 즉시 사용할 수 있는 스크립트와 함께 제공됩니다. // Lint and autofix with eslint $ npm run lint // Format with prettier $ npm run format ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:2:3","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Controllers 요청을 처리하고 클라이언트에 대한 응답을 반환하는 역할을 합니다. 컨트롤러의 목적은 애플리케이션에 대한 특정 요청을 수신하는 것입니다. 라우팅 메커니즘은 어떤 컨트롤러가 어떤 요청을 수신하는지를 제어합니다. 종종, 각각의 컨트롤러는 하나 이상의 루트를 가지며, 다른 루트는 다른 동작을 수행할 수 있습니다. 기본 컨트롤러를 만들기 위해 클래스와 데코레이터를 사용합니다. 데코레이터는 클래스를 필요한 메타데이터와 연결하고 Nest가 라우팅 맵(해당 컨트롤러에 요청을 연결)을 만들 수 있도록 합니다. ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:0","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Routing 아래 예시에서 기본 컨트롤러를 정의하는 데 필수인 @Controller() 데코레이터를 사용할 것입니다. cat을 route path의 prefix로 지정합니다. @Controller() 데코레이터에서 path prefix를 사용하면 관련된 일련의 경로를 쉽게 그룹화할 수 있고 반복되는 코드를 최소화할 수 있습니다. 예를 들어, 우리는 경로 /cats 아래에서 cat 엔티티와의 상호 작용을 관리하는 path 집합을 그룹화할 수 있습니다. 해당 경우, 우리는 파일의 각 경로에 대해 경로의 그 부분을 반복할 필요가 없도록 @Controller() 데코레이터에서 path perfix를 'cats'으로 지정할 수 있습니다.1️⃣ import { Controller, Get } from '@nestjs/common'; @Controller('cats') //1️⃣ export class CatsController { @Get() findAll(): string { //2️⃣ return 'This action returns all cats'; } } HINT CLI를 사용해서 컨드롤러를 생성하려 한다면, 간단히 $ nest g controller [name] 명령어를 실행하면 됩니다. findAll() 메서드 앞에 있는 @Get() HTTP request method decorator는 Nest에게 HTTP request에 대한 특정 엔드포인트에 대한 핸들러를 작성하도록 지시합니다. 엔드포인트는 HTTP 요청 방식(이 경우 GET) 및 route path에 해당합니다. ​ 그런데 route path는 무엇일까요? 핸들러(연결자)인 route path는 컨트롤러에 의해 선언된 perfix(선택사항 임)와 동작할 함수 데코레이터에 지정된 경로를 연결하여 완성됩니다. (아래 예시 글을 보며 이해해봅시다.) route를 ‘cats’로 선언했고 이후에 다른 route 정보를 데코레이터에 선언하지 않았기 때문에, Nest는 /cats으로 접수된 GET 요청을 연결합니다. 언급한 바와 같이 path는 개발자가 의도적으로 작성한 perfix 경로 컨트롤러와 함수 데코레이터에 선언된 임의의 경로 문자열을 모두 포함(동일한 것으로 간주)합니다. 예를 들어, @Controller(‘cats’)안에 데코레이터 @Get(‘breed’)를 같이 사용하면 /cats/breed와 같은 GET 요청에 대한 경로 매핑을 생성합니다. import { Controller, Get } from '@nestjs/common'; @Controller('cats') export class CatsController { @Get() findAll(): string { return 'This action returns all cats'; } @Get('bread') OMG(): string { return 'This breadbreadbreadbread'; } } 위의 예제에서 이 엔드포인트에 GET 요청이 있을 때 Nest는 요청을 사용자 정의 findAll() 메서드로 라우팅합니다. 2️⃣ 여기서 우리가 선택하는 메서드 이름(findAll(), OMG()…)은 완전히 임의적입니다. 경로를 바인딩할 메서드를 분명히 선언해야 하지만 Nest는 선택한 메서드 이름에 아무런 의미를 부여하지 않습니다. (그냥 만들고 싶은 이름으로 만들면 됩니다.) ​ 이 함수는 HTTP response 200 state를 반환하는데, 단순히 문자열에 불과합니다. 왜 이렇게 될까요? 설명하기 위해 Nest의 두 가지 다른 옵션을 사용하는 개념을 소개합니다. Standard (recommended) 내장 함수를 사용하는 경우 핸들러는 자바스크립트의 객체 또는 배열을 반환하는데 이는 자동으로 JSON으로 직렬화 됩니다. 그러나 자바스크립트의 원시타입(e.g., 문자열, 숫자형, 참거짓)을 반환하는 경우, Nest는 직렬화하지 않고 값만 반환합니다. 이렇게 하면 응답 관리가 간단해집니다: 간단히 값만 반환하면되고, 나머지는 Nest가 처리합니다. (e.g.,상태 코드) 또 상태 코드의 응답은 기본적으로 200이 default입니다. POST는 201을 사용합니다. 상태 코드를 바꿔서 반환(응답)하고 싶다면, ‘@HttpCode(…)’ 데코레이터를 사용하면 됩니다. Library-specific 우리는 method handler signature 기술인 @Res() 데코레이터를 사용하여 라이브러리별 (e.g., Express) 응답 객체를 사용할 수도 있습니다. (e.g., findAll(@Res() response)) 이 방법을 사용하면 해당 객체에서 노출된 기본 응답 처리 메서드를 사용할 수 있습니다. 예를 들어 Express를 사용하면 response.status(200).send()와 같은 코드를 사용하여 응답을 구성할 수 있습니다. WARNING Nest detects when the handler is using either @Res() or @Next(), indicating you have chosen the library-specific option. If both approaches are used at the same time, the Standard approach is automatically disabled for this single route and will no longer work as expected. To use both approaches at the same time (for example, by injecting the response object to only set cookies/headers but still leave the rest to the framework), you must set the passthrough option to true in the @Res({ passthrough: true }) decorator. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:1","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Request object 핸들러는 클라이언트 요청에 대한 상세한 정보에 접근할 필요가 있는 경우가 많습니다. Nest는 기본 플랫폼의 요청 객체에 대한 접근을 제공합니다(Express by default). 핸들러의 시그니처에 @Req() 데코레이터를 추가하여 Nest에 지시함으로써 요청 객체에 접근할 수 있습니다. import { Controller, Get, Req } from '@nestjs/common'; import { Request } from 'express'; @Controller('cats') export class CatsController { @Get() findAll(@Req() request: Request): string { console.log(request) // 👈 return 'This action returns all cats'; } } HINT In order to take advantage of express typings (as in the request: Request parameter example above), install @types/express package. 요청 개체는 HTTP 요청을 나타내며 요청 쿼리 문자열, 매개 변수, HTTP 헤더 및 본문에 대한 속성을 가집니다(read more here). 대부분의 경우, 이런 속성들을 수동적으로 확인하는 것은 필요하지 않습니다. 우리는 특정 데코레이터를 사용할 수 있습니다. 예를 들어 @Body() or @Query(), 같은 것들을 별도의 설치 없이(out of the box) 사용할 수 있습니다. 아래 리스트들은 Nest에서 제공하는 데코레이터이며, 간단하게 사용 가능한 것들 입니다. @Request(), @Req() req @Response(), @Res() res @Next() next @Session() req.session @Param(key?: string) req.params / req.params[key] @Body(key?: string) req.body / req.body[key] @Query(key?: string) req.query / req.query[key] @Headers(name?: string) req.headers / req.headers[name] @Ip() req.ip @HostParam() req.hosts HTTP 플랫폼(e.g., Express and Fastify) 간의 typings 호환성을 위해, Nest는 @Res() and @Response() 데코레이터를 제공합니다. @Res()는 @Response()의 별칭일 뿐입니다. 이 두 데코레이터는 개발자에게 HTTP 플랫폼의 기본 응답 객체에 직접 접근할 수 있게 해줍니다. 이것들을 사용할 때 모든 이점을 얻기 위해서는 당신은 라이브러리를 import해서 사용해야 합니다. @Res() 또는 @Response()를 메서드 핸들러에 주입할 때는 해당 핸들러에 대해 Nest를 라이브러리별 모드로 전환하고 응답을 관리하는 책임이 당신에게 있음을 주의하세요. 이렇게 할 때는 ‘response’ 개체(e.g., res.json(...) or res.send(...))를 호출하여 어떤 종류의 응답을 발행해야 합니다. 그렇지 않으면 HTTP 서버가 중단됩니다. HINT To learn how to create your own custom decorators, visit this chapter. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:2","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Resources 앞서 우리는 cats 리소스를 가져올 엔드포인트(GET route)에 대하여 정의 했습니다. 또한 일반적으로 새 레코드를 생성하는 엔드포인트를 제공하고자 합니다. 이를 위해 POST 핸들러를 만들어 보겠습니다: // cats.controller.ts import { Controller, Get, Post } from '@nestjs/common'; @Controller('cats') export class CatsController { @Post() create(): string { return 'This action adds a new cat'; } @Get() findAll(): string { return 'This action returns all cats'; } } 간단하죠. Nest는 모든 기본 HTTP 메서드를 위한 데코레이터를 제공합니다. @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), and @Head(). 또 @All()은 이 모든 데코레이터를 처리하는 엔드포인트 입니다. 예를 들어 /cats 에 대하여 @Get(), @Post() 두 메서드만 정의했고 @All()을 추가로 정의한 경우, /cats으로 @Put(), @Delete(), @Patch(), @Options(), and @Head() 요청을 보내면 @All()메서드가 응답합니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:3","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Route wildcards# 패턴에 기반한 routes도 지원합니다. 예로 asterisk(*)는 와일드카드로 사용되며 모든 문자 조합과 매칭됩니다. @Get('ab*cd') findAll() { return 'This route uses a wildcard'; } 'ab*cd' route path는 abcd, ab_cd, abecd 등과 연결됩니다. ?, +, * 및 () 문자는 route path에 사용될 수 있으며 정규식 대응의 하위 집합입니다. 하이픈(-)과 점(.)은 문자열 기반 경로로 문자 그대로 해석됩니다. WARNING A wildcard in the middle of the route is only supported by express. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:4","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Status code# 이전에 언급했듯이, status code는 기본적으로 항상 200이 기본값입니다. POST는 예외적으로 201입니다. 이는 간단히 바꿀 수 있는데 핸들러 작성 단계에서 @HttpCode(...)를 추가 하면 됩니다. import { Post, HttpCode } from '@nestjs/common'; @Post() @HttpCode(204) create() { return 'This action adds a new cat'; } HINT Import HttpCode from the @nestjs/common package. WARNING @All() 이후 @Post()를 작성하면 호이스팅이 되지 않는다! 우선 순위를 고려하면 개발해야함. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:5","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Headers# 특별히 응답 header를 커스텀하고 싶다면, @Header()데코레이터나, 라이브러리별 응답 개체를 사용하고 res.header()를 직접 호출하면 됩니다. import { Post, Header } from '@nestjs/common'; @Post() @Header('Cache-Control', 'none') create() { return 'This action adds a new cat'; } ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:6","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Redirection# 특정 URL로 리다이렉션 하기 위해서는 @Redirect()데코레이터나, 라이브러리별 응답 객체를 사용하고, res.redirect()를 직접 호출하면 됩니다. @Redirect() 는 두개의 인자가 필요합니다., url과 statusCode, 둘 다 필수값은 아니며, 생략할 경우 기본 status code는 302입니다. @Get() @Redirect('https://nestjs.com', 301) HINT 가끔씩 동적으로 HTTP 상태 코드나 리디렉션 URL을 보내고 싶을 때가 있을 것입니다. 이럴 땐, (@nestjs/common의) HttpRedirectResponse 인터페이스를 따르는 객체를 반환하면 됩니다. 메서드가 return 값(e.g, URL)을 반환하면, 이 값은 데코레이터에 전달된 기존의 인수를 오버라이드(덮어쓰기)한다. 예를 들어 @Get('docs') @Redirect('https://docs.nestjs.com', 302) getDocs() { return { url: 'https://naver.com' }; } 해당 경우 응답이 naver로 덮어써진다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:7","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Route parameters# 요청의 일부로 동적 데이터를 수신할 필요가 있을 때,정적 path의 routes는 동작하지 않습니다. (e.g., GET /cats/1 to get cat with id 1). 매개변수가 있는 routes를 정의하기 위해, routes에 매개변수 tokens을 추가하여 요청 URL의 해당 위치에서 동적값을 활용할 수 있습니다. @Get()데코레이터안에 route 매개변수 token를 사용한 아래의 예시를 봅시다. route 매개변수가 아래와 같이 선언되었다면, @Param() 데코레이터를 사용해서 접근하고 사용할 수 있습니다. HINT route 매개변수를 사용할 때, 매개변수가 포함된 route는 정적 path를 선언한 후에 작성되어야 한다. 이렇게 하면, 정적 path의 트래픽이 매개변수가 담긴 path에 의해 방해받는 것을 방지할 수 있다. 예를 들어 /users/profile, /users/:id 두개의 라우트가 선언 되어 있을 때 ‘/users/profile’ 먼저 선언되어 있어야한다. 그렇지 않으면, :id 파라미터가 “profile\"이라는 값을 캡쳐하게 되어, 의도하지 않은 동작을 유발할 수 있다. import { Get, Param } from '@nestjs/common'; @Get(':id') findOne(@Param() params: any): string { return `This action returns a #${params.id} cat`; } @Param()은 메서드 매개변수(위 예시의 ‘params’)를 장식하는 데 사용된다. 이렇게 하면 라우트 파라미터가 메서드 함수 내에서 변수의 속성으로 사용할 수 있습니다. 위 코드에서 볼 수 있듯이, params.id를 참조하여 id 매개변수에 접근할 수 있다. 데코레이터에 특정 파라미터 토큰을 전달하면, 메서드 본문에서 route 매개변수를 이름으로 직접 참조할 수 있습니다. import { Get, Param, Bind } from '@nestjs/common'; @Get(':id') @Bind(Param('id')) findOne(id) { return `This action returns a #${id} cat`; } 단, @Get(’:id’) / @Bind(Param(‘id’)) 와 같이 @Get(':')의 :뒤에 문자와 @Bind(Param('')) ''안의 문자가 동일해야 합니다. 또 아래와 같이 사용할 수 있습니다. import { Get, Param } from '@nestjs/common'; @Get(':id') findOne(@Param('id') id: string): string { return `This action returns a #${id} cat`; } ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:8","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Sub-Domain Routing# @Controller 데코레이터는 호스트 옵션을 사용하여 들어오는 요청의 HTTP 호스트가 특정 값과 일치하도록 요구할 수 있습니다. @Controller({ host: 'admin.example.com' }) export class AdminController { @Get() index(): string { return 'Admin page'; } } WARNING Since Fastify lacks support for nested routers, when using sub-domain routing, the (default) Express adapter should be used instead. route path와 마찬가지로 hosts 옵션은 토큰을 사용하여 호스트 이름에서 해당 위치의 동적 값을 캡처할 수 있습니다. 아래 @Controller() 데코레이터 예제의 호스트 매개변수 토큰은 이 사용법을 보여줍니다. 이런 방법으로 선언된 호스트 매개변수는 @HostParam() 데코레이터를 사용하여 접근할 수 있으며, 이 데코레이터는 메서드 시그니처에 추가되어야 합니다. @Controller({ host: ':account.example.com' }) export class AccountController { @Get() getInfo(@HostParam('account') account: string) { return account; } } ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:9","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Scopes# Nest에서는 거의 모든 것이 들어오는 요청 간에 공유된다. 예를 들어 데이터베이스에 대한 연결 풀, 글로벌 상태의 singleton services(싱글톤 서비스) 등이 있습니다. Node.js는 모든 요청이 별도의 스레드에 의해 처리되는 요청/응답 다중 스레드 상태 비저장 모델을 따르지 않는다는 점을 기억하십시오. 따라서 싱글톤 인스턴스를 사용하는 것은 우리의 응용 프로그램에 완전히 안전합니다. singleton services 객체의 인스턴스가 오직 1개만 생성하여 사용하는 것을 의미합니다. 생성자를 여러 번 호출하더라고 실제 생서되는 각체는 하나이며 최초로 생성된 이후에 호출된 생성자는 이미 생성한 객체를 반환시키도록 만드는 것입니다. 즉, 어플리케이션이 시작될 때 어떤 클래스가 최로 한 번만 메모리를 할당(static)하고 그 메모리에 인스턴스를 만들어 사용하는 서비스입니다. var SingletonService = (function () { // 1. private 변수 var instance; // 2. private 생성자 function SingletonService() { // 객체 초기화 코드 } // 3. 싱글톤 객체 생성 또는 기존 객체 반환 function createInstance() { if (!instance) { instance = new SingletonService(); } return instance; } // 4. 외부에서 접근 가능한 메서드 (public method) return { getInstance: function () { return createInstance(); } }; })(); // 테스트 var singletonA = SingletonService.getInstance(); var singletonB = SingletonService.getInstance(); console.log(singletonA === singletonB); // true, 같은 인스턴스를 공유하고 있음 ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:10","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Asynchronicity# (비동기성) 우리는 최신 JavaScript를 사랑하며 데이터 추출이 대부분 비동기식이라는 것을 알고 있습니다. 그렇기 때문에 Nest는 비동기 함수를 지원하고 잘 작동합니다. HINT Learn more about async / await feature here ​ 모든 비동기 함수는 promise 타입을 반환해야 합니다. 이것은 Nest가 스스로 해결할 수 있는 연기된(deferred) 값을 반환할 수 있다는 것을 의미합니다. 이에 대한 예시를 살펴보겠습니다. @Get() async findAll(): Promise\u003cany[]\u003e { return []; } 위의 코드는 완전히 유효합니다. 더욱 강력한 것은 Nest 라우트 핸들러가 *RxJS observable streams을 반환할 수 있다는 점입니다. Nest는 자동으로 소스에 구독하고 스트림이 완료되면 마지막으로 전달된 값을 가져옵니다. @Get() findAll(): Observable\u003cany[]\u003e { return of([]); } 위의 두 가지 접근 방식은 모두 작동하며 요구 사항에 맞는 모든 것을 사용할 수 있습니다. *RxJS(Reactive Extensions for JavaScript)는 자바스크립트에서 반응형 프로그래밍을 구현하기 위한 라이브러리입니다. “Observable\"은 RxJS에서 중요한 개념 중 하나로, 이는 비동기적인 이벤트나 데이터 스트림을 다루는데 사용됩니다. Observable은 데이터나 이벤트의 스트림을 나타내는데, 이 스트림은 시간에 따라 여러 값을 방출할 수 있습니다. 이러한 값을 Observer가 관찰하고, 스트림의 상태에 따라 특정 작업을 수행할 수 있습니다. 간단히 말해, RxJS observable은 비동기적인 이벤트 또는 데이터 스트림을 나타내며, 해당 스트림에서 발생하는 변화에 대응하여 작업을 수행할 수 있는 방법을 제공합니다. Nest.js와 같은 프레임워크에서는 이러한 Observable을 사용하여 비동기적인 작업을 효율적으로 다룰 수 있습니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:11","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Request payloads# 이전에 예를 보면 POST 요청의 처리에서 클라이언트 데이터를 받지 못했습니다. 여기에 @Body()데코레이터를 추가해 수정해보겠습니다. 그런데 먼저 (당신이 typescript를 사용한다면) 우리는 DTO(Data Transfer Object) 스키마를 결정해야 합니다. DTO는 데이터가 네트워크를 통해 전송되는 방식을 정의하는 개체입니다. TypeScript 인터페이스를 사용하거나 간단한 클래스를 사용하여 DTO 스키마를 결정할 수 있습니다. 흥미롭게도 여기서는 클래스를 사용하는 것을 권장합니다. 왜인가요? 클래스는 자바스크립트 ES6 표준의 일부이므로 컴파일된 자바스크립트에서 실제 엔티티로 보존됩니다. 반면에 TypeScript 인터페이스는 컴파일 중에 제거되므로 Nest는 실행중일 때 해당 인터페이스를 참조할 수 없습니다. *Pipes와 같은 기능이 런타임에 변수의 메타타입에 액세스할 수 있을 때 추가적인 가능성을 지원하기 때문에 중요합니다. *Nest.js의 Pipes는 입력 데이터의 변환 또는 유효성 검사와 같은 특정 작업을 수행하는데 사용됩니다. Pipes는 메타데이터(metatype)에 접근할 수 있어야 하는 경우가 있는데, 이는 런타임(runtime)에서 변수의 유형 및 다른 정보를 알아내는 것을 의미합니다. 메타데이터를 사용하면 Pipes가 동적으로 동작하고 입력 데이터에 대해 적절한 작업을 수행할 수 있습니다. 예를 들어, 데이터 유효성 검사를 수행하는 Pipe는 입력 데이터의 유형이나 기타 속성을 알아야 합니다. 이를 위해 Pipes는 런타임에서 변수의 메타데이터를 확인할 수 있어야 합니다. Let’s create the CreateCatDto class: export class CreateCatDto { name: string; age: number; breed: string; } It has only three basic properties. Thereafter we can use the newly created DTO inside the CatsController: 기본 속성은 세 가지뿐입니다. 이제 CatsController안에서 새로 만든 DTO를 사용할 수 있습니다: @Post() async create(@Body() createCatDto: CreateCatDto) { return 'This action adds a new cat'; } HINT Our ValidationPipe는 메서드 핸들러가 수신해서는 안 되는 속성을 필터링할 수 있다. 이 경우 허용되는 속성을 화이트리스트에 추가할 수 있으며, 화이트리스트에 포함되지 않은 속성은 결과 개체에서 자동으로 제거된다. In the CreateCatDto example, our whitelist is the name, age, and breed properties. Learn more here. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:12","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Handling errors# There’s a separate chapter about handling errors (i.e., working with exceptions) here. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:13","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Full resource sample# 아래는 사용 가능한 여러 데코레이터를 사용하여 기본 컨트롤러를 만드는 예입니다. 이 컨트롤러는 내부 데이터에 접근하고 조작할 수 있는 몇 가지 방법을 공개합니다. import { Controller, Get, Query, Post, Body, Put, Param, Delete } from '@nestjs/common'; import { CreateCatDto, UpdateCatDto, ListAllEntities } from './dto'; @Controller('cats') export class CatsController { @Post() create(@Body() createCatDto: CreateCatDto) { return 'This action adds a new cat'; } @Get() findAll(@Query() query: ListAllEntities) { return `This action returns all cats (limit: ${query.limit} items)`; } @Get(':id') findOne(@Param('id') id: string) { return `This action returns a #${id} cat`; } @Put(':id') update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) { return `This action updates a #${id} cat`; } @Delete(':id') remove(@Param('id') id: string) { return `This action removes a #${id} cat`; } } HINT Nest CLI는 모든 보일러 플레이트 코드를 자동으로 생성하는 발전기(도형)를 제공하여 이 모든 것을 방지하고 개발자가 훨씬 쉽게 경험할 수 있도록 도와줍니다. 이 기능에 대한 자세한 내용은 here에서 확인하십시오. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:14","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Getting up and running# 위 컨트롤러가 완전히 정의된 상태에서 Nest는 여전히 CatsController가 존재한다는 것을 알지 못하며 결과적으로 이 클래스의 인스턴스를 만들지 않습니다. 컨트롤러는 항상 모듈에 속하기 때문에, 이는 왜 우리가 @Module()안에 controllers들을 넣어야 하는 가의 답입니다. 우리는AppModule을 제외한 어떤 모듈도 정의하지 않았기 때문에, CatsController를 사용해서 정의해보겠습니다. // app.module.ts import { Module } from '@nestjs/common'; import { CatsController } from './cats/cats.controller'; @Module({ controllers: [CatsController], }) export class AppModule {} @Module() 데코레이터를 이용하여 모듈 클래스에 메타데이터를 연결했으며, Nest는 탑재해야 하는 컨트롤러를 쉽게 반영할 수 있게 되었습니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:15","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Library-specific approach# 지금까지 우리는 Nest 표준 응답 조작 장법에 대하여 이야기했습니다. 응답을 다루는 두 번째 방법은 라이브러리 별 응답 개체(library-specific response object)를 사용하는 것입니다. 특정 응답 객체를 주입하기 위해서는 @Res()데코레이터를 사용하면 됩니다. 차이점을 보이기 위해 CatsController 를 다시 작성해보겠습니다. import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common'; import { Response } from 'express'; @Controller('cats') export class CatsController { @Post() create(@Res() res: Response) { res.status(HttpStatus.CREATED).send(); } @Get() findAll(@Res() res: Response) { res.status(HttpStatus.OK).json([]); } } 비록 이 방식이 작동하고 실제로 응답 객체에 대한 완전한 제어를 제공하여 헤더 조작, 라이브러리별 기능 등에서 어느 정도의 유연성을 허용하지만, 이는 주의해서 사용해야 합니다. 일반적으로 이 방식은 훨씬 명확하지 않으며 몇 가지 단점이 있습니다. 주요 단점은 코드가 플랫폼에 의존적이 되며(기본 라이브러리에서 응답 객체에 대한 API가 다를 수 있음), 테스트하기 어려워진다는 것입니다(응답 객체를 목업해야 할 필요가 있습니다 등). 또한 위의 예제에서는 Nest 표준 응답 처리에 의존하는 Interceptor 및 @HttpCode() / @Header() 데코레이터와 같은 Nest 기능과의 호환성이 손실됩니다. 이를 해결하려면 다음과 같이 passthrough 옵션을 true로 설정할 수 있습니다: @Get() findAll(@Res({ passthrough: true }) res: Response) { res.status(HttpStatus.OK); return []; } 이제 특정 조건에 따라 쿠키나 헤더를 설정하는 등 네이티브 응답 객체와 상호 작용할 수 있지만, 나머지는 프레임워크에 맡겨둘 수 있습니다. ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:3:16","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Providers 프로바이더는 Nest에서의 기본적인 개념 중 하나입니다. 많은 기본 Nest 클래스는 프로바이더로 취급될 수 있습니다 - 서비스, 리포지토리, 팩토리, 헬퍼 등입니다. 프로바이더의 주요 아이디어는 이를 의존성으로 주입할 수 있다는 것입니다. 이는 객체들이 서로 다양한 관계를 생성할 수 있고, 이러한 객체들을 ‘연결’하는 기능을 대부분 Nest 런타임 시스템에 위임할 수 있다는 것을 의미합니다. 이전 장에서 우리는 간단한 CatsController를 만들었습니다. 컨트롤러는 HTTP 요청을 처리하고 더 복잡한 작업을 프로바이더에게 위임해야 합니다. 프로바이더는 모듈에서 프로바이더로 선언된 일반적인 JavaScript 클래스입니다. HINT Nest는 의존성을 더 객체지향적인 방식으로 설계하고 구성할 수 있는 기능을 제공하므로, SOLID 원칙을 따르는 것을 강력히 권장합니다. SOLID 원칙은 다음과 같습니다. 단일 책임 원칙 (Single-responsibility principle): ‘한 클래스가 변경되어야 하는 이유는 오직 하나뿐이어야 합니다.’ 다시 말해, 모든 클래스는 하나의 책임만 가져야 합니다. 개방/폐쇄 원칙 (Open–closed principle): ‘소프트웨어 엔터티는 확장에는 열려있어야 하지만 수정에는 닫혀 있어야 합니다.’ 즉, 기존의 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 합니다. 리스코프 치환 원칙 (Liskov substitution principle): ‘기본 클래스의 포인터나 참조를 사용하는 함수는 그것들을 모르고도 파생 클래스의 객체를 사용할 수 있어야 합니다.’ 계약에 따른 설계도 참고하세요. 인터페이스 분리 원칙 (Interface segregation principle): ‘클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.’ 의존성 역전 원칙 (Dependency inversion principle): ‘추상화에 의존하되 구체화에 의존하지 마십시오.’ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:0","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Services# 간단한 CatsService를 만들어 보겠습니다. 이 서비스는 데이터의 저장 및 검색을 담당하며, CatsController에서 사용될 것으로 예상되므로 프로바이더로 정의하기에 좋은 후보입니다. // cats.service.ts import { Injectable } from '@nestjs/common'; import { Cat } from './interfaces/cat.interface'; @Injectable() export class CatsService { private readonly cats: Cat[] = []; create(cat: Cat) { this.cats.push(cat); } findAll(): Cat[] { return this.cats; } } HINT To create a service using the CLI, simply execute the $ nest g service cats command. 우리의 CatsService는 하나의 속성과 두 개의 메서드를 가진 기본적인 클래스입니다. 유일하게 새로운 기능은 @Injectable() 데코레이터를 사용한다는 것입니다. @Injectable() 데코레이터는 CatsService가 Nest *IoC 컨테이너에서 관리될 수 있는 클래스임을 선언하는 메타데이터를 첨부합니다. 이 예제에서는 아마도 다음과 같이 보이는 Cat 인터페이스도 사용하고 있습니다. ​ *IoC는 “Inversion of Control\"의 약어로, 한국어로는 “제어의 역전\"이라고 번역됩니다. IoC는 소프트웨어 디자인에서 중요한 개념 중 하나로, 일반적으로 의존성 주입(Dependency Injection)과 관련이 있습니다. 기존에는 개발자가 코드의 제어 흐름을 직접 제어하고 구성했습니다. 그러나 IoC에서는 제어의 주도권이 프레임워크나 컨테이너로 넘어가게 됩니다. 이는 개발자가 코드를 작성할 때 일부 제어를 외부에서 받아들이는 개념입니다. 일반적으로 IoC는 다음과 같은 특징을 포함합니다: 의존성 주입(Dependency Injection): 객체가 필요로 하는 의존성을 직접 생성하는 대신, 외부에서 의존성을 주입받는 방식입니다. 이를 통해 코드의 결합도를 낮추고 유연성을 높일 수 있습니다. 제어의 역전: 개발자가 코드의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 제어 흐름이 주어지는 것을 의미합니다. 일반적으로는 컨테이너나 프레임워크가 코드의 실행을 주도하는 구조를 말합니다. // interfaces/cat.interface.ts export interface Cat { name: string; age: number; breed: string; } 이제 고양이를 검색하는 서비스 클래스가 있으니, 이를 CatsController내에서 사용해보겠습니다: // cats.controller.ts import { Controller, Get, Post, Body } from '@nestjs/common'; import { CreateCatDto } from './dto/create-cat.dto'; import { CatsService } from './cats.service'; import { Cat } from './interfaces/cat.interface'; @Controller('cats') export class CatsController { constructor(private catsService: CatsService) {} @Post() async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } @Get() async findAll(): Promise\u003cCat[]\u003e { return this.catsService.findAll(); } } CatsService는 클래스 생성자를 통해 주입됩니다. private 구문을 사용하는 것에 주목하세요. 이 간편한 표기법을 사용하면 catsService 멤버를 동시에 선언하고 초기화할 수 있습니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:1","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Dependency injection# Nest는 보편적으로 알려진 의존성 주입이라는 강력한 디자인 패턴을 기반으로 구축되었습니다. 이 개념에 대한 훌륭한 기사를 읽는 것을 권장합니다. official Angular documentation Nest에서는 TypeScript의 능력 덕분에 의존성을 관리하는 것이 매우 쉽습니다. 왜냐하면 TypeScript는 단순히 타입에 의해 의존성이 해결되기 때문입니다. 아래의 예제에서 Nest는 catsService를 해결하고 CatsService의 인스턴스를 생성하여 반환합니다. (또는 싱글톤의 일반적인 경우에는 이미 다른 곳에서 요청되었다면 기존 인스턴스를 반환합니다) 이 의존성은 해결되고 해당 의존성은 컨트롤러의 생성자로 전달됩니다(또는 지정된 속성에 할당됩니다): constructor(private catsService: CatsService) {} ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:2","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Scopes# 프로바이더는 일반적으로 애플리케이션 라이프사이클과 동기화된 수명(혹은 ‘스코프’)을 갖습니다. 애플리케이션이 부트스트랩될 때 모든 의존성이 해결되어야 하며, 따라서 모든 프로바이더는 인스턴스화되어야 합니다. 마찬가지로 애플리케이션이 종료될 때마다 각 프로바이더가 소멸됩니다. 그러나 프로바이더 수명을 요청 스코프(request-scoped)로 만드는 방법도 있습니다. 이에 대한 자세한 내용은 여기(here)에서 확인할 수 있습니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:3","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Custom providers# Nest는 제공자 간의 관계를 해결하는 내장형 제어의 역전(‘IoC’) 컨테이너를 갖고 있습니다. 이 기능은 위에서 설명한 의존성 주입 기능의 기반이지만, 실제로는 여태까지 설명한 것보다 훨씬 더 강력합니다. 프로바이더를 정의하는 여러 가지 방법이 있습니다: 평범한 값, 클래스, 비동기 또는 동기적인 팩토리를 사용할 수 있습니다. 더 많은 예제는 여기(here)에서 제공됩니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:4","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Optinal providers# 가끔은 해결되지 않아도 괜찮은 의존성이 있을 수 있습니다. 예를 들어, 클래스가 구성 객체에 의존할 수 있지만 전달되지 않으면 기본값을 사용해야 할 수 있습니다. 이 경우 구성 프로바이더가 없어도 오류가 발생하지 않기 때문에 의존성은 선택적이 됩니다. 프로바이더가 선택적임을 나타내려면 생성자의 시그니처에서 @Optional()데코레이터를 사용하십시오.” import { Injectable, Optional, Inject } from '@nestjs/common'; @Injectable() export class HttpService\u003cT\u003e { constructor(@Optional() @Inject('HTTP_OPTIONS') private httpClient: T) {} } 위의 예제에서는 HTTP_OPTIONS 사용자 지정 토큰을 포함하는 사용자 지정 프로바이더를 사용하고 있습니다. 이는 이전 예제에서 생성자 기반 주입을 보여주면서 생성자 내에서 클래스를 통해 의존성을 나타냈던 이유입니다. 사용자 지정 프로바이더 및 관련 토큰에 대한 자세한 내용은 여기(here)에서 확인할 수 있습니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:5","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Property-based injection# 지금까지 사용한 기술은 생성자 기반 주입(Constructor-based Injection)이라고 불립니다. 여기서 프로바이더는 생성자 메서드를 통해 주입됩니다. 매우 특수한 경우에는 속성 기반 주입(Property-based Injection)이 유용할 수 있습니다. 예를 들어, 최상위 클래스가 하나 이상의 프로바이더에 의존하는 경우, 서브 클래스의 생성자에서 super()를 호출하여 모든 프로바이더를 계속 전달하는 것은 매우 번거로울 수 있습니다. 이를 피하기 위해 속성 레벨에서 @Inject() 데코레이터를 사용할 수 있습니다. import { Injectable, Inject } from '@nestjs/common'; @Injectable() export class HttpService\u003cT\u003e { @Inject('HTTP_OPTIONS') private readonly httpClient: T; } WARNING If your class doesn’t extend another class, you should always prefer using constructor-based injection. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:6","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Provider registration# 이제 우리는 프로바이더(CatsService)를 정의했고, 해당 서비스를 사용하는 소비자(CatsController)가 있습니다. 이 서비스를 Nest에 등록하여 주입을 수행할 수 있도록 해야 합니다. 이를 위해 모듈 파일인 (app.module.ts)을 편집하고, 서비스를 @Module() 데코레이터의 providers 배열에 추가합니다. import { Module } from '@nestjs/common'; import { CatsController } from './cats/cats.controller'; import { CatsService } from './cats/cats.service'; @Module({ controllers: [CatsController], providers: [CatsService], }) export class AppModule {} Nest는 이제 CatsController 클래스의 의존성을 해결할 수 있게 될 것입니다. ​ 이제 디렉터리 구조는 다음과 같아야 합니다: src └ cats └ dto └ create-cat.dto.ts └ interfaces └ cat.interface.ts └ cats.controller.ts └ cats.service.ts app.module.ts main.ts ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:7","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":["Nest"],"content":"Manual instantiation(인스턴스(객체)화)# 지금까지 우리는 Nest가 대부분의 의존성 해결 세부 사항을 자동으로 처리하는 방법에 대해 논의했습니다. 특정 상황에서는 내장된 의존성 주입 시스템 밖으로 나가서 프로바이더를 수동으로 검색하거나 인스턴스화해야 할 수 있습니다. 아래에서 두 가지 관련 주제에 대해 간략하게 논의하겠습니다. 기존 인스턴스를 가져오거나 프로바이더를 동적으로 인스턴스화하려면 Module reference를 사용할 수 있습니다. bootstrap() 함수 내에서 프로바이더를 얻으려면(예: 컨트롤러 없이 독립적인 애플리케이션 또는 부트스트래핑 중에 구성 서비스를 활용하기 위한 경우) Standalone applications를 참조하세요. ​ ​ ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/:4:8","tags":["Nest"],"title":"Nest Official_01_(Introduction, First steps, Controllers, Providers)","uri":"https://colinder.github.io/nest-official_01_introduction-first-steps-controllers-providers/"},{"categories":null,"content":"​ 추상화 \u0026 구체화 개발 미팅을 하다보면 자주 듣게 되었는데, 정확한 정의와 의미를 알기 위해 정리합니다. ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/abstraction/:0:0","tags":["abstraction","면접대비"],"title":"what is Abstraction(추상화)?","uri":"https://colinder.github.io/abstraction/"},{"categories":null,"content":"추상화 추상화는 복잡한 시스템, 객체 또는 개념을 단순화하여 핵심 기능에 집중하고 불필요한 세부 사항을 숨기는 프로세스입니다. 이는 문제를 이해하기 쉽게 만들고, 핵심 개념에 집중하여 설계를 간소화하며, 재사용성을 높이는 데 도움이 됩니다. 프로그래밍에서 추상화는 여러 수준에서 발생할 수 있습니다: 데이터 추상화: 데이터를 간소화하거나 숨기는 것으로, 특정 데이터 유형의 세부 정보를 숨기고 핵심 데이터만 표시하는 것을 의미합니다. 이는 객체 지향 프로그래밍에서 클래스와 객체를 사용하여 데이터를 캡슐화하는 것과 관련이 있습니다. 프로세스 추상화: 복잡한 작업이나 알고리즘을 간단한 단계나 함수로 나누어 표현하는 것입니다. 이를 통해 코드를 이해하기 쉽게 만들고, 유지보수를 용이하게 할 수 있습니다. 인터페이스 추상화: 시스템의 일부를 간단한 인터페이스로 정의하는 것으로, 해당 부분의 내부 동작은 숨기고 필요한 부분만 외부로 노출시킵니다. 이는 모듈화와 관련이 있으며, 모듈 간의 결합도를 낮출 수 있습니다. 추상화는 소프트웨어 개발에서 중요한 개념으로, 복잡성을 다루고 코드를 이해하기 쉽고 관리하기 쉽게 만들어줍니다. 추상화는 모델링, 설계 및 구현 단계에서 계속해서 사용되며, 좋은 소프트웨어 아키텍처의 핵심 원칙 중 하나입니다. ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/abstraction/:1:0","tags":["abstraction","면접대비"],"title":"what is Abstraction(추상화)?","uri":"https://colinder.github.io/abstraction/"},{"categories":null,"content":"구체화 구체화(Concretization)는 추상화의 반대 개념으로, 추상적인 개념이나 아이디어를 실제로 구체적인 형태로 나타내거나 실현하는 것을 말합니다. 추상화가 일반적이고 고수준의 개념을 간추려 표현하는 것이라면, 구체화는 그 개념을 실제로 구현하거나 현실 세계에서 구체적인 사물로 만드는 것입니다. 프로그래밍에서 클래스나 인터페이스 등을 정의할 때, 이를 구체화하기 위해 실제 코드를 작성하고 객체를 생성하는 것이 구체화에 해당합니다. 이는 개념을 구현체로 옮겨가게끔 하는 과정이며, 추상화와 함께 프로그래밍에서 중요한 요소 중 하나입니다. ​ ​ 예를 들어, 추상적인 “자동차\"라는 개념이 있다면, 이를 구체화하기 위해서는 실제 자동차 모델을 만들어야 합니다. 추상화는 고수준의 개념을 이해하기 쉽게 단순화하는 것이라면, 구체화는 실제로 그 개념을 구현하고 동작시키는 것입니다. ​ ​ ​ ​ ​ ","date":"2024-01-03","objectID":"https://colinder.github.io/abstraction/:2:0","tags":["abstraction","면접대비"],"title":"what is Abstraction(추상화)?","uri":"https://colinder.github.io/abstraction/"},{"categories":["Computer Science","시간복잡도"],"content":"​ Time Complexity (시간 복잡도) 효율적인 알고리즘 구성을 위해 항상 신경써야하는 시간 복잡도. 그리고 시간 복잡도를 표기하는 방법인 Big-O(빅-오) 표기법에 대해 정리합니다. ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:0:0","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"시간 복잡도 위키백과에 따르면 시간복잡도는 계산복잡도 이론에서 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다. 또 컴퓨터과학에서 알고리즘의 시간복잡도는 입력을 나타내는 문자열 길이의 함수로서 작동하는 알고리즘을 취해 시간을 정량화하는 것인데, 간단히 input 후 연산이 진행되고 output을 반환하는데 시간이 얼마나 걸리는가?를 계산한 값입니다. 조금 더 간단하게는 알고리즘의 수행시간입니다. ​ 위에서 계산한 값이라고 적었는데 이 계산한 값의 표기법 중 하나가 Big-O(빅-오) 표기법입니다. ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:1:0","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"Big-O 표기법 시간복잡도 표기법에는 3가지 방법이 있습니다. Big-O(빅-오) ▶️ 알고리즘이 수행되는데 최악의 시간으로 결과값이 반환되는 경우 (상한 *점근) Big-Ω(빅-오메가) ▶️ 알고리즘이 수행되는데 최선의 시간으로 결과값이 반환되는 경우 (하한 점근) Big-θ(빅-세타) ▶️ 그 둘의 평균 위 세가지 경우 중 주로 Big-O(빅-오) 표기법으로 수행 시간을 고려하는 것이 좋습니다. 최악을 대비하는 것이 더 바람직하기 때문입니다. ​ 점근: 점점 가까워 지는 모양 ? 점근 표기법: 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법. ​ ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:2:0","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"Big-O 표기법의 특징 상수항 무시 빅오 표기법은 데이터 입력값(n)이 충분히 크다고 가정하고 있고, 알고리즘의 효율성 또한 데이터 입력값(n)의 크기에 따라 영향 받기 때문에 상수항 같은 사소한 부분은 무시한다. ex) O(2N) ▶ O(N) 영향력 없는 항 무시 빅오 표기법은 데이터 입력값(n)의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다. ex) O(N^2 + 2N + 1) ▶ O(N^2) ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:2:1","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"Big-O 표기법의 종류 O(1) O(log n) O(n) O(n * log n) O(n^2) O(n^n) ​ 그래프로 보면 성능의 비교가 가능한데 FAST : O(1) — O(log n) — O(n) — O(n * log n) — O(n^2) — O(n^n) SLOW FAST : 상수함수 - 로그함수 - 선형함수 - 로그 함수와 선형 함수의 곱 - 다항함수 - 지수함수 : SLOW (오른쪽으로 갈 수록 속도가 느려진다.) ​ ​ O(1) O(1)는 일정한 복잡도(constant complexity)라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않는다. 입력값의 크기와 관계없이, 즉시 출력값을 반환하는 알고리즘을 의미한다. ## example 1 def hello_world(): return print(\"hello_world\") ## example 2 def O1_algo(list, index): return print(li[index]) li = [1,2,3,4,5,6] idx = 1 O1_algo(li, idx) # li의 길이가 아무리 길어도 idx가 1로 고정임으로 항상, 즉시 출력값을 얻을 수 있다. ​ ​ ​ O(log n) O(log n)은 로그 복잡도(logarithmic complexity)라고 부르며, Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가진다. log n은 보통 log의 밑이 2인 경우를 상정합니다. == $\\log_{2}{n}$ 이는 *이진탐색의 로직과 거의 유사합니다. 예를 들어서 이야기 해보죠. 8개의 값이 주어졌을 때 이진 탐색으로 내가 원하는 값을 찾는 방법입니다. 8 \u003e 4 \u003e 2 \u003e 1 총 3번의 탐색이 필요합니다. (운이 좋으면 1번에 찾을 수도 있지만, 최악의 상황을 가정) $8 = 1 \\times2^3$ 만약 주어진 데이터가 N개고, X번의 탐색으로 통해 1이 되는 경우를 공식화하면 $N = 1 \\times2^X$ 몇 번의 과정을 거쳐야 하는지 즉, 효율을 계산하려면 $X$가 필요하고 이를 구하기 위해 양변에 $\\log_{2}$를 취하면 $X = \\log_{2}{N}$ 자연스럽게 log n의 식이 도출되고 이것이 O(log n) 복잡도입니다. ​ 💡여기서 잠깐, 배열의 크기가 3일 때 이진 검색은 2단계 배열의 크기가 7일 때 이진 검색은 3단계 배열의 크기가 15일 때 이진 검색은 4단계 배열의 크기가 100일때 이진 검색은 7단계 배열의 크기가 10,000일때 이진 검색은 13단계 배열의 크기가 1,000,000일때 이진 검색은 20단계 👉 데이터가 커질수록 단계 수가 늘어나므로 이진 검색은 O(1)이라 표현할 수 없습니다. 👉 검색하고 있는 배열의 원소 수보다 단계 수가 훨씬 적으므로 O(N)이라 표현할 수도 없습니다. ​ O(log n)은 O(1)과 O(N) 사이 어디쯤엔가 있다. 저는 간단히 1/2 연산을 몇번 해야 되는지 알려주는 값이라고 외우고 있습니다. 또는 데이터가 두 배로 증가하면 한 단계씩 늘어나는 알고리즘 ​ 이진탐색: 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교한다. 해당 값을 찾을 때까지 이 과정을 반복 ​ ​ ​ O(n) O(n)은 선형 복잡도(linear complexity)라고 부르며, 입력값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것을 의미한다. 데이터가 늘어날 때 정확히 그 데이터에 비례해 단계 수가 증가하는 알고리즘이다. ## example - li의 길이에 따라 단계 수가 증가 def On_algo(li): for i in li: return print(i) li = [1,2,3,4,5,6,7,8,9,10] ​ ​ ​ O(n * log n) 일반적으로 최적화된 알고리즘의 경우 해당 시간복잡도를 가진다. linear한 단일 컬렉션에 logarithmic한 수행을 반영한 알고리즘이다. ## example - 퀵 정렬(Quick Sort) def quick_sort(arr): if len(arr) \u003c= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x \u003c pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x \u003e pivot] return quick_sort(left) + middle + quick_sort(right) # 예시 리스트 example_list = [38, 27, 43, 3, 9, 82, 10] # 퀵 정렬 수행 sorted_list = quick_sort(example_list) print(\"정렬 전:\", example_list) print(\"정렬 후:\", sorted_list) ​ ​ ​ O(n^2) O(n^2)은 2차 복잡도(quadratic complexity)라고 부르며, 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미한다. 입력값이 1일 경우 1초가 걸리던 알고리즘에 5라는 값을 주었더니 25초가 걸리게 된다면, 이 알고리즘의 시간 복잡도는 O(n^2)라고 표현한다. ## example 1 def O_quadratic(): for i in range(1, 100): for j in range(1, 100): return print(i, j) 간단히 2중 중복문의 경우에 해당합니다. 3중, 10중 중복문의 경우에도 O(n^2)라고 표현합니다. ​ ​ ​ O(2^n) O(2^n)은 기하급수적 복잡도(exponential complexity)라고 부르며, Big-O 표기법 중 가장 느린 시간 복잡도를 가진다. 대표적인 예가 피노나치의 수열인데, 피보나치 수는 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열입니다. [1, 1, 2, 3, 5, 8, ….] def fibonacci(n): if n \u003c= 1: return 1 return fibonacci(n-1) + fibonacci(n-2) 많은 기술 블로그들이 이렇게 코드 짤꺼면 그냥 하지마라. 고 말하곤 합니다.ㅎ ​ ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:2:2","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"복잡도 정량화 비교 Complexity 1 10 100 O(1) 1 1 1 O(log n) 0 2 5 O(n) 1 10 100 O(n log n) 0 20 461 O(n^2) 1 100 10000 O(2^n) 1 1024 1267650600228229401496703205376 ​ ​ ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:2:3","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["Computer Science","시간복잡도"],"content":"시간 복잡도를 구하는 요령 하나의 루프를 사용하여 단일 *컬렉션을 반복하는 경우: O(n) 두 개의 다른 루프를 사용하여(중첩 X) 두 개의 다른 컬렉션을 반복하는 경우: O(n) + O(m) =\u003e O(n) 두 개의 중첩 루프를 사용하여 단일 컬렌션을 반복하는 경우: O(n^2) 두 개의 중첩 루프를 사용하여 두 개의 다른 컬렉션을 반복하는 경우: O(n) * O(m) =\u003e O(n^2) 컬렉션 자료형: 여러가지 요소를 하나로 묶어 사용하는 데이터 타입. python의 경우 시퀀스(리스트, 튜플, 딕셔너리, 레인지), 매핑(딕셔너리), 집합 등이 있다. ​ ​ ​ ​ ​ ​ ​ ​ ​ 👀 마치면서.. 사실 이론은 복잡하지 않습니다. 이 정리를 통해 어느 정도 이해할 수 있었다면, 실제 개발에서 효율을 고려하며 개발한다.를 적용할 수 있도록 코드마다 시간복잡도를 생각하면서 개발하는 노력이 필요할 것 같습니다. ​ ​ ​ ​ ​ ","date":"2023-10-17","objectID":"https://colinder.github.io/time_complexity/:3:0","tags":["CS","시간복잡도","computer science","면접대비"],"title":"Time Complexity 시간복잡도","uri":"https://colinder.github.io/time_complexity/"},{"categories":["react-native"],"content":"​ React Native 시작하기 (with Typescript) myApp은 본인이 원하는 프로젝트 이름으로 바꾸면 됩니다. 가장 최근 버전으로 프로젝트 세팅 npx react-native@latest init myApp --template react-native-template-typescript ​ ​ ​ ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:0:0","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["react-native"],"content":"실행명령어 Metro 실행 명령어 npx react-native start ​ ​ ​ ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:1:0","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["react-native"],"content":"절대 경로 세팅 공식문서 여기 참고하시면 좋습니다. v0.72 기준 저는 아래와 같은 폴더 구조로 세팅했고 이 중 src를 root로 설정하고 싶었습니다. 또 @로 root 주소를 불러오고 싶습니다. ├─.bundle ├─android ├─ios ├─node_modules ├─src 👈 │ ├─assets │ │ ├─fonts │ │ └─styles │ ├─components │ ├─hooks │ ├─layout │ ├─screen │ │ └─intro │ │ ├─intro-calender │ │ └─intro-period │ └─utils ├─__tests__ ├─package.json ├─tsconfig.json ├─babel.config ├ ... ├ ... ​ ​ babel-plugin-module-resolver 설치하기 npm i babel-plugin-module-resolver ​ ​ babel.config.js에서 alias(별칭) 설정하기 프로젝트를 생성하면 기본적으로 아래와 같이 설정되어 있습니다. module.exports = { presets: ['module:metro-react-native-babel-preset'], }; ​ 이렇게 바꿔 줍니다. module.exports = { presets: ['module:metro-react-native-babel-preset'], plugins: [ [ 'module-resolver', { root: ['./src'], extensions: [ '.ios.ts', '.android.ts', '.ts', '.ios.tsx', '.android.tsx', '.tsx', '.jsx', '.js', '.json', ], alias: { '@': './src', }, }, ], ], }; ​ tsconfig.json설정하기 (Typescript 사용시) defualt { \"extends\": \"@tsconfig/react-native/tsconfig.json\", } ​ 아래와 같이 변경 { \"extends\": \"@tsconfig/react-native/tsconfig.json\", \"compilerOptions\": { \"baseUrl\": \"./src\", \"paths\": { \"@/*\": [\"./*\"], } } } ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:2:0","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["react-native"],"content":"끝 ​ ​ ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:2:1","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["react-native"],"content":"Font 적용하기 Pretendard 폰트를 적용하고 싶었다. react-native는 css로 글로벌하게 지정하려면 라이브러리를 사용해야 했는데, 그게 싫어서 \u003ccustomText\u003e를 만들어 사용하기로 생각했다. ​ 알아둘 것 ios와 android 세팅 방법이 다르다. 난 android 기준으로 진행 ​ 원하는 폰트 다운로드 (otf나 ttf나 상관 없다.) 적용할 폰트를 프로젝트 안에 넣는다. 여기서 android와 ios 각각 세팅하지않고 한번에 세팅되게 한다. root/src/assets/fonts 폴더를 만들고 이 안에 otf 혹은 ttf 파일을 다 넣는다. 여기서 ios 는 font name과 PostScript name이 다르면 정상적으로 동작되지 않는다하니, 이는 찾아보길 바란다. root 주소에 react-native.config.js를 생성하고 아래와 같이 수정한다. module.exports = { project: { ios: {}, android: {}, }, assets: ['./src/assets/fonts'], //👈 }; 👉 내가 폴더 구조를 root/src/assets/fonts 로 했기 때문에 이 구조를 등록한 것인다. 변경하고 싶다면, 마음대로 변경해도 된다. ​ 명령어를 입력해 ios, android 폴더에 폰트를 반영시킨다! npx react-native-asset 잘 되었는지 확인! android android/app/src/main/assets/fonts 가 생기며 이안에 폰트파일들이 잘 들어있는지 확인! ios ios/{projectName}/Info.plist 가 수정되었으며 \u003ckey\u003eUIAppFonts\u003c/key\u003e 아래에 폰트이름리스트가 잘 있는지 확인! ​ 이제 적용해보자 //App.tsx import React from 'react'; import { StyleSheet, View, Text, } from 'react-native'; function App(): JSX.Element { return ( \u003cView\u003e \u003cText style={styles.highlight}\u003ewhen i wasunger.설\u003c/Text\u003e \u003c/View\u003e ); } const styles = StyleSheet.create({ highlight: { fontFamily: 'Pretendard-Bold', }, }); export default App; ​ ​ 제일 중요합니다. 에뮬레이터를 완전히 껐다가 다시 켜보세요. 전 이걸 안했다가 적용이 안되서 구글 정독했고, 4시간을 버렸습니다….. vscode와 android 에뮬레이터를 전부 끄고 다시 vscode를 실행하고 npm run android를 입력해 실행하였습니다. 그러니 정상적으로 폰트가 적용된 것을 확인했습니다. ​ ​ ​ ​ ​ ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:3:0","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["react-native"],"content":"Navigation // 스텍에 쌓고 이동하기 ( 뒤로가기시 페이지로 돌아옴 ) navigation.navigate('스크린 이름 ') // 이전페이지로 돌아가기 ( 위의 navigate 를 이용하여 이동한 경우 가능 payLoad 가 2개 이상인 경우에 가능 하다 ) navigation.pop(); // 스텍의 제일 윗 페이지로 이동 navigation.popToTop() ​ // 새롭게 컴포넌트를 스텍이 쌓는다. ( 이전에 스텍에 쌓여있으면 그걸 불러온다 ) navigation.push(); // 스텍쌓지 않고 이동하기 ( 뒤로가기시 이전페이지로 돌아갈 수 없음 ) navigation.replace('스크린이름') // 중첩된 네비게이터에서 이동 navigation.navigate('A_Screen', { screen: 'A_1Screen' }) // 데이터 전달 navigation.navigate('Inquiry_R',{ 키값: 데이터 }) // 뒤로가기 import { CommonActions } from \"@react-navigation/native\"; navigation.dispatch(CommonActions.goBack()); //or navigation.goBack() ​ ​ ​ ​ ","date":"2023-07-20","objectID":"https://colinder.github.io/things/:4:0","tags":["react-native","web"],"title":"react-native Things","uri":"https://colinder.github.io/things/"},{"categories":["Apache","django","deploy"],"content":"​ How To Deploy Django on Windows server Using Apache Window에 backend(django)를 배포할 일이 생겨 방법을 정리하였다. (iis를 써보려했으나 실패했다.) ​ ✨단계가 꽤 된다. ","date":"2023-07-19","objectID":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/:0:0","tags":["Apache","django","deploy"],"title":"How To Deploy Django on Windows server Using Apache","uri":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/"},{"categories":["Apache","django","deploy"],"content":"요약 apache와 C++ 개발환경 세팅 django \u0026 mod-wsgi 설치 및 연동 Apache 서버 구동 ​ 주의! 기본적으로 python은 설치되어있다고 가정 ​ ​ ","date":"2023-07-19","objectID":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/:0:1","tags":["Apache","django","deploy"],"title":"How To Deploy Django on Windows server Using Apache","uri":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/"},{"categories":["Apache","django","deploy"],"content":"step 00. 다운 받고 환경을 만들어 보자 apache https://www.apachelounge.com/download/ 작성일 기준 가장 최신버전으로 다운받는다. ​ 다운된 파일의 압축을 풀면 3개의 파일이 보인다. 이중 Apache24 폴더를 통째로 잘라내고 C:\\ 에 붙여넣었다. 여기를 메인으로 사용할 것이다. ​ ​ Apache 설치 파일을 옮겨왔으니 설치하자 관리자 모드로 CMD를 켠다. ​ C:\\Apache24\\bin로 이동하자. cd C:\\Apache24\\bin ​ 이제 Apache 설치하자 httpd.exe -k install 뭔가 오류같은 내용들이 나오는데 출력된 내용 위에 이것만 뜨면 일단 동작하는데 문제는 없는 것 같다. ​ 구동도 해보자 httpd.exe -k start 아파치 서버 실행 명령어입니다. (중요) ​ 이제 설치가 잘 되었는지, 잘 구동되는지 확인할 단계 인터넷 주소창에 localhost라고 입력해보면 일하고 있다. (집, 공공장소인지 물어보는 경고창이 떠서 전부 체크하고 허용버튼 눌렀다.) ​ 여기까지 확인했으면, 일단 서비스를 중지해두자. ​ Apache24를 찾아서 중지해둔다. ​ ​ Dev C++ https://visualstudio.microsoft.com/visual-cpp-build-tools/ 다운로드 후 실행되면, ​ C++ 이 써있는거 클릭 후 설치해준다. (빨간 박스만 클릭하고 설치하였다.) ​ ​ ​ ","date":"2023-07-19","objectID":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/:0:2","tags":["Apache","django","deploy"],"title":"How To Deploy Django on Windows server Using Apache","uri":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/"},{"categories":["Apache","django","deploy"],"content":"step 01. django \u0026 mod-wsgi 설치 및 연동 잠깐. mod-wsgi는 Apache에서 Python 기반 웹 응용 프로그램을 호스팅하기 위한 WSGI 호환 인터페이스를 제공하는 Graham Dumpleton의 Apache HTTP 서버 모듈. ​ 터미널 창을 켜고 django 설치 pip install django 그리고 장고 프로젝트를 C:\\Apache24\\htdocs에 생성한다. (난 psgfront라는 이름으로 만들었다.) # django 프로젝트 생성 명령어 django-admin startproject psgfront ✨ 혹시 정적파일들을 관리해야 한다면, 프로젝트 폴더로 들어가(C:\\Apache24\\htdocs\\psgfront) static 이라는 폴더를 생성 ​ ​ mod-wsgi 설치 \u0026 설정값 확인 pip install mod-wsgi 설치 다 됬으면, mod_wsgi-express module-config # 라고 입력 후 엔터 이후 나오는 설정값(LoadFile, LoadModule, WSGIPythonHome 총 3개)은 등록해야 하는 값들이다. ​ C:\\Apache24\\conf 로 이동해 httpd.conf 파일을 편집한다. 파일을 열고 맨아래로 가 아래 코드를 붙여넣는다. # Django Project LoadFile \"c:/python37/python37.dll\" LoadModule wsgi_module \"c:/python37/lib/site-packages/mod_wsgi/server/mod_wsgi.cp37-win_amd64.pyd\" WSGIPythonHome \"c:/python37\" WSGIScriptAlias / \"C:/Users/navar/Desktop/webproject/webproject/wsgi.py\" WSGIPythonPath \"C:/Users/navar/Desktop/webproject/\" \u003cDirectory \"C:/Users/navar/Desktop/webproject/webproject/\"\u003e \u003cFiles wsgi.py\u003e Require all granted \u003c/Files\u003e \u003c/Directory\u003e Alias /static \"C:/Users/navar/Desktop/webproject/static/\" \u003cDirectory \"C:/Users/navar/Desktop/webproject/static/\"\u003e Require all granted \u003c/Directory\u003e ​ 여기서 아까 mod_wsgi-express module-config명령어로 확인한 설정값(LoadFile, LoadModule, WSGIPythonHome 총 3개)을 각각 변경한다. 나머지 값 확인 WSGIScriptAlias 생성한 django 프로젝트에 wsgi.py를 등록 저의 경우 \"C:/Apache24/htdocs/psgfront/psgfront/wsgi.py\" ​ WSGIPythonPath 생성한 django 프로젝트의 주소를 등록 저의 경우 \"C:/Apache24/htdocs/psgfront/\" ​ Directory 생성한 django 프로젝트의 메인 app 주소를 등록 저의 경우 \"C:/Apache24/htdocs/psgfront/psgfront/\" ​ Alias /static \u0026 Directory django 프로젝트에 생성한 static 폴더 주소를 등록 저의 경우 \"C:/Apache24/htdocs/psgfront/static/\" ​ ​ 최종 결과 LoadFile \"C:/Users/kjong/AppData/Local/Programs/Python/Python310/python310.dll\" LoadModule wsgi_module \"C:/Users/kjong/AppData/Local/Programs/Python/Python310/lib/site-packages/mod_wsgi/server/mod_wsgi.cp310-win_amd64.pyd\" WSGIPythonHome \"C:/Users/kjong/AppData/Local/Programs/Python/Python310\" WSGIScriptAlias / \"C:/Apache24/htdocs/psgfront/psgfront/wsgi.py\" WSGIPythonPath \"C:/Apache24/htdocs/psgfront/\" \u003cDirectory \"C:/Apache24/htdocs/psgfront/psgfront/\"\u003e \u003cFiles wsgi.py\u003e Require all granted \u003c/Files\u003e \u003c/Directory\u003e Alias /static \"C:/Apache24/htdocs/psgfront/static/\" \u003cDirectory \"C:/Apache24/htdocs/psgfront/static/\"\u003e Require all granted \u003c/Directory\u003e ​ ​ ​ ","date":"2023-07-19","objectID":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/:0:3","tags":["Apache","django","deploy"],"title":"How To Deploy Django on Windows server Using Apache","uri":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/"},{"categories":["Apache","django","deploy"],"content":"step 02. 다시 서비스를 실행 아까 중지해두었던 서비스로 들어가 Apache2.4를 실행하면, 잘 배포된 모습을 볼 수 있다. ​ ​ ​ ​ 👀 마무리 배포는 잘 마무리 되었지만, 아직 설정할 것이 많이 있다. 차근히 찾아보고 진행했던 단계들도 다시 한 번 천천히 살펴보며 보강하는 것이 좋을 것 같다. 명령어 모음 URL : https://github.com/colinder/How_To_Deploy_Django_on_Windows_server_Using_Apache/blob/main/README.md ​ ​ ​ ​ ","date":"2023-07-19","objectID":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/:0:4","tags":["Apache","django","deploy"],"title":"How To Deploy Django on Windows server Using Apache","uri":"https://colinder.github.io/how-to-deploy-django-on-windows-server-using-apache/"},{"categories":["web","ip"],"content":"​ 외부 \u0026 내부 IP 란? backend 개발을 하다보면, IP에 대하여 알아야하는 순간이 온다. 그래서 알아보자. ​ ​ ","date":"2023-07-18","objectID":"https://colinder.github.io/what_is_ip/:0:0","tags":["web","ip"],"title":"외부 \u0026 내부 IP","uri":"https://colinder.github.io/what_is_ip/"},{"categories":["web","ip"],"content":"IP란? 인터넷 프로토콜(Internet Protocol)의 약자로, 인터넷이 통하는 네트워크에서 어떤 정보를 수신하고 송신하는 통신에 대한 규약을 의미 ​ ​ ","date":"2023-07-18","objectID":"https://colinder.github.io/what_is_ip/:1:0","tags":["web","ip"],"title":"외부 \u0026 내부 IP","uri":"https://colinder.github.io/what_is_ip/"},{"categories":["web","ip"],"content":"IP면 IP지? 내부, 외부는 무엇인가? 우리 집을 생각해보자. 우리는 통신사의 어떤 기기를 대여받아 인터넷 와이파이를 사용하고 있다. 여기가 포인트다. 어떤 기기로 우리 집안에 와이파이를 뿌려주고 있고, 우리 가족은 이 기기의 와이파이로 인터넷에 접속한다! 이제 우리는 어떤 기기를 공유기라고 명명하겠다. ​ 즉 인터넷과 공유기 그리고 공유기에 할당받는 기기 3가지의 흐름을 알면 된다. 외부IP 인터넷과 공유기의 통신에 필요한 주소(프로토콜) 내부IP 공유기를 공유하는 기기들간에 부여받는 주소(프로토콜), 간단히 공유기망 안의 기기들에게 부여하는 주소(프로토콜) ​ 외부IP는 공유기당 1개의 주소를 할당 받고, 내부IP는 공유기를 공유하는 기기의 수만큼 생성되며 할당된다. ​ ​ ","date":"2023-07-18","objectID":"https://colinder.github.io/what_is_ip/:2:0","tags":["web","ip"],"title":"외부 \u0026 내부 IP","uri":"https://colinder.github.io/what_is_ip/"},{"categories":["web","ip"],"content":"우리가 쉽게 오해하는 것 중 하나 개발시 backend 개발자 PC의 DB를 연동해 통신하는 것은, 우리 PC ▶️ backend 개발자의 PC로 통신하는 것이 아니라, 우리 PC ▶️ 공유기 ▶️ backend개발자의 PC에 접근하는 것이다. ​ ​ ​ ","date":"2023-07-18","objectID":"https://colinder.github.io/what_is_ip/:2:1","tags":["web","ip"],"title":"외부 \u0026 내부 IP","uri":"https://colinder.github.io/what_is_ip/"},{"categories":["web","ip"],"content":"외부 \u0026 내부 IP 확인 방법은? 외부IP 가장 포괄적인 방법은 네이버에 접속해 ‘내 ip 주소 확인’이라고 검색하면 보인다. 공유기에 접속해 확인도 가능하나 그건 기기에 따른 가이드가 달라 각자 알아보자 ​ 내부IP 윈도우+R ▶️ cmd 입력 후 엔터 ▶️ ipconfig 입력 후 엔터 IPv4 주소 . . . . . . . . . : 값이 내부IP주소입니다. ​ ​ ​ ​ ","date":"2023-07-18","objectID":"https://colinder.github.io/what_is_ip/:3:0","tags":["web","ip"],"title":"외부 \u0026 내부 IP","uri":"https://colinder.github.io/what_is_ip/"},{"categories":["React"],"content":"​ React_Style 관리 전 css보다 scss가 더 좋습니다. Sassy CSS - 문법적으로 짱 멋진(Sassy) CSS이기 때문입니다. ​ ​ ","date":"2023-05-04","objectID":"https://colinder.github.io/scss_setting/:0:0","tags":["React"],"title":"React Scss_setting","uri":"https://colinder.github.io/scss_setting/"},{"categories":["React"],"content":"react에 scss 적용하기 간단히 라이브러리 하나만 설치해주고 파일명만 바꿔주면 됩니다. *CRA 공식 문서에 나와있는 방법을 따릅니다. ​ ​ package.json이 있는 위치에서 npm install sass ​ .css로 된 파일명을 .scss로 바꾸면 끝. ​ ​ ​ ​ ​ 👀 많은 레퍼런스가… npm install node-sass 해당 명령어로 sass를 적용하는데, 동료가 깃헙에서 npm i를 하는데 계속 오류가 났고 저도 간헐적으로 에러가 발생해 설명한 방식으로 변경하였습니다. ​ ​ ​ ​ ​ ​ ​ ","date":"2023-05-04","objectID":"https://colinder.github.io/scss_setting/:1:0","tags":["React"],"title":"React Scss_setting","uri":"https://colinder.github.io/scss_setting/"},{"categories":["React"],"content":"​ React_Style 관리 Vue에는 .vue 파일마다 \u003cstyle\u003e가 있고 여기에 \u003cstyle scoped\u003e를 주면 해당 파일에만 적용되는 style을 구성할 수 있는데, react는 어떻게 하는지 알아봅니다. ​ ​ ","date":"2023-05-03","objectID":"https://colinder.github.io/scoped_css/:0:0","tags":["React"],"title":"React Scoped_css","uri":"https://colinder.github.io/scoped_css/"},{"categories":["React"],"content":"scoped css 설정 지역적으로 사용하고 싶은 css 설정 방법 ​ 폴더 구조를 보자면. (구조는 마음대로 구성하여도 됩니다. 아래는 제 마음대로 구성한 것입니다.) src ├── assets │ ├── Styles │ ├── common.css │ ... ├── types │ ├── global.d.ts │ ... └── pages │ ├── test.tsx │ ├── test.module.css └── tsconfig.json ​ ​ ","date":"2023-05-03","objectID":"https://colinder.github.io/scoped_css/:1:0","tags":["React"],"title":"React Scoped_css","uri":"https://colinder.github.io/scoped_css/"},{"categories":["React"],"content":"✨ CRA로 프로젝트를 생성한 것을 기준으로 [name].module.css파일을 생성하는 것으로 지역적인 css를 설정할 수 있습니다. types \u003e global.d.ts파일을 생성하고 이곳에 [name].module.css를 선언해줍니다. (react typescript에게 알려주는 느낌.) CRA(Create-React-App) 공식문서를 따르면 CRA로 프로젝트를 생성했을 때, 별도의 설정없어 [name].module.css가 적용된다고 하는데 저는 붉은 경고창을 보았습니다. 그래서 등록해줬습니다. 참고 declare module \"*.module.css\" { const classes: { [className: string]: string }; export default classes; } //or declare module \"*.module.css\" ​ types를 선언해줬기 때문에 이를 default로 참고하라고 tsconfig.json에 등록해줍니다. { \"compilerOptions\": { \"typeRoots\": [\"./node_modules/@types\", \"types\"], // 👈👈👈 } ​ 우선 pages \u003e test.tsx에 기본 구조를 만들고 function test() { return ( \u003cdiv \u003e \u003ch1\u003etest 메인 페이지\u003c/h1\u003e \u003cdiv\u003e여기를 바꿔 봅시다.\u003c/div\u003e \u003c/div\u003e ); } export default test; ​ pages \u003e test.module.css에 test.tsx에만 적용할(지역적으로) css를 구성합니다. 간단하게 배경색을 주고 .Box { background-color: aqua; } ​ pages \u003e test.tsx에 반영하면 됩니다. import styles from \"./test.module.css\"; // 👈👈👈 function test() { return ( \u003cdiv \u003e \u003ch1\u003etest 메인 페이지\u003c/h1\u003e \u003cdiv className={styles.Box}\u003e여기를 바꿔 봅시다.\u003c/div\u003e // 👈👈👈 \u003c/div\u003e ); } export default test; ​ ​ ​ 👀 참고사항 global로 .box 클래스를 설정하고 .module.css에도 .box 클래스를 설정하는 경우 .module.css가 적용됩니다. 프로젝트가 커지는 경우 클래스명이 충돌될 수도 있는데, 기본적으로 .module.css이러한 충돌을 막기위해 CRA에서 구성된 것입니다. 저는 CRA 설명대로 했는데도 경고가 떠서, 1, 2번의 과정이 추가되었습니다. 보다 정확한 방법은 공식문서를 참고하세요! ​ ​ ​ ​ ","date":"2023-05-03","objectID":"https://colinder.github.io/scoped_css/:1:1","tags":["React"],"title":"React Scoped_css","uri":"https://colinder.github.io/scoped_css/"},{"categories":["React"],"content":"​ React Style_관리 전역으로 사용할 css 설정은 어떻게 하는지 알아봅니다. *기본적으로 typescript가 적용되어 있습니다. ​ ​ ","date":"2023-05-02","objectID":"https://colinder.github.io/global_css_setting/:0:0","tags":["React"],"title":"React global_Style_관리","uri":"https://colinder.github.io/global_css_setting/"},{"categories":["React"],"content":"Global css 설정 전역으로 사용하고 싶은 css 설정 방법 ​ 폴더 구조를 보자면. (구조는 마음대로 구성하여도 됩니다. 아래는 제 마음대로 구성한 것입니다.) src ├── assets │ ├── Styles │ ├── common.css │ ... └── index.tsx ​ global css 만들기 저는 공통으로 사용할 css 요소를 assets \u003e Styles \u003e common.css에 구성하였습니다. 예를 들어 /* common.css */ .red { background-color: red; } 배경색을 붉게 하는 red라는 클래스를 만들었습니다. ​ ​ 최상단 컴포넌트에 반영하기 저는 index.tsx를 최상위 컴포넌트로 사용하기 때문에 여기에 등록(import)해줍니다. /* index.tsx */ import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; import './assets/Styles/common.css' /* 👈👈👈 */ const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement ); root.render( \u003cReact.StrictMode\u003e \u003cApp /\u003e \u003c/React.StrictMode\u003e ); ​ ​ ​ 이렇게 등록해주면 어디서든 red라는 클래스를 사용할 수 있습니다. ​ ​ ​ ","date":"2023-05-02","objectID":"https://colinder.github.io/global_css_setting/:1:0","tags":["React"],"title":"React global_Style_관리","uri":"https://colinder.github.io/global_css_setting/"},{"categories":["Web"],"content":"​ npm Vs npx 예전부터 궁금했지만 굳이 알아볼 필요까지는 없었다가, 여드름이 터지듯 갑자기 궁금해서져 알아봤습니다. ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/npm_npx/:0:0","tags":["Web","npm","npx"],"title":"npm? npx?","uri":"https://colinder.github.io/npm_npx/"},{"categories":["Web"],"content":"가장 큰 차이는 설치를 할 것인가 아닌가 컴퓨터에 패키지 전역으로 설치하여 실행: npm 컴퓨터에 패키지 설치 없이 이번만 실행: npx npm는 컴퓨터 전역(global)에 패키지(npm 모듈 시스템)를 설치한다는 의미입니다. 만약 npm -g와 같이 뒤에 -g가 있다면, 전역으로 설치한다는 옵션입니다. -g 옵션이 없으면 NPM 패키지는 node_modules라는 이름의 폴더 안에 저장됩니다. node_modules 폴더는 npm install을 실행한 위치와 같은 계층에 있는 폴더입니다. ​ npm 패키지를 설치하지 않고 실행만 하려면 터미널에 npx를 입력하면 됩니다. npx는 노드 패키지 실행(Node Package Execute, NPX)의 약자로 NPM 패키지 실행자(NPM Package Runner)라고도 불립니다. npx가 설치되어 있는지를 확인하시려면 다음 명령어를 터미널에 입력하시면 됩니다. npx -v ​ 컴퓨터에 노드 패키지를 저장하고 싶은 분들은 아래 1번 방법을, 패키지를 저장하지 않고 실행하고 싶은 분들은 2번 방법을 사용하시면 됩니다. ​ ​ 컴퓨터에 패키지 전역으로 설치: npm npm create-react-app my-project ... ​ 컴퓨터에 패키지 설치 없이 실행: npx npx create-react-app my-project ... ​ ​ ​ 👀 저는 react를 배우다가 npm과 npx의 차이가 문득 궁금해져서 알아본 것인데, react를 시작하는 여러 방법 중 하나인 CRA(create-react-app)는 버전 변경이 자주 발생하는 React의 Boiler Plate입니다. 보일러 틀에 여러 개의 보일러를 찍어내듯, 초기 환경을 자동으로 셋업해주는 도구라고 보면 된다. (Vue CLI 같은 개념이다.) 버전 변경이 잦다는 것은 한 버전을 글로벌하게 설치해서 사용할 경우 내가 사용하는 버전이 점점 뒤로 밀리는 후속버전이 된다는 의미. 즉 항상 최신 버전으로 프로젝트를 생성하고 싶다면, npx가 더 맞는 방법이 되는 것이다. 이렇게 사용하려는 기술의 변화와 개인의 취향을 고려하여 사용하면 더 좋을 것 같습니다. ​ ​ ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/npm_npx/:1:0","tags":["Web","npm","npx"],"title":"npm? npx?","uri":"https://colinder.github.io/npm_npx/"},{"categories":["React"],"content":"​ React 시작하기 vue2 서비스가 23년 12월 31일에 종료된다… vue3는 개인적으로 실패한 프로젝트라 생각해 vue2를 고집하고 있었는데…. vue3로 갈 것인가. 그냥 react로 갈 것인가 고민하다. 일단 알아보자는 마음으로 정리한 내용이다. ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/init_setting/:0:0","tags":["React"],"title":"React Init","uri":"https://colinder.github.io/init_setting/"},{"categories":["React"],"content":"react 시작하기 앞서 준비할 것 node.js 에디터(ex. vscode) ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/init_setting/:1:0","tags":["React"],"title":"React Init","uri":"https://colinder.github.io/init_setting/"},{"categories":["React"],"content":"react 시작하기 준비가 끝났으니, react 프로젝트를 생성해보자 ​ 프로젝트 초기 세팅 명령어 npx create-react-app hello-world hello-world 라는 이름의 프로젝트를 생성 단!. 저는 별도의 package를 설치하지 않아서 package를 설치하겠나고 물어봤는데 당연히 Y 입니다. ​ 설치 완료 확인 내용을 보니 react라는 것과 react-dom 그리고 react-script가 설치된 것을 볼 수 있습니다. 모두 중요한 요소입니다. ​ 실행하기 cd hello-world npm start 정상적으로 설치 및 실행이 된 것을 확인하였습니다. ​ ​ ​ ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/init_setting/:2:0","tags":["React"],"title":"React Init","uri":"https://colinder.github.io/init_setting/"},{"categories":["React"],"content":"Typescript 적용한 프로젝트 생성 방법 npx create-react-app hello-world --template typescript hello-world 라는 이름의 프로젝트를 생성하는데 typescript로 생성 ​ ​ ​ ​ ​ ","date":"2023-04-20","objectID":"https://colinder.github.io/init_setting/:3:0","tags":["React"],"title":"React Init","uri":"https://colinder.github.io/init_setting/"},{"categories":["docker"],"content":"​ 내가 자주 사용하는 docker 명령어 정리 ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:0","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"1. 현재 docker container 상태 확인하기 docker ps -a ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:1","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"2. 현재 docker image 조회 docker hub에서 받은 image와 내가 생성한 image를 보는 명령어 docker images # 또는 docker image ls / 둘은 같은 결과를 반환하는 명령어 ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:2","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"3. image 생성 hub에서 pull 받기 docker pull \u003c다운받을 image 이름\u003e 다운받을 image 이름 \u0026 종류는 Docker Hub Web(https://hub.docker.com/)에서 검색 후 존재를 확인하고 다운 받는다. dockerfile 생성해서 구축하기 dockerfile을 만들었다고 가정한 후 docker build -t \u003c내가 정하는image 이름\u003e . # ex) docker build -t mydocker/nginx . ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:3","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"4. image 삭제 remove image docker rmi \u003cimage ID\u003e # ex) docker rmi 3e1b601d0fa6 ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:4","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"4-1. container 삭제하기 전에 image를 삭제하는 경우 강제로 삭제해야 하기 때문에 -f 옵션을 준다. 해당 경우 container도 삭제된다. docker rmi -f \u003cimage ID\u003e # ex) docker rmi -f 3e1b601d0fa6 none 으로 등록된 image 삭제 방법 docker rmi $(docker images -f \"dangling=true\" -q) # 또는 docker rmi -f $(docker images -f \"dangling=true\" -q) ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:5","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"5. container 접속 docker exec -it \u003c컨테이너이름\u003e /bin/bash ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:6","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"6. container 실행 실행 \u003e image를 만들고 해당 image로 컨테이너를 실행한다.(최초) docker run \u003cimage ID\u003e 재실행 \u003e 멈춰 있는 container를 다시 실행한다. docker start \u003ccontainder NAME or containder ID\u003e ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:7","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"6-1. container 종료 docker stop \u003ccontainder NAME or containder ID\u003e ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:8","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"7. container 삭제 none으로 생긴 container 삭제 방법 docker rm $(docker ps --filter status=exited -q) 일반 삭제 방법 docker rm \u003ccontainer ID\u003e \u003c...\u003e \u003c...\u003e # ex) docker rm 3e1b601d0fa6 / 여러개인 경우 띄어쓰기로 구분 후 계속 입력 ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:9","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["docker"],"content":"8. container 이름 변경 실행중인 container의 이름을 변경하더라도 상태를 유지한다. 즉, 구동상태에 영향을 주지 않는다. docker rename \u003c기존이름\u003e \u003c변경하고싶은이름\u003e # ex) docker rename originalName changeName ​ ​ ​ ​ ​ ​ ​ ","date":"2023-03-27","objectID":"https://colinder.github.io/command/:0:10","tags":["docker","command"],"title":"docker Command","uri":"https://colinder.github.io/command/"},{"categories":["security","AES","web"],"content":"​ ​ AES_django \u003e vue pycryptodomex(django)에서 CryptoJS(vue)로 암호화 복호화 하는 과정을 정리 ​ ​ ​ ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:0:0","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"✨기본 사항 django에서 6자리 숫자의 OTP를 생성해 암호화 하여 vue로 전달하는 상황을 가정. 각기 다른 시스템의 라이브러리를 사용. AES의 CBC 모드를 기본으로 가정. CBC모드를 사용하기 위해서 필수 인자 3가지 secret_key: 암호화 \u0026 복호화를 위한 메인 키 (대칭키) iv: 암호화 \u0026 복호화를 위한 서브 키 data: 암호화를 하고 싶은 데이터 💡중요 pycryptodomex 암호화 해당 라이브러리에서는 bytes type의 데이터만 인자로 받을 수 있다. 하여 encode(), decode() 함수를 사용해 데이터 타입을 변경해 주었다. secret_key와 iv, data는 정해진 bytes 길이(long)를 지켜야 한다. ex) 16bytes, 32bytes 등 pycryptodomex는 자동으로 data를 padding해주지 않는다. CryptoJS 복호화 secret_key와 iv는 암호화에 사용된 값과 동일해야 한다. ​ ​ ​ ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:1:0","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"Django 암호화(encryption) info\rdjango에서 복호화 코드만 정리. api 통신을 위한 내용과 라이브러리들은 정리하지 않는다.\rimport base64 from Cryptodome.Cipher import AES from Cryptodome.Util.Padding import pad def encryption(value): secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef'.encode('utf-8') iv = '1234567890123456'.encode('utf-8') # pad를 위해서 bytes로 변환 필요 # 최소 데이터 길이 == 16bytes 로 만들어 주기 위해 pad 진행 data = value.encode('utf-8') # Data must be padded to 16 byte boundary in CBC mode padded_data = pad(data, 16) cipher = AES.new(secret_key, AES.MODE_CBC, iv) encrypted_data = base64.b64encode(cipher.encrypt(padded_data)) return encrypted_data # bytes type @permission_classes([AllowAny]) class Otp(APIView): def get(self, request): OTP = \"\" for _ in range(6): temp = random.randrange(0, 10) OTP += str(temp) response = { \"detail\": \"요청하신 사항이 처리 되었습니다.\", \"OTP\": encryption(OTP) # \u003cclass 'bytes'\u003e } return Response(response) ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:2:0","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"💡암호화 해설 @permission_classes([AllowAny]) class Otp(APIView): def get(self, request): OTP = \"\" for _ in range(6): temp = random.randrange(0, 10) OTP += str(temp) response = { \"detail\": \"요청하신 사항이 처리 되었습니다.\", \"OTP\": encryption(OTP) # \u003cclass 'bytes'\u003e } get요청을 받으면, 6자리 숫자 string type의 OTP를 생성하고 이를 암호화(encryption()) 한다. secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef'.encode('utf-8') iv = '1234567890123456'.encode('utf-8') 키에 관련된 변수 세팅 data = value.encode('utf-8') padded_data = pad(data, 16) pycryptodomex 공식문서를 보면 ‘Data must be padded to 16 byte boundary in CBC mode’ 이다. 하여 padding을 주어야 하는데 pycryptodomex의 pad() 함수를 사용한다. pad() 함수는 bytes type의 데이터만 다룰 수 있어서 .encode(‘utf-8’)로 bytes type으로 변경하고 이를 pad() 함수에 넣어 처리한다. cipher = AES.new(secret_key, AES.MODE_CBC, iv) 암호화 세팅을 해주고 encrypted_data = base64.b64encode(cipher.encrypt(padded_data)) bytes type의 변수 ‘padded_data’를 암호화 cipher.encrypt(padded_data)는 b'8\\x08\\xa5\\x90\\xed;Q\\x18\\x86\\xcb\\xbf\\nY\\xd1\\x9e\\x87'와 같은 형태 base64.b64encode() 함수에 넣어 b'fGJc4x3IqRkIApLmz/atxw=='와 같이 변환한다. ​ ​ ​ ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:2:1","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"Vue 복호화(decryption) var encrypted_data = res.data.OTP const decryptde_data = CryptoJS.AES.decrypt(encrypted_data, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting(없어도 됨) mode: CryptoJS.mode.CBC, }); console.log('OTP', decryptde_data.toString(CryptoJS.enc.Utf8)) ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:3:0","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"💡암호화 해설 var encrypted_data = res.data.OTP 응답온 데이터를 변수로 저장 var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; var iv = '1234567890123456'; 암호키 설정값 가져오고 const decryptde_data = CryptoJS.AES.decrypt(encrypted_data, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting(없어도 됨) mode: CryptoJS.mode.CBC, }); AES 세팅하고 암호화된 데이터(encrypted_data)를 넣어 복호화 한다. console.log('OTP', decryptde_data.toString(CryptoJS.enc.Utf8)) type을 변환해주고 console로 확인해본다. ​ ​ ​ ​ ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:3:1","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"마무리 이로써 pycryptodomex(django)에서 CryptoJS(vue)로 암호화 복호화 하는 과정 정리를 마무리. 두 라이브러리의 차이를 이해하고, 단계 단계마다 어떻게 데이터가 변하는지 확인하는 것이 좋을 것 같습니다. ​ ​ ​ ​ ​ ","date":"2023-02-28","objectID":"https://colinder.github.io/aes_django_vue/:4:0","tags":["security","AES","web"],"title":"AES django \u003e vue 적용","uri":"https://colinder.github.io/aes_django_vue/"},{"categories":["security","AES","web"],"content":"​ ​ AES_vue \u003e django CryptoJS(vue) 에서 pycryptodomex(django)로 암호화 복호화 하는 과정을 정리 ​ ​ ​ ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:0:0","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"✨기본 사항 각기 다른 시스템의 라이브러리를 사용. AES의 CBC 모드를 기본으로 가정. CBC모드를 사용하기 위해서 필수 인자 3가지 secret_key: 암호화 \u0026 복호화를 위한 메인 키 (대칭키) iv: 암호화 \u0026 복호화를 위한 서브 키 data: 암호화를 하고 싶은 데이터 vue에서 object를 통째로 암호화 하여 django로 전달하는 상황을 가정. 💡중요 CryptoJS secret_key와 iv는 정해진 bytes 길이(long)를 지켜야 한다. ex) 16bytes, 32bytes 등. 사용자가 길이를 맞추어 사용하기 어렵다면, padding을 사용해 맞춘다. data는 길이가 상관없다. CryptoJS는 자동으로 padding하여 bytes길이를 맞추어주기 때문에! 다만 암호화를 하려면 string type의 데이터를 넣어야 한다. pycryptodomex secret_key와 iv, data는 정해진 bytes 길이(long)를 지켜야 한다. ex) 16bytes, 32bytes 등 이는 이번 포스팅에서는 신경쓸 부분이 아니지만, 나중에 django에서 암호화하여 vue로 보낼때 중요한 사항이다. pycryptodomex는 자동으로 data를 padding해주지 않기 때문에! ​ ​ ​ ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:1:0","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"Vue 암호화(encryption) //// import import CryptoJS from \"crypto-js\"; //// encryption var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; var iv = '1234567890123456'; const data = { \"email\": \"user12312312@naber.com\", \"password\": \"1234567890q\" } var enc = JSON.stringify(data) const cipher = CryptoJS.AES.encrypt(enc, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting(없어도 됨) mode: CryptoJS.mode.CBC, } ) // out type: Object this.$axios.post(\"myServerAdress\", { send: cipher.toString() }) ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:2:0","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"💡암호화 해설 var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; var iv = '1234567890123456'; 원하는 값으로 변경해서 사용하면 되며, 단 bytes 길이는 맞추어 사용해야 한다. const data = { \"email\": \"user12312312@naber.com\", \"password\": \"1234567890q\" } Object를 통째로 암호화하여 사용할 것 var enc = JSON.stringify(data) 암호화를 하려면 string으로 변경해야 해서 변경 const cipher = CryptoJS.AES.encrypt(enc, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting(없어도 됨) mode: CryptoJS.mode.CBC, } ) // out type: Object 앞선 포스팅에서 참고 this.$axios.post(\"myServerAddress\", { send: cipher.toString() }) “myServerAddress\"로 post요청을 보내는데 ‘send’라는 이름으로 암호화한 값을 string type으로 변경하여 전달한다. ​ ​ ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:2:1","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"Django 복호화(decryption) info\rdjango에서 복호화 코드만 정리. api 통신을 위한 내용과 라이브러리들은 정리하지 않는다.\rimport base64 from Cryptodome.Cipher import AES def decryption(value): # value == string secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef'.encode('utf-8') iv = '1234567890123456'.encode('utf-8') dec = base64.b64decode(value) # TypeError(\"Object type %s cannot be passed to C code\" % type(data)) 방지 cipher = AES.new(secret_key, AES.MODE_CBC, iv) decrypted_data = cipher.decrypt(dec).decode('utf-8') # CryptoJS의 자동 padding을 지우고 # javascript의 Object를 그대로 받아오기 위해 decrypted_data = decrypted_data.split('}')[0] + \"}\" decrypted_data = eval(decrypted_data) return decrypted_data @permission_classes([AllowAny]) class vue_api(APIView): def post(self, request): data = request.data['send'] decrypted_data = decryption(data) print(decrypted_data) # {\"email\": \"user12312312@naber.com\", \"password\": \"1234567890q\"} ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:3:0","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"💡복호화 해설 info\rdjango에서 복호화 코드만 정리. api 통신을 위한 라이브러리들은 정리하지 않는다.\r@permission_classes([AllowAny]) class vue_api(APIView): def post(self, request): data = request.data['send'] decrypted_data = decryption(data) print(decrypted_data) API 요청을 접수하여 request.data['send']값을 가져오고 이를 decryption()함수를 통해 복호화 한다. secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef'.encode('utf-8') iv = '1234567890123456'.encode('utf-8') 암호화에 사용된 것과 동일한 secret_key와 iv값을 가져온다. dec = base64.b64decode(value) # TypeError(\"Object type %s cannot be passed to C code\" % type(data)) 방지 value(암호화한 데이터)를 base64로 디코딩해준다. 만약 안해주면 TypeError(“Object type %s cannot be passed to C code” % type(data)) 에러가 난다. 왜 그런건지는 아직 잘 모르겠다. cipher = AES.new(secret_key, AES.MODE_CBC, iv) decrypted_data = cipher.decrypt(dec).decode('utf-8') 복호화할 AES를 설정해주고(cipher) cipher의 decrypt()함수를 사용해 복호화 한다. \u003e output type은 bytes 복호화한 값은 encoding된 값(bytes type)이라서 decode(‘utf-8’)를 사용해 string type으로 변경해준다. ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:3:1","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"여기서 부터 중요! 여기까지 진행하고 복호화된 값(decrypted_data)을 출력해보면 {\"email\": \"user12312312@naber.com\", \"password\": \"1234567890q\"}══════와 같이 CryptoJS가 bytes길이를 맞추기 위해 padding된 공백값들이 ══════같은 특수문자로 채워져있다. # CryptoJS의 자동 padding을 지우고 javascript의 Object를 그대로 받아오기 위해 decrypted_data = decrypted_data.split('}')[0] + \"}\" decrypted_data = eval(decrypted_data) 하여 Object의 데이터를 그대로 사용하기 위해 “}“를 기준으로 split()하고 다시 “}“를 붙여 dictionary 형태의 string으로 만들었다. 그리고 이를 eval()함수를 사용해 dictionary type으로 만들었다. 아직 정확한 원인?을 찾지 못했습니다. CryptoJS와 pycryptodomex라는 라이브러리의 차이 때문에 발생한 원인으로 이해하고 넘어갔습니다. return decrypted_data 그리고 전처리가 다 끝난 값을 return 해 종료 ​ ​ ​ ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:3:2","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"마무리 이로써 CryptoJS(vue) 에서 pycryptodomex(django)로 암호화 복호화 하는 과정 정리를 마무리. 모든 과정을 정확히 이해하기 위해 공식문서를 다 참고하였지만, 아직 명확하지 않은 부분도 남아있습니다. 저는 다른 사람들이 작성한 코드도 많이 보았지만, 가장 정확한 사용방법은 공식문서와 github을 참고해 라이브러리의 코드를 직접 보며 이해하는 것입니다. 다른 분들 그리고 저를 포함해 남들이 작성한 코드에 현혹되지 마세요. 대충 코드가 돌기만하면 된다 하시는 분은 그냥 레퍼런스 많이 보면 이해가 될 것입니다. ​ ​ ","date":"2023-02-24","objectID":"https://colinder.github.io/aes_vue_django/:4:0","tags":["security","AES","web"],"title":"AES vue \u003e django 적용","uri":"https://colinder.github.io/aes_vue_django/"},{"categories":["security","AES","web"],"content":"​ ​ AES django 적용 django에 PyCryptodomex를 설치하여 적용 pip install pycryptodomex 주의 사항 PyCryptodome is a fork of PyCrypto For more information, see the homepage.를 클릭하면, pycryptodome의 문서로 이동하는데, 왜 그런건지 모르겠다. 아마 의존성?이 있어 그런건가 싶다. 문서에 예시를 보면 from Crypto.Cipher import AES 와 같이 import 하라는데, 이러면 안되고 from Cryptodome.Cipher import AES 이렇게 Crypto \u003e Cryptodome 으로 바꿔주어야 사용이 가능하다. pycryptodome은 오직 bytes로 인코딩 된 데이터만 처리할 수 있다. AES를 이용 암호화하려면, 암호화의 대상인 text가 16, 32, 64, 128, 256 바이트의 블록들(데이터)이어야 한다. 위와 같이 암호화 대상인 text를 16, 32, 64, 128, 256 바이트의 블록들로 만드는 것을 padding이라고 한다. 개인적으로 전체적인 데이터 처리를 위한 타입을 맞춰주는 것이 가장 어려웠다. Front에서 어떤 데이터를 전달 받은 상황을 가정하고 예시 제작 ​ ​ ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:0:0","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"암호화(encryption) def encryption(value): secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef' iv = '1234567890123456' SK = secret_key.encode('utf-8') IV = iv.encode('utf-8') data = value.encode('utf-8') # pad를 위해서 bytes로 변환 필요 paded_data = pad(data, 16) # 최소 데이터 길이 == 16bytes 로 만들어 주기 위해 pad 진행 cipher = AES.new(SK, AES.MODE_CBC, IV) encrypted_data = base64.b64encode(cipher.encrypt(paded_data)) return encrypted_data # type bytes ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:1:0","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"💡암호화 유의사항 data = value.encode('utf-8') paded_data = pad(data, 16) pad를 위해서 bytes로 변환 필요 data의 길이가 16보다 작으면, 최소 데이터 길이 == 16bytes 로 만들어 주기 위해 pad 진행 ​ ​ ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:1:1","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"복호화(decryption) def decryption(value): secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef' iv = '1234567890123456' SK = secret_key.encode('utf-8') IV = iv.encode('utf-8') dec = base64.b64decode(value) cipher = AES.new(SK, AES.MODE_CBC, IV) decrypted_data = cipher.decrypt(dec).decode('utf-8') return decrypted_data data = request.data # 암호화된 string result = encryption(data) ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:2:0","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"💡복호화 유의사항 secret_key = 'abcdefghijklmnopqrstuvwxyzabcdef' # AES256은 key 길이가 32자여야 함 front에서 전달받은 암호화 데이터를 복호화하는 것이니. 암호화때 사용된 secret_key와 동일한 secret_key 정보가 있어야 함. iv = '1234567890123456' iv도 마찬가지 SK = secret_key.encode('utf-8') IV = iv.encode('utf-8') pycryptodomex는 bytes type의 데이터만 다룰 수 있어 변환 테스트 결과 ‘utf-8’ 이든 ‘ascii’든 encode 하는 타입은 복호화에 영향이 없었다. (아무거나 선택 가능) 아마도 bytes 로만 변경되면 다룰 수 있기 때문에 가능한 것 같다. 또 utf-8이 ascii보다 더 포괄적인 사용 가능한 인코딩 방식 ​ ​ ​ ​ ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:2:1","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"👀알아낸 것 sent = '8ac9c453ae4f5056' a = sent.encode('utf-8') # b'8ac9c453ae4f5056' b = a.decode('utf-8') # 8ac9c453ae4f5056 .encode() .decode()는 간단히 string type \u003c\u003e bytes type로 변경해주는 함수 ​ sent = b'8ac9c453ae4f5056' a = base64.b64encode(sent) # b'OGFjOWM0NTNhZTRmNTA1Ng==' b = base64.b64decode(a) # b'8ac9c453ae4f5056' base64.b64encode(), base64.b64decode()는 간단히 bytes type의 데이터를 base64로 변경해주는 함수 ​ 인코딩 뜻: 정보의 형태나 형식을 변환하는 처리나 처리 방식 ​ ​ ​ ​ ​ ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:2:2","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"✨주의사항 보안 코드 전문가가 아니기 때문에, 구글링을 통하여 테스트해보고 실제 동작이 확인된 사항들만 정리하였습니다. 즉, 다른 방법도 있을 것이고 다른 분의 깔끔한 코드도 금방 찾아 볼 수 있으니, 많은 레퍼런스, 많은 테스트를 진행해보길 추천합니다. 전 type 맞추는 것이 제일 복잡했습니다. 또 저는 vue와 연동을 하면서 개발하여서, 앞에 vue 정리사항과 같이 보면 더 좋습니다. 참고 레퍼런스 https://inma.tistory.com/145 https://www.pycryptodome.org/src/examples ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ","date":"2023-02-21","objectID":"https://colinder.github.io/aes_django/:3:0","tags":["security","AES","web"],"title":"AES django 적용","uri":"https://colinder.github.io/aes_django/"},{"categories":["security","AES","web"],"content":"​ ​ AES Vue 적용 vue.js에 CryptoJS를 설치하여 진행 npm i crypto-js 주의 사항 AES에 사용되는 parameters는 모두 bytes 타입만 사용이 가능하다. 하여 대부분 utf-8로 encoding하여 사용 (이 부분은 아직 정확하게 이해하지 못했다.) ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/aes_vue/:0:0","tags":["security","AES","web"],"title":"AES vue 적용","uri":"https://colinder.github.io/aes_vue/"},{"categories":["security","AES","web"],"content":"암호화(encryption) var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; var iv = '1234567890123456'; var data = this.accounts.email.padEnd(32, \" \") const cipher = CryptoJS.AES.encrypt(data, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting(없어도 됨) mode: CryptoJS.mode.CBC, }); // out type: Object this.$axios.post(\"myServerAdress\", { cipher: cipher.toString() }) ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/aes_vue/:1:0","tags":["security","AES","web"],"title":"AES vue 적용","uri":"https://colinder.github.io/aes_vue/"},{"categories":["security","AES","web"],"content":"💡암호화 유의사항 var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; AES256은 secretKey 길이가 32자여야 함 var iv = '1234567890123456'; mode.CBC모드를 사용하려면 iv 길이는 16자여야 함 var data = this.accounts.email.padEnd(32, \" \") 전달할 데이터에 최소 32bytes padding을 주지 않으면, django에서 데이터를 받는데 user@naver.com╗╗ 와 같이 알 수 없는 특수문자가 포함되어서 왔다. this.$axios.post(\"myServerAdress\", { cipher: cipher.toString() }) params로 담기 위해선 string tpye 변환이 필요 toSting()안하면, Converting circular structure to JSON 에러 발생 선회하는 구조를 JSON으로 바꾸려고 해서 나는 에러라는데 뭔지 잘 모르겠음. .toString() 함수를 사용하지 않으면, 암호화된 Object 타입이 되는데, 대략 아래와 같은 모습이다. {$super: {…}, ciphertext: W…y.init, key: W…y.init, iv: W…y.init, init: *ƒ, …}* $super: {$super: {…}, init: ƒ, toString: ƒ} algorithm: {keySize: 8, _doReset: ƒ, encryptBlock: ƒ, decryptBlock: ƒ, _doCryptBlock: ƒ, …} blockSize: 4 ciphertext: WordArray.init {words: Array(12), sigBytes: 48} formatter: {stringify: ƒ, parse: ƒ} init: ƒ () iv: WordArray.init {words: Array(4), sigBytes: 16} key: WordArray.init {words: Array(8), sigBytes: 32} mode: {$super: {…}, Encryptor: {…}, Decryptor: {…}, init: ƒ} padding: {pad: ƒ, unpad: ƒ} [[Prototype]]: Object 여기에 .toString() 함수를 붙여주면. 0zs9xTyPtLkJDvwXCH1G4PZqxUwfuf/LVIq5Ovs3bR39B0sCxl87IxSaE1mtS4RE 와 같이 암호화가 된 것을 볼 수 있다. ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/aes_vue/:1:1","tags":["security","AES","web"],"title":"AES vue 적용","uri":"https://colinder.github.io/aes_vue/"},{"categories":["security","AES","web"],"content":"복호화(decryption) var secretKey = 'abcdefghijklmnopqrstuvwxyzabcdef'; var iv = '1234567890123456'; var encrypted_data = res.data.OTP // 복호화할 데이터 (tpye string) const decryptde_data = CryptoJS.AES.decrypt(encrypted_data, CryptoJS.enc.Utf8.parse(secretKey), { iv: CryptoJS.enc.Utf8.parse(iv), padding: CryptoJS.pad.Pkcs7, // default setting (없어도 됨) mode: CryptoJS.mode.CBC, }); console.log('복호화', CryptoJS.enc.Utf8.stringify(decryptde_data).toString()) ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/aes_vue/:2:0","tags":["security","AES","web"],"title":"AES vue 적용","uri":"https://colinder.github.io/aes_vue/"},{"categories":["security","AES","web"],"content":"💡복호화 유의사항 본 테스트는 django에서 진행하였는데 django에서 전달되는 데이터 형태는 string이다. 암호화에 사용된 동일한 secretKey, iv를 가져와서 사용해야 한다. (대칭키니까 당연하게도) 레퍼런스를 확인해보니 전달되는 데이터에 iv를 포함하여 전달하고 받는 형태도 있던데, 저는 그냥 secretKey, iv를 별도로 지정하여 사용하였습니다. var encrypted_data = res.data.OTP django에서 전달 받은 데이터를 변수로 저장. / 대략 wh5woZao84Sgh7NmhQJVvQ== 이런 모습 ​ ​ ​ ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/aes_vue/:2:1","tags":["security","AES","web"],"title":"AES vue 적용","uri":"https://colinder.github.io/aes_vue/"},{"categories":["security","AES","web"],"content":"​ ​ AES 보안 보안 진단을 받아보니, 생각보다 API 통신은 해킹이 쉽다. 하여 보안에 신경써야 하는 경우, 기술들이 다양하게 있는데, 그 중 AES\u003cAdvanced Encryption Standard\u003e를 간단히 알아보고 이후 적용하는 방법과 과정에 대하여 정리한다. AES는 미국 표준 기술 연구소에 의해서 연방 정보 처리 표준으로 지정된 암호화 방식이며 NSA에 의해 1급 비밀에 사용할 수 있도록 승인된 암호화 알고리즘 중 유일하게 공개된 알고리즘 - 출처 : 나무위키 ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/what_is_aes/:0:0","tags":["security","AES","web"],"title":"what is AES","uri":"https://colinder.github.io/what_is_aes/"},{"categories":["security","AES","web"],"content":"환경 설정 frontend = vue.js / backend = django로 API 연동하여 사용. 즉 vue.js에서 암호화한 값을 django에서 복호화해서 사용하고, django에서 암호화한 값을 vue.js에서 복호화해서 사용하는 환경을 가정. vue.js는 CryptoJS를 사용 django는 PyCryptodomex를 사용 ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/what_is_aes/:1:0","tags":["security","AES","web"],"title":"what is AES","uri":"https://colinder.github.io/what_is_aes/"},{"categories":["security","AES","web"],"content":"기본 지식 \u0026 설정 AES는 대칭키 암호화 방식이며, front와 back이 공유해야하는 키가 존재한다. secret_key : 비공개로 관리되어야 하며, 암호를 걸거나 풀 때 사용하는 특별한 KEY ​ 사용하려는 AES에 디폴트값인 MODE_CBC(Cipher Block Chaining) 방식를 사용하려고 한다. 블록 암호화 운영 모드 중 보안 성이 제일 높은 암호화 방법으로 가장 많이 사용된다. IV(Initial Vector)라는 값을 설정해주어야하는데, 이는 암호화를 랜덤화하기 위해 여러 모드에서 사용되는 비트 블록이다. 암호문이 블록의 배수가 되기 때문에 복호화 후 평문을 얻기 위해서 Padding을 해야만 한다. 해당 사항들을 다 이해하고 사용하면 좋겠지만, 우선 iv라는 설정값이 필요하다, padding을 해주어야 한다. 정도만 알고 진행해도 무방하다. ​ 즉 AES의 CBC 방식을 사용하기 위해서는 secret_key iv padding의 과정 이 세가지를 생각하며 진행하면 된다. ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/what_is_aes/:2:0","tags":["security","AES","web"],"title":"what is AES","uri":"https://colinder.github.io/what_is_aes/"},{"categories":["security","AES","web"],"content":"잠시 특이사항 정리 secret_key It must be 16 (AES-128), 24 (AES-192) or 32 (AES-256) bytes long. For MODE_SIV only, it doubles to 32, 48, or 64 bytes. ​ iv The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key. - 출처: 위키피디아 동일한 iv를 사용해도 암호화된 내용은 변경된다고 한다. 그러나 레퍼런스들을 찾아보니 secret_key는 고정된 값이지만, iv는 random하게 생성해서 사용하는 경우가 많은 것 같다. iv는 For MODE_CBC, MODE_CFB, and MODE_OFB it must be 16 bytes long. ​ 하여 secret_key(32bytes), iv(16bytes)는 고정된 값으로 생성 후 사용하려고 한다. ​ ​ ​ ​ ​ ","date":"2023-02-20","objectID":"https://colinder.github.io/what_is_aes/:2:1","tags":["security","AES","web"],"title":"what is AES","uri":"https://colinder.github.io/what_is_aes/"},{"categories":["AI","Overfitting"],"content":"​ 과적합(Overfitting) 잘 정리된 내용을 발견하였고 거기에 개인적인 경험을 추가하기 위해 정리하였습니다. (대부분 필사입니다.) 인공지능 모델링을 하다보면 항상 만나게 되는 과적합을 어떻게 해결해야하는지, 방법에 대하여 정리 인공지능에게 흔히 말하는 깊이있는 공부를 시키려면 모델의 layer을 늘리고, 노드(unit)을 늘리는 방법을 떠올린다. 그리고 그러다 보면 train data에 만 너무 적합하게, 처음 보는 test data를 집어넣었을 땐 형편없는 결과를 도출하는 모델이 된다. (이를 과적합이라 한다.) 일반적으로 과적합은 모델 학습과정에서 valid loss가 지속적으로 감소하다가 증가하는 지점부터 발생한다고 정의된다. 하지만 처음부터 valid loss가 증가하는 모델도 많이 보았다. ​ ​ ​ Solution 과적합을 해결하는 가장 기본적인 방법은 train data의 양을 늘리는 것이다. 다만 실무를 경험해보면 알겠디만, 데이터를 늘리고 싶다고 늘릴 수 있는게 아니다. 다양한 방법으로 기존의 데이트를 늘리는 방법을 적용해보기도 하지만, 과연 재구성한 데이터의 적합성과 유효성을 알긴 어렵다. ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:0","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"1. Dropout (드롭아웃) 중간 노드의 학습을 임의로 중지하는 것. 학습하는 layer의 노드 중 일부를 랜덤으로 꺼버려 역전파시 파라미터 업데이트를 막는다. 이는 모형의 불확실성을 증가시켜 과적합 해결에 기여한다. 드롭아웃 비율을 얼마로 해야 하는가에 정답은 없다. 개인적으로 과적합이 심하지 않다면 0.10.5를, 심하다 싶으면 0.70.8로 설정한다. 다만, 드롭아웃의 의미를 알고 얼마나 꺼볼까? 하는 개념을 가지고 진행하는 것을 추천한다. 또 여러 layer 마다 드롭아웃을 다르게 줄텐데 불확실성을 높인다.는 논리하에서 노드의 수가 많은 층의 드롭아웃을 우선 적용하고 비율도 높게 주고 있다. 다만 결과는 보장하지 못한다. 😒 ​ ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:1","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"2. L1(Lasso)/L2(Ridge) Regularization 학습에 기여하지 못하는 모수를 0으로 만들어버리자로 접근하는 방법 아래 수식과 같이 손실함수에 람다항을 추가해서 일종의 페널티를 주는 방법. ​ L1 Regularization(절댓값) L2 Regularization(제곱) 자세한 증명은 이 블로그를 참고 내가 중요하게 학습 시키고 싶은 정보는 regularization을 가급적 출력층에 사용하는 것이 좋다는 것이다. 교수님께서는 regularization이 통계학의 가설검정과 유사하다고 하셨는데, 가설검정 시 t값이나 F값, 혹은 p-value를 통해 유의미한 변수인지 아닌지를 판단하는 것처럼 regularization은 loss를 줄이는데 기여하지 못하는 모수를 0(L1) 또는 0에 가까운(L2) 값으로 제한하는 기능을 한다. 보통 L2 regularization이 L1보다 더 많이 쓰인다. ​ 여기서 잠깐! \u003cQ. Dropout과 Regularization을 동시에 사용해야 하는가?\u003e 이 질문에 대한 답변은 교수님 버전과 구글링 버전이 달라서 혼란스러웠다. 교수님: 두 기법은 상호보완관계, 하나만 쓰면 안되고 둘 다 써야한다. 구글링: 두 기법은 상호보완 관계, 보통 둘 다 쓰는게 성능이 더 높은데 하나만 쓸지 둘 다 쓸지는 경험적으로 판단할 문제다. 즉, 케바케! 데바데! 실제 실험을 해보았을 때에는 구글링 답변처럼 모델마다 결과가 달랐다. 어떤 모델은 두 기법 모두 쓰는게 효과가 좋았고 또 어떤 모델은 하나씩만 쓰는게 더 좋았다. 개인적으로 구글링 입장에 동의하고, 일반적으로 둘 다 쓰는게 성능이 더 높다고는 하니 둘 다 실험해보는 것을 추천한다. ​ ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:2","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"3. 출력층 직전 은닉층의 노드 수를 줄여라. 출력직전 모수를 줄이는게 효과가 좋았다. 통계학에서 오버피팅을 해결하는 방법은 쓸데없는 변수를 제거해서 입력변수 x의 수를 줄이는 것인데(t-test 등을 통해 significant하지 않은 변수를 제거한다) 통계학의 관점에서 출력층 직전 은닉층 노드 수는 설명변수의 수가 된다. 따라서 의미있는 설명변수들을 남기기 위해/생성하기 위해 출력직전 노드 수를 확 줄여버리는 것이다. 나는 주로 출력 범주의 수가 20이하인 경우, FCL(Fully Connected Layer) 마지막 층의 노드 수를 32로 줄인다. 만약 출력 범주의 수가 100 이상으로 넘어갈 경우엔 그에 맞춰서 마지막 층 노드 수를 결정한다. cf) 비슷한 이야기로 과적합을 막으려면 모수(parameter)의 수를 줄여야 하는데, 은닉층 자체를 줄이거나 은닉층 노드 수를 줄이면 된다. 이때 터무니없이 막 줄이면 안되고, 조절해보면서 적당한 선을 찾아야 한다. CNN에서는 kernel size, pooling size, filter 수를 줄이면 된다. ​ ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:3","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"4. Batch Normalization(배치정규화) 뉴럴넷에서 각 활성함수의 미분값은 역전파 과정에서 계속 곱해지기 때문에 굉장히 중요하다. 시그모이드 함수의 경우 일정수준 이상 혹은 이하의 값이 입력되었을때 미분값이 0에 가깝게 되는데, 이때 파라미터 업데이트과정에서 0에 가까운 값이 지속적으로 곱해지면 vanishing gradient(기울기 소실) 문제가 발생한다. 이렇게 되면 파라미터 업데이트가 거의 일어나지 않고 수렴 속도도 아주 느리게 되어 최적화에 실패하게 되는데, 이 문제를 해결하는 방법으로는 배치정규화 외에도 relu 등의 활성함수를 사용하거나 **가중치 초기화(weight initialization)**을 적용하는 방법이 있다. 배치정규화는 mini batch 별로 분산과 표준편차를 구해 분포를 조정한다. 역전파시 파라미터 크기에 영향을 받지 않기 때문에 좋다고 한다. 배치정규화는 각 은닉층에서 활성함수 적용 직전에 사용되어야한다. 일반적으로 선형결합-배치정규화-활성함수-드롭아웃 순으로 은닉층 연산이 진행된다. ​ ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:4","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"5. 그 외 참고하면 좋을 사항들 1. epoch의 증가는 과적합 해결을 위한 수단이 아니라 모니터링 수단이다. 단순하게 epoch만 늘려주면 train data의 loss는 줄고 accuracy는 높아지기 때문에 train data의 loss와 accuracy는 valid 결과와 비교하기 위한 참고사항일 뿐이다. epoch 수를 늘리면 valid와 train loss가 교차하는 지점이 발생한다. 일반적으로 valid loss가 감소하다가 증가하는 시점을 과적합으로 정의하기 때문에 이 지점에서 적당한 epoch을 결정한다. 이는 early stopping과도 관련이 있다. ​ 2. epoch이 증가하면서 train loss 와 valid loss가 수렴해야 가장 좋다. 교차점에서 epoch을 결정하더라도 train과 최종 test loss와 accuracy를 비교해야한다. 이러한 점검은 cross-validation으로 진행해야한다. ​ 3. batch_size는 과적합과 관련이 없다. 모수의 수렴 문제와 관련이 있다. 배치사이즈가 작을 수록 수렴속도는 느리지만 local minimum에 빠질 가능성은 줄어든다. 반면 배치사이즈가 클 수록 학습진행속도와 수렴속도가 빨라지지만 항상 빨리 수렴하는 것은 아니다. 작은 데이터셋이라면 32가 적당하다고 하는데 이 역시도 구글링하다보면 수많은 의견들이 존재한다. 적당히 참고해가면서 실험해보면 좋겠다. ​ ​ ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:0:5","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["AI","Overfitting"],"content":"참고 https://velog.io/@yookyungkho/%EB%94%A5%EB%9F%AC%EB%8B%9D%EC%9D%98-%EA%B3%A0%EC%A7%88%EB%B3%91-Overfitting%EA%B3%BC%EC%A0%81%ED%95%A9-%ED%95%B4%EA%B2%B0-%ED%8C%81 ​ ","date":"2022-12-28","objectID":"https://colinder.github.io/overfitting/:1:0","tags":["AI","Overfitting"],"title":"Overfitting","uri":"https://colinder.github.io/overfitting/"},{"categories":["Web"],"content":"​ axios 설치 및 전역변수 설정 방법 front와 back간의 통신에 자주 사용하는 axios의 설치 및 전역 변수 설정 방법을 기록합니다. 먼저, axios의 특징은 구형 브라우저를 지원한다. 응답 시간 초과를 설정하는 방법이 있다. JSON 데이터 자동변환이 가능하다. node.js에서의 사용이 가능하다. request aborting(요청 취소)가 가능하다. catch에 걸렸을 때, .then을 실행하지 않고, console창에 해당 에러 로그를 보여준다. 설치부터 진행해보겠습니다. 테스트는 Vue를 활용하여 진행하였습니다. ​ ","date":"2022-12-14","objectID":"https://colinder.github.io/axios/:0:0","tags":["Vue","Web","AJAX","axios"],"title":"what is Axios \u0026 usage for Vue","uri":"https://colinder.github.io/axios/"},{"categories":["Web"],"content":"1. axios 설치 // Terminal에 npm install axios 👈 axios 설치 ​ ","date":"2022-12-14","objectID":"https://colinder.github.io/axios/:0:1","tags":["Vue","Web","AJAX","axios"],"title":"what is Axios \u0026 usage for Vue","uri":"https://colinder.github.io/axios/"},{"categories":["Web"],"content":"2. axios 전역 설정 // main.js or main.ts import Vue from 'vue' import App from './App.vue' import router from './router' import store from './store' import vuetify from './plugins/vuetify' import Axios from 'axios' // 👈추가 Vue.config.productionTip = false Vue.prototype.axios = Axios // 👈추가 new Vue({ router, store, vuetify, render: h =\u003e h(App) }).$mount('#app') 두 번째 // 👈추가를 보면 어디서든 axios라는 이름으로 호출하겠다. 고 선언한 겁니다. 만약 Vue.prototype.imAxios = Axios 라고 선언하면 imAxios 라는 이름으로 호출 ​ ","date":"2022-12-14","objectID":"https://colinder.github.io/axios/:0:2","tags":["Vue","Web","AJAX","axios"],"title":"what is Axios \u0026 usage for Vue","uri":"https://colinder.github.io/axios/"},{"categories":["Web"],"content":"3. axios 사용 예시 저는 Vue 개발방법 두 가지(함수형, 클래스형) 중 클래스 형으로 개발하고 ‘vue-property-decorator’라는 라이브러리를 적용하여 개발하였습니다. 하여 구조가 다른 개발자분들과 다를 수 있습니다. \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003eaxios Test\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import {Component, Vue} from 'vue-property-decorator'; @Component({ name: 'Test', components: { } }) export default class Test extends Vue { mounted() { this.axios.post('URL', prams) .then((res) =\u003e { console.log(res) }) .catch((err) =\u003e { console.error(err) }) } } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e 간단히 하자면, Vue의 특징인 SPA방식으로 해당 코드의 화면이 mounted 될 때, 'URL' 주소로 prams를 담아 POST 요청을 보낸다. 요청에 성공하면(.then() 동작) console.log로 응답(res)온 사항을 출력한다. 요청을 실패하면(.catch() 동작) console.error로 응답(err)온 사항을 출력한다. ​ ​ ​ ","date":"2022-12-14","objectID":"https://colinder.github.io/axios/:0:3","tags":["Vue","Web","AJAX","axios"],"title":"what is Axios \u0026 usage for Vue","uri":"https://colinder.github.io/axios/"},{"categories":["Web"],"content":"Example jsonplaceholder라는 json형태의 가상테이터 요청 사이트를 이용해 테스트를 진행 솔직히 여기 site의 Guide만보고 따라해도 AJAX를 맛볼 수 있다. (혹시 몰라 설명하자면, Guide의 “fetch\"를 “axios\"로 바꾸어 사용해보면 된다. ) // 새로 프로젝트를 만들고 npm install axios 설치하고, main.js에서 전역설정해준 뒤 진행. // test해볼 conponents인 HelloWorld.vue의 내용을 수정해서 진행. // HelloWorld.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003eaxios 테스트\u003c/h1\u003e 👈 \u003cbutton @click=\"axiosTest()\"\u003eaxios 테스트\u003c/button\u003e 👈 \u003cp\u003e{{this.posts}}\u003c/p\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import {Component, Vue} from 'vue-property-decorator'; @Component({ name: 'HelloWorld', components: { } }) export default class HelloWorld extends Vue { posts: '' axiosTest() { const baseURI = 'https://jsonplaceholder.typicode.com' this.axios.get(`${baseURI}/posts`) .then((res) =\u003e { alert('1차 요청 완료') this.posts = res.data }) } } \u003c/script\u003e // 살짝 JSONPlaceholder의 공식 Guide를 따르진 않는다. 서버실행화면 =\u003e 버튼클릭 후 결과화면 (요청이 잘 받아진 화면을 확인할 수 있다.) ​ 보기 좋게 parsing해보자. // HelloWorld.vue \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003eaxios 테스트\u003c/h1\u003e \u003cbutton @click=\"axiosTest()\"\u003eaxios 테스트\u003c/button\u003e \u003cp v-for=\"(post, i) in posts\" :key=\"i\"\u003e{{post}}\u003c/p\u003e 👈 수정 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e // 변화 없음 export default class HelloWorld extends Vue { posts: '' axiosTest() { const baseURI = 'https://jsonplaceholder.typicode.com' this.axios.get(`${baseURI}/posts`) .then((res) =\u003e { alert('1차 요청 완료') this.posts = res.data }) } } \u003c/script\u003e 서버실행화면 =\u003e 버튼클릭 후 결과화면 ​ ​ 하지만, 여기서 의문이 생긴다. 비동기 요청인 axios를 동기적으로 처리 할 순 없을까? ","date":"2022-12-14","objectID":"https://colinder.github.io/axios/:1:0","tags":["Vue","Web","AJAX","axios"],"title":"what is Axios \u0026 usage for Vue","uri":"https://colinder.github.io/axios/"},{"categories":["Vue"],"content":"​ Vuex 핵심컨셉(getters, mutations, actions, modules) ​ ","date":"2022-11-29","objectID":"https://colinder.github.io/08_vue_vuex-concept/:0:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"🤔여기까지 왔다면, 이 흐름을 보자. 이제 다시 컨셉들을 보자 ​ ​ ","date":"2022-11-29","objectID":"https://colinder.github.io/08_vue_vuex-concept/:1:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"3. Actions 공식문서에 따르면 액션(Actions)은 변이(mutations)와 유사하나, 몇가지 다른 점이 있다고 한다. 상태를 변이시키는 대신 액션으로 변이에 대한 커밋을 합니다. 작업에는 임의의 비동기 작업이 포함될 수 있습니다. Q. 상태를 변이시키는 대신 액션으로 변이에 대한 커밋을 합니다. A. mutations의 역할은 State를 관리하는 것이다. 그런데 만약 비동기적 요청을 마구잡이로 보내게 된다면, State가 변질될 가능성이 높아진다. 결국 비동기 요청의 경우에도 mutations에 정의한 메소드의 형태로 보내어 상태가 변화하는 것을 추적한다. ​ Q. 작업에는 임의의 비동기 작업이 포함될 수 있습니다. A. 예를 들어 axios요청을 보내놓고 store에 등록된 자료를 가져오거나 수정해 사용하고 싶은 경우 사용하겠다. ​ - 이론적인 개념을 조금 더 생각해보자면, mutations의 경우 디버깅을 위해 동기(순차)적으로 작동이 되었으나 actions의 경우 비동기(비순차)적인 역할을 수행하는데 도움이 된다. 예를 들면, axios요청을 보낸다 던가. setTimeout()을 설정해 작동 시간을 조정한다던가. ​ 🙋‍♂️간단히 Actions을 실습해 봅시다. (Step. 1, 2로 구성) Step. 1 // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { addOneMutations(state) { return state.second++ } }, actions: { 👈 //비동기 요청인 setTimeout을 실습 👈 delayFewMinutes(context) { 👈 context는 그냥 선언적인 겁니다. return setTimeout(() =\u003e { 👈 context.commit('addOneMutations'); 👈 actions도 결국 commit 으로 }, 1000) 👈 mutations를 불러오는 겁니다. } 👈 'addOneMutations'는 위에 mutations에 } 👈 선언한 것을 불러온 것이고 / 1000은 1초를 의미 }) ​ Step. 2 //사용하는 component에서 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eMutations 사용한 값: {{$store.state.second}}\u003c/h1\u003e \u003cbutton @click=\"useMutations\"\u003e+\u003c/button\u003e \u003chr\u003e \u003ch1\u003eActions 사용한 값: {{$store.state.second}}\u003c/h1\u003e 👈 \u003cbutton @click=\"useActions\"\u003e+\u003c/button\u003e 👈 \u003chr\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { //mutations을 이용할 떄는 commit을 사용 useMutations() { return this.$store.commit(\"addOneMutations\", {N: 2}) }, //actions를 이용할 떄는 dispatch를 사용 👈 useActions() { 👈 return this.$store.dispatch(\"delayFewMinutes\") 👈 actions은 store에서 } 👈 'dispatch'로 불러옵니다. } } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ✋잠깐. Actions도 인자를 넘길 수 있는데! \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { //mutations을 이용할 떄는 commit을 사용 useMutations() { return this.$store.commit(\"addOneMutations\", {N: 2}) }, //actions를 이용할 떄는 dispatch를 사용 useActions() { return this.$store.dispatch(\"delayFewMinutes\", {by: 50, time: 2000}) 👈 요기요기 } } } \u003c/script\u003e // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { addOneMutations(state) { return state.second += 2 } }, actions: { //비동기 요청인 setTimeout을 실습 delayFewMinutes(context, payload) { 👈 return setTimeout(() =\u003e { 👈 context.commit('addOneMutations', payload.by) 👈 이런식으로 인자로 작동시간 }, payload.time) 👈 설정도 가능하고, mutations에 } 👈 payload 받는 부분 만들어서 } 👈 거기까지도 전달 가능 }) ​ ","date":"2022-11-29","objectID":"https://colinder.github.io/08_vue_vuex-concept/:2:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"4. Modules 모듈은 간단하게 store에 여러개의 저장소(모듈s)를 만들어 관리한다는 것이다. 공식문서에 따르면 Vuex는 저장소를 모듈 로 나눌 수 있습니다. 고 설명하고 있다. //예를 들자면 이런 모습으로.(출처: 공식문서) const moduleA = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: () =\u003e ({ ... }), mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { 👈 여기서 모듈을 선언해주고 a: moduleA, 👈 각각의 모듈을 등록해주고 있는 b: moduleB 👈 모습을 볼 수 있다. } }) ​ ​ ​ ​ ","date":"2022-11-29","objectID":"https://colinder.github.io/08_vue_vuex-concept/:3:0","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["Vue"],"content":"✨실습해보면서 알게된 포인트를 정리하며 마친다. 1️⃣ Mutations은 동기(순차)적인 경우에 Actions은 비동기(비순차)적인 경우에 사용한다. (하지만 Actions도 결국엔 Mutations를 불러와 사용한다.) 2️⃣ 각각의 Components에서 Actions는 dispatch로 호출해 사용한다. Mutations는 commit으로 불러와서 사용 3️⃣ Modules는 store의 저장소를 분할해 등록하고 싶을 때 사용한다. Vue는 단일 트리 컴포넌트 형식이니 자주 사용되진 않을 것 같다. ","date":"2022-11-29","objectID":"https://colinder.github.io/08_vue_vuex-concept/:3:1","tags":["Vue"],"title":"08_Vue_Vuex Concept...","uri":"https://colinder.github.io/08_vue_vuex-concept/"},{"categories":["mariaDB"],"content":"​ MariaDB mysql, mariaDB를 계속해서 사용하고 있지만, 계정과 데이터베이스 연결 관계 등 정확한 개념과 이해는 하지 않은 채 시간이 흘러가고 있어, 이번에 정리하고 기록합니다. 전체적인 용어와 개념이 틀렸을 수도 있습니다. 제가 이해하기 쉬운 언어와 그림으로 정리하였습니다. 잘못된 부분이 있다면 꼭. 피드백을 부탁드립니다. ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:0:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"진행과정 “계정생성” \u003e “database생성”\u003e “권한부여” \u003e “하이디에서 확인” 과정을 진행해보며 mariaDB의 구조와 흐름을 이해. ​ ​ MariaDB를 설치한 후 MySQL Client에서 우선 진행. ​ ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:1:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"MariaDB 기본 정보 MariaDB를 설치하고 MySql Client로 접속을 시도하면 비밀번호를 입력하라는 메세지를 볼 수 있다. 이는 프로그램을 설치할 때 root라는 계정의 비밀번호를 생성하는데 그떄 비밀번호를 입력하면 된다. 이 행위는 root라는 admin 계정으로 MariaDB 시스템에 접속하는 과정임을 알아야 한다. ​ 비밀번호를 입력하면 mariaDB 시스템에 접속하게 된다. ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:2:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"Default database 확인 mariaDB는 설치하게 되면 default로 세팅이 되는데. 데이터베이스를 보자면, show databases; 4개의 데이터 베이스가 생성되어 있다. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:2:1","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"여기서 잠깐💡 mariaDB는 ‘작업공간’이라는 개념이 있다. 현재는 mariaDB의 어떤 데이터베이스(작업공간)도 선택되지 않은 상태이다. ​ 아래와 같은 명령어로 테이터베이스(작업공간)으로 접속할 수 있다. use mysql; /* mysql이라는 데이터베이스(작업공간)을 사용하겠다.*/ 잘 변경되었다면, MariaDB [mysql] 과 같이 데이터베이스(작업공간)에 들어와 있는 것을 알 수 있다. ​ 명령어를 입력하는데 내가 의도한 작업공간이 아닌 경우 에러가 날 수 있으니, 내가 의도한 작업공간안에 들어와서 명령어를 입력한다. 는 개념을 가지고 있어야 한다. ​ ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:2:2","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"Default 생성 계정 확인 또한 계정이 생성되는데 생성되는 계정은 mysql 데이터베이스안에 user라는 테이블에 생성된다. /* mysql의 user라는 곳에서 user와 host를 선택한다.*/ select user, host from mysql.user; /* 만약 mysql이라는 작업공간으로 접속해 명령어를 입력한다면, */ select user, host from user; mariaDB라는 시스템에 등록된 계정이 여기에 쌓이게 되는 것이다. ​ 이외의 데이터베이스에는 user라는 테이블도 없다. ​ 참고로 mysql에 default로 생성된 테이블은 아래와 같다. ​ information_schema는 총 79개의 테이블 ​ sys는 총 101개의 테이블 ​ performance_schema는 총 81개의 테이블이 있다. ​ ​ 즉, mariaDB라는 시스템을 설치하면, 기본적으로 4개의 데이터베이스 생성되고 ​ ​ ​ 시스템에 등록되는 계정은 mysql이라는 데이터베이스의 user라는 테이블에서 관리된다. 그리고 user 테이블에는 기본적으로 5개의 계정이 있고 이들이 어떤 역할을 하는지는 여기서 다루지는 않겠다. (실은 잘 모른다.) ​ ​ ​ 여기까지 MariaDB를 설치하면 생기는 기본적인 세팅에 대하여 살펴보았고, 지금부터 “계정생성” \u003e “database생성”\u003e “권한부여” \u003e “하이디에서 확인”의 과정을 진행. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:2:3","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"계정 생성 이제 계정을 생성한다. 처음 mariaDB에 접속하면 “none으로 어떤 데이터베이스도 선택되지 않았음\"을 알 수 있다. ​ 어떤 데이터베이스도 선택하지 않고 테스트 계정을 만들어 보면, create user 'none_database_user'@'%' identified by '1234'; /* 어디서든 접속할수있는(%) none_database_user라는 계정을 만들고 비밀번호는 1234 */ 그 계정은 위에서 말한 mysql 데이터베이스에 user 테이블에 생성됨을 알 수 있다. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:3:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"계정 삭제 delete from mysql.user where user='삭제할계정이름'; /* user테이블에서 삭제 */ delete from mysql.db where user='삭제할계정이름'; /* 계정DB에 반영 */ flush privileges; /* 시스템 반영 */ 위에서 설명했듯 mysql 데이터베이스에 user라는 테이블에 계정이 생성되는데, 계정을 삭제하는 위치(from)을 구체적으로 명시하지 않으면 정상적으로 동작 하지 않는다. delete from user where user=‘none_database_user’; delete from mysql.user where user=‘none_database_user’; 이 둘의 차이를 알아여하며, 내가 작업하고 있는 공간이 어디인지를 계속 생각해야 한다. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:4:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"권한 부여 계정을 생성하면 기본적으로 information_schema 테이블이 생긴다. INFORMATION_SCHEMA란 MySQL 서버 내에 존재하는 DB의 메타 정보(테이블, 칼럼, 인덱스 등의 스키마 정보)를 모아둔 DB다. INFORMATION_SCHEMA 데이터베이스 내의 모든 테이블은 읽기 전용이며, 단순히 조회만 가능하다. 즉, 읽기전용(Read-only)으로 사용자가 직접 수정하거나 관여할 수는 없다. 진행해야 할 것은 내가 사용할 데이터 베이스를 만들고 특정 계정에 그 데이터 베이스를 관리하라는 권한을 주어야 한다. ​ 계정은 “human”으로 만들고, 데이터베이스는 “box”로 만들어보겠다. /* 계정 생성 */ create user 'human'@'%' identified by '1234'; /* 데이터베이스 생성 */ create database box; ​ 계정 생성 확인 select user, host from mysql.user; ​ 데이터베이스 생성 확인 show databases; ​ ​ 생성한 human의 초기 권한을 확인해보면, show grants for 'human'@'%'; 무슨 말인지 모르겠습니다. ​ ​ human 계정에 box 데이터베이스의 모든 권한을 주고 grant all privileges on box.* to 'human'@'%'; /* 모든(all) 권한을 box데이터베이스하위 모든 곳(box.*)에 human계정에게 부여한다. */ ​ ​ 이후 다시 human의 권한을 확인해보면, 나름의 해석 USAGE ON *.* 의 의미는 모든 데이터베이스에 대하여 접근할 수 있다. 정도인 것 같습니다. box에 모든 권한을 받은 것을 확인 ​ ​ 여기까지 진행한 사항을 DB에 반영하기 위해서는 flush privileges; 를 입력 ​ ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:5:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"하이디(MariaDB GUI 시스템)으로 확인 하이디에서는 계정 별로 할당된 데이터베이스를 보는 시스템임을 알아 두어야 합니다. ​ 프로그램 시작 후 초기 모습 아무런 정보도 보이지 않음. ​ ​ ​ 우선 root 계정에 대하여 확인해보겠습니다. 신규 \u003e 세션이름 변경(root) \u003e 사용자/암호 입력 \u003e 열기 *세션 이름은 아무렇게나 설정해도 됩니다. ​ ​ ​ ​ 위에서 만들었던 “box” 데이터베이스를 비롯, 기본으로 생기는 4개의 데이터베이스를 root계정으로 확인할 수 있음을 알 수 있다. ​ ​ ​ ​ human 계정으로 접근한다면? 신규 \u003e 세션이름 변경(human) \u003e 사용자/암호 입력 \u003e 열기 *세션 이름은 아무렇게나 설정해도 됩니다. ​ ​ ​ ​ 아까 권한을 준 box 데이터베이스와 default로 생성되는 information_schema 데이터베이스만 접근이 가능한 것을 알 수 있습니다. ​ ​ ​ ​ 위의 상황을 이미지로 표현한다면, root 계정으로 접속한다면? ​ ​ ​ ​ human 계정으로 접속한다면? 이와 같이 표현할 수 있습니다. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:6:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["mariaDB"],"content":"간단히 정리하자면, 마리아디비에 등록된 계정마다 데이터베이스 (접근)권한을 부여하고 권한에 따라 접근할 수 있는 데이터베이스가 다르다. 또한 데이터베이스마다 시스템(ex. backend)을 연결하여 개발을 한다. ​ ​ 계정과 데이터베이스의 관계 그리고 데이터베이스를 다른 시스템(ex. backend)에 연결하여서 사용한다고 했을 때, DB 계정과 backend에서 생서한 계정의 차이. DB 계정이 관리할 수 있는 내용와 한계 등을 이해하는데 도움이 되었으면 합니다. ​ ​ ​ ","date":"2022-11-11","objectID":"https://colinder.github.io/understand_of_mariadb/:7:0","tags":["mariaDB"],"title":"Understand_of_MariaDB","uri":"https://colinder.github.io/understand_of_mariadb/"},{"categories":["ai","sequence"],"content":"​ Sequence data 자연에는 사건이 발생하는데, 이는 대부분 시간에 따른 원인에 의한 결과로써 발생하게 된다. 예를들어 오전에는 맑았는데 오후에는 흐리다. 상반기에는 잘 팔렸는데, 하반기에는 잘 안팔린다. 기분이 나빴는데, 좋아졌다. 등등 순서(sequence)대로 하나씩 나열하여 나타낼 수 있는 데이터를 Sequence data라고 한다. 그리고 이 데이터들은 서로 독립적이지 않다.는 특징을 가지고 있다. 즉, 원인과 결과가 무한이 이어져있다. ​ ​ ","date":"2022-10-25","objectID":"https://colinder.github.io/what_is_sequence_data/:0:0","tags":["ai","sequence"],"title":"What is Sequence_data \u0026 apply AI","uri":"https://colinder.github.io/what_is_sequence_data/"},{"categories":["ai","sequence"],"content":"Sequence data의 구조와 주로 활용되는 형태 많은 사람들이 시도해보는 주식 예측 인공지능 개발을 가정하여 설명. A회사의 ‘주가’를 예측할 것이며 주식은 시간에 따라 ㄱ, ㄴ, ㄷ, ㄹ, ㅁ이라는 사건에 영향을 받는다. ㄱ, ㄴ, ㄷ, ㄹ, ㅁ은 수치화 할 수 있다. ​ A회사 주식의 변화를 표로 나다내면 아래와 같다. 날짜 주가 ㄱ ㄴ ㄷ ㄹ ㅁ 1900-01-01 10,000 45 6 23 54 3 1900-01-02 10,100 41 8 28 50 1 1900-01-04 10,200 39 4 30 47 2 1900-01-05 10,200 36 4 26 49 3 1900-01-06 10,500 47 7 29 46 1 1900-01-07 10,100 50 10 24 44 2 1900-01-08 10,200 60 8 25 50 3 우선 간단히 데이터를 분석하자면, 1900-01-01부터 보통 1일간의 간격(sequence)으로 데이터가 수집되었다. 1900-01-04 데이터는 결측되었다. 데이터가 수집된 일자의 변수(feature) ㄱ, ㄴ, ㄷ, ㄹ, ㅁ의 결측은 없다. 정도로 간단히 분석할 수 있다. ​ ​ ","date":"2022-10-25","objectID":"https://colinder.github.io/what_is_sequence_data/:0:1","tags":["ai","sequence"],"title":"What is Sequence_data \u0026 apply AI","uri":"https://colinder.github.io/what_is_sequence_data/"},{"categories":["ai","sequence"],"content":"Apply AI 이를 인공지능에 적용하기 위해서는 데이터 전처리 라는 과정이 필요하다. 데이터를 어떻게 전처리해 AI의 학습 데이터로 사용할지는 전처리 방법의 차이 학습용 데이터 구조를 어떻게 만드느냐? 어떤 모델을 사용할 것이냐? 등의 차이가 있고, 절대적인 정답은 없다. ​ 간단히 시퀀스 데이터 형태로 변환하자면, data_set = [[45,6,23,54,3], [41,8,28,50,1], [39,4,30,47,2], [36,4,26,49,3], [47,7,29,46,1], [50,10,24,44,2], [60,8,25,50,3]] 와 같이 구조화할 수 있겠다. ​ ​ 💡 여기서 알아야할 점이 있다. 아래와 같은 데이터가 있다. seq_data = [0, 3, 4, 5] filter = [1, 2] seq_data에 filter를 곱해(seq_data ⦿ filter) output = [6, 11, 14] 라는 결과가 나왔다. ​ *해당 과정의 흐름을 기억해야 한다. / seq_data에 filter를 적용해 output을 계산했다. (seq_data ⦿ filter = output) ​ 위의 주식 예측 인공지능에 맞대어 생각해본다면, [0, 3]라는 변수가 있을 때 주가가 6이었고, [3, 4]라는 변수가 있을 때 주가가 11이었고, [4, 5]라는 변수가 있을 때 주가가 14이었다. ​ ​ 그렇다면, 주식 예측 인공지능를 개발하기 위해서 진행되어야 하는 과정은 seq_data가 있고 output이 있을 때, filter 값를 찾아 향후 seq_data에 대입해 계산해보는 것이다. 즉, (seq_data ⦿ filter = output)에서 filter 값을 찾아주는 것이 인공지능의 역할이며 위의 filter라는 명칭은 인공지능에서 가중치(weight)라고 불리며 이를 찾아 가는 것이 인공지능의 핵심이다. ​ ​ ​ 아까 주식 데이터에서 날짜를 고려하지 않고, 3일간의 데이터를 사용해 1일 뒤(1900-01-09)의 주가를 예측한다고 했을 때, 날짜 주가 ㄱ ㄴ ㄷ ㄹ ㅁ 1900-01-01 10,000 45 6 23 54 3 1900-01-02 10,100 41 8 28 50 1 1900-01-04 10,200 39 4 30 47 2 1900-01-05 10,200 36 4 26 49 3 1900-01-06 10,500 47 7 29 46 1 1900-01-07 10,100 50 10 24 44 2 1900-01-08 10,200 60 8 25 50 3 01-01, 01-02 데이터는 활용하기 어렵다. (별도의 결측치 대치 전처리를 하지 않는 이상.) =\u003e 연속된 4일간의 데이터가 있어야, 주제에 맞는 인공지능 학습용 데이터 세트를 만들 수 있다. ​ [[39,4,30,47,2], [36,4,26,49,3], [47,7,29,46,1]] x filter(weight) = 10,100 [[36,4,26,49,3], [47,7,29,46,1], [50,10,24,44,2]] x filter(weight) = 10,200 [[47,7,29,46,1], [50,10,24,44,2], [60,8,25,50,3]] x filter(weight) = ? 이렇게 인공지능은 filter(weight)를 찾아 “예측\"을 하게 된다. ​ ​ ​ ​ ​ 이 과정에 “예측\"에 대한 많은 오점과 오류와 가정를 찾기를 바란다. 이와 같은 방법이 맞을 수 있으나, 우리가 사는 세상에 적용하기에 수많은 오점과 오류가 있으며, 가정이 필요하다. ​ ​ ​ ​ ","date":"2022-10-25","objectID":"https://colinder.github.io/what_is_sequence_data/:0:2","tags":["ai","sequence"],"title":"What is Sequence_data \u0026 apply AI","uri":"https://colinder.github.io/what_is_sequence_data/"},{"categories":["ML","Machine_learning "],"content":"​ Machine learning (ML) 머신러닝을 활용하기에 좋은 분야에 대하여 알아보겠습니다. ​ 분류(classification) 정해진 카테고리 중 어디에 속하는지 알아내는 경우 종류 KNN(k-nearest neighbor) k-nearest neighbor는 데이터를 분류하고 새로운 데이터 포인트의 카테고리를 결정할 때 K 개의 가장 가까운 포인트를 선점하고 그중 가장 많이 선택된 포인트의 카테고리로 이 새로운 데이터를 분류하는 방법이다. 중요 개념 좌표와 같이 데이터의 위치를 특정할 수 있게 변환 내 주변에 가까운 K개의 데이터와의 거리를 재고 그 중 더 많은 값에 내가 속한다고 판단. K는 홀수로 등록(짝수의 경우 class 가 50:50으로 나뉘면 내가 어디 속하는지 판단할 수 없음.) .fit() 없이 데이터를 바로 가져와서 분석 가능 == Lazy model 데이터와의 거리를 재는 방식은 여러개가 있으니 상황에 맞게 선택하여 사용 예를 들어 실수 데이터의 경우 유클리드 거리 측정 방식을 사용하고, 범주형 혹은 이진 데이터와 같은 유형의 데이터는 해밍 거리 측정 방식을 사용 ​ ​ Decision Tree(의사결정 트리) 가장 단순한 classifier 중 하나로, decision tree와 같은 도구를 활용하여 모델을 그래프로 그리는 매우 단순한 구조로 되어 있다. 이 방식은 root에서부터 적절한 node를 선택하면서 진행하다가 최종 결정을 내리게 되는 model(훈련 데이터에 오버피팅이 되는 경향이 있다.) 중요 개념 가지치기(pruning) 엔트로피(Entropy) 불순도(Impurity) 정보 획득(Information gain) 프로세스 가지치기를 통해 얼만큼의 조건(분기)를 줄지 설정. 엔트로피는 불순도와 같은 의미를 가지는데, 해당 범주안에 서로 다른 데이터가 얼마나 있는지를 뜻. 엔트로피 1는 한 범주안에 정확히 반반의 데이터가 있다는 뜻. 엔트로피 0은 한 범주 안에 하나의 데이터만 있다는 뜻. 즉 불순도가 낮아야 정확한 분류가 되었다는 의미 엔트로피가 1인 상태에서 0.7로 변경되었다면, 정보 획득(Information gain)은 0.3 정보 획득이 최대화하는 방향으로 학습이 진행 ​ ​ Random Forest Decision tree 여러개 모아 Forest를 이루고 여러 트리의 결과값을 종합해 최종 결과를 판단. (훈련 데이터 오버피팅을 어느 정도 완화할 수 있다. ) 중요 개념 20개의 feature가 있을 때 이 중 5개의 feature만 가지고 결정트리를 생성 (복원 추출/비복원 추출 선택 사용 가능) 또 이 중 5개의 feature만 가지고 결정트리를 생성을 반복하여 결정 트리마다의 예측값들 중 가장 많이 나온 값을 최종 예측값으로 결정 ​ 중요 변수 n_estimators: 랜덤 포레스트 안의 결정 트리 갯수 (클수록 좋으나, 그만큼 메모리와 훈련시간이 늘어남) max_features: 무작위로 선택할 Feature의 개수 boostrap = False 설정을 한다면 비복원 추출을 하기 때문에 사실 전체 feature를 사용해 트리를 만듦. boostrap = True 설정은 복원 추출 max_features가 크면, 트리들이 비슷하게 생겨 두드러진 특성을 잘 잡고, 작다면 오버피팅이 줄어드는 효과가 있음. ​ ​ SVM (Support Vector Machine) 분류와 회귀에서 사용되는 데 분류 모델은 SVC(Support Vector Classifier), 회귀 모델은 SVR(Support Vector Regression)이라 함. 주어진 데이터가 어느 카테고리에 속할지 판단하는 이진 선형 분류 모델 Decision Boundary라는 직선이 주어진 상태 중요 인자. kernel, C, Gamma kernel : decision boundary의 모양을 선형으로 할지 다항식형으로 할지 등을 결정 C : decision boundary의 유연성을 설정. C가 크면 decision boundary는 더 굴곡지고, C가 작으면 decision boundary는 직선에 가깝습니다. Gamma : reach에 영향을 주어 decision boundary에 가까운(혹은 먼) 요소만을 적용하여 설정. Gamma가 크면 decision boundary는 더 굴곡지고, Gamma가 작으면 decision boundary는 직선에 가깝습니다. ​ ​ Naive Bayes (나이브 베이즈) 베이즈 정리에 기반한 통계적 분류 기법. 나이브 베이즈는 feature끼리 서로 독립이라는 조건이 필요합니다. 즉, 스펨 메일 분류에서 광고성 단어의 개수와 비속어의 개수가 서로 연관이 있어서는 안 됩니다. ​ ​ K-means Clustering(K-평균 클러스터링) 클러스터란 비슷한 특성을 가진 데이터끼리의 묶음입니다. 즉 K 개의 데이터들의 평균을 활용한 군집(Cluster)을 만들고 이에 따른 분류를 하는 기술입니다. 중요 개념 클러스터의 중심(means)을 Centroid라고 합니다. ​ 프로세스 몇 개의 클러스터(class)가 필요한지 결정 (K 결정) 초기 Centroid 위치 지정 랜덤하게 지정 수동으로 지정 Kmean ++ 지정 모든 데이터를 순회하며 각 데이터마다 가장 가까운 Centroid가 속해있는 class로 할당 할당된 class 별 Centroid의 평균(means)으로 Centroid를 이동 클러스터에 할당되는 데이터에 변화가 없을 때까지 스텝 3, 4를 반복 ​ 회귀(regression) 어떤 정확한 값을 예측하는 경우에 사용합니다. 집 평수에 따른 이사 비용 예측, 가전기기 수에 따른 전력량 예측 등 모델 종류 Gaussian Processes(GP) 예측값의 신뢰구간 혹은 비신뢰구간을 알 수 있다. 추세를 나타내기에 좋다. 예측(Forecast) 어떤 값을 예측하기 위해서는 기존의 값들을 알아야 한다. 즉 레이블 작업이 필요. 회귀 + 시간 다음달 기름값 가격, 다음달 GPU 가격 등 arima GP SVR ​ 이상값 감지(Anomaly Detection, 비정상값 발견) 특정 패턴 혹은, 유형을 벗어난 값을 감지 ​ 그룹화(Clustering) 주어진 데이터들을 그룹으로 묶기위헤서는 그 특성을 대조하면 된다. 즉 레이블 작업 불필요. 전체 데이터를 주면 특징을 기준으로 그룹해주는 경우 분류와의 차이점 : 분류는 정해진 카테고리 안에서 어디에 속하는지 확인 ​ ​ 강화학습(Reinforcement Learning) 목표 지향 학습을 통해 진행. 특정 케이스에 집중해서 컴퓨터를 학습시키는 경우 ​ ​ ​ ​ ​ ","date":"2022-08-10","objectID":"https://colinder.github.io/machine_learning_classification/:0:0","tags":["ML","Machine_learning "],"title":"Machine_learning type","uri":"https://colinder.github.io/machine_learning_classification/"},{"categories":["fit()","transform()"],"content":"​ ","date":"2022-07-08","objectID":"https://colinder.github.io/why_transform_after_fit/:0:0","tags":["fit()","transform()"],"title":"AI학습 때 왜 .fit() 한 뒤에 train, test data를 .transform()할까?","uri":"https://colinder.github.io/why_transform_after_fit/"},{"categories":["fit()","transform()"],"content":"🤔 왜 .fit() 한 뒤에 train, test data를 .transform()할까? 결론은 .fit()을 통해 학습데이터(train)의 경향을 파악 및 저장하고 이 경향을 train, test data를 적용해 조정해주기 위함입니다. minmaxScaler를 대표로 .fit()한 결과를 출력해보면 .fit()이 어떤 역할을 하는지 알 수 없습니다. 그냥 MinMaxScaler()라는 객체가 할당된 것만 알 수 있습니다. 공식문서를 살펴보면 fit(X, y=None) Compute the minimum and maximum to be used for later scaling. * StandardScale()의 경우 Compute the mean and std to be used for later scaling. 평균과 분산을 저장 ​ 나중에 스케일링할 때 사용할 최대 최소의 값을 계산한다고 합니다. 어떤 동작을 하는지는 알았는데 왜 이런 과정이 필요할까? 왜 train data의 경향을 뽑아 test에 적용할까? ​ ​ 해당 내용은 스케일링 보다 인공지능 학습에 대한 설명일 수도 있습니다. 우리가 인공지능을 통해 알고 싶은 것은 어떤 경향(분포)를 학습한 모델이 특정 input값이 입력되었을 때, 신뢰성 있는 예측값입니다. 이 과정을 세분화해 알아보자면, train_data의 경향(분포)를 학습한 모델 특정 input(test_data)값이 입력 모델이 예측한 결과 도출 ​ AI 모델은 1번 과정을 통해 학습합니다. 예를 들어 train_data가 1~100으로 이루어져 있고 이를 학습했다면, 2번의 특정 input값이 입력되었을 때, 특정 input의 위치는 train_data의 1~100의 경향에 빗대어 보니 어디쯤 이다.는 결과를 도출합니다. 즉, 만약 train_data와 test_data에서 각각 .fit()하여 .transform() 하게 된다면, test_data의 규모만 줄여주며, 이를 train_data에 빗대어 예측할 수 없게 됩니다. ​ 그래서 test_data를 train_data의 분포(경향)을 따르게 .transform() 해준 후 모델 예측(.predict())에 넣어 결과를 보는 것입니다. ​ ​ ​ ​ ​ ​ ​ ​ 추가 사항 \u003e fit_transform() 위의 프로세스대로 스케일링을 진행한다면 train의 경향 추출(.fit()) 2.train의 경향을 train에 반영하는 스케일링 진행(.transform()), train의 경향을 test에 반영하는 스케일링 진행(.transform()) 총 3번의 과정을 거처야 하나, 이를 줄이기 위해 fit_transform()이라는 함수를 통해 1, 2 과정을 한 번에 진행할 수도 있습니다. ​ ​ ​ ​ ","date":"2022-07-08","objectID":"https://colinder.github.io/why_transform_after_fit/:1:0","tags":["fit()","transform()"],"title":"AI학습 때 왜 .fit() 한 뒤에 train, test data를 .transform()할까?","uri":"https://colinder.github.io/why_transform_after_fit/"},{"categories":["scaling"],"content":"​ 데이터 스케일링(Data Scaling) 이란? 데이터의 값의 범위를 조정하는 것 ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:0:0","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"🤔 왜 데이터 스케일링을 하는가? 데이터의 경향, feature의 영향, 상관관계 등 데이터를 분석하는데 활용할 수 있으며, 인공지능 개발 중 학습단계에서 여러 feature의 영향도를 비슷한 수준으로 맞추기 위해 범위를 조정. ​ 아래 그림을 보면서 이해해보겠습니다. ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:1:0","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"과제 여러 feature(성별, 나이, 몸무게, 자산현황)의 특성을 보고 Label을 예측하는 모델을 만든다고 가정 ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:1:1","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"문제점 값의 범위를 보면 성별 0, 1 나이 0~100, 몸무게 0~120, 자산현황 0~700,000,000, Label은 0~800,000,000의 값을 갖는다고 가정한다면, ​ 성별, 나이, 몸무게는 Label를 예측하는데 큰 영향이 없는 형태로 학습될 수 있습니다. 아마도 자산현황이 Label을 예측하는데 가장 큰 영향을 미친다고 판단하며 학습될 것 같습니다. (feature들 간, 값의 규모의 차이가 너무 크기 때문) 또, 데이터의 값이 너무 크거나 혹은 작은 경우에 모델 학습과정에서 0으로 수렴하거나 무한으로 발산할 수 있습니다. ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:1:2","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"결론 feature별 데이터의 규모(scale)이 다르다면, 논리적인 인공지능 학습이 이루어지지 않을 수 있습니다. 따라서, 데이터 스케일링 작업을 통해, 모든 feature의 범위(또는 분포)를 유사하게 만들어 주는 것이 모델 학습에 좋은 영향을 주게 됩니다. ​ ​ ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:1:3","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"🧐 스케일링 방법은 어떤 것들이 있는지? 데이터 스케일링은 데이터 값의 규모를 비슷한 수준으로 맞추어 주는 것입니다. 그리고 비슷한 수준으로 맞추어 주는 방법은 주로 통계적인 기법을 사용해 진행합니다. * scikit-learn에서 제공되는 라이브러리 기준으로 정리 ​ ​ scikit-learn에서는 MinMaxScaler, MaxAbsScaler, StandardScaler, RobustScaler 총 4가지의 스케일링 방법을 제공합니다. MinMaxScaler : 데이터 값을 0 ~ 1 사이로 스케일링 (정규화 Normalization) MaxAbsScaler : 데이터 값을 -1 ~ 1 사이로 스케일링 StandardScaler : 데이터의 평균 = 0, 분산 = 1이 되도록 스케일링 (표준화 Standardization) RobustScaler : 데이터의 중앙값 = 0, IQE = 1이 되도록 스케일링 ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:2:0","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"MinMaxScaler (Normalization) 최대 최소값을 기준으로 스케일링 데이터를 0 ~ 1 사이의 값으로 스케일링. (모든 스케일링은 열 기준으로 적용 ( 성별, 나이, 몸무게, 자산현황 별로 계산 ) 됩니다.) 데이터의 최소값과 최대값을 알 때 사용합니다. 왜냐하면 이상치가 존재할 경우 스케일링 결과가 매우 좁은 범위로 압축될 수 있기 때문입니다. 최대값과 최소값의 차이를 기준으로 설정하기 때문에, 최소값이 매우 작거나, 최대값이 매우 큰 이상치가 있을 때 특이점이 발생할 수 있습니다. 분류보다 회귀에 유용합니다. from sklearn.preprocessing import MinMaxScaler # minmax scaler 선언 및 학습 minmaxScaler = MinMaxScaler().fit(X_train) # train셋 내 feature들에 대하여 minmax scaling 수행 X_train_minmax = minmaxScaler.transform(X_train) # test셋 내 feature들에 대하여 minmax scaling 수행 X_test_minmax = minmaxScaler.transform(X_test) # 스케일링 된 결과 값으로 본래 값을 구할 수도 있다. # X_origin = minmaxScaler.inverse_transform(X_train_minmax) ​ ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:2:1","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"MaxAbsScaler value 절대값 기준, 최대 절대값을 100%로 두고 스케일링 (음수 표현 가능) 데이터가 -1 ~ 1 사이에 위치하도록 스케일링. 절대값의 최소값 = 0, 절대값의 최대값 = 1이 되도록 스케일링 합니다. 데이터의 값이 양수만 존재할 경우 MinMaxScaler와 유사하게 동작합니다. 이상치에 매우 민감합니다. (value의 범위가 큰 쪽에 존재할 경우 매우 민감) from sklearn.preprocessing import MaxAbsScaler # MaxAbsScaler 선언 및 학습 maxabsScaler = MaxAbsScaler().fit(X_train) # train셋 내 feature들에 대하여 maxabs scaling 수행 X_train_maxabs = maxabsScaler.transform(X_train) # test셋 내 feature들에 대하여 maxabs scaling 수행 X_test_maxabs = maxabsScaler.transform(X_test) # 스케일링 된 결과 값으로 본래 값을 구할 수도 있다. # X_origin = maxabsScaler.inverse_transform(X_train_maxabs) ​ ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:2:2","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"StandardScale (Standardization) 정규분포를 따르게 스케일링 데이터의 평균 = 0, 분산 = 1이 되도록, 즉 데이터가 표준 정규 분포(standard normal distribution)를 따르도록 스케일링. (x - x의 평균) / (x의 표준편차) 데이터의 최소값과 최대값을 모를 때 사용합니다. 평균(mean)과 분산(variance)을 사용합니다. 모든 feature들이 같은 스케일을 갖게 됩니다. 평균과 표준편차가 이상치로부터 영향을 많이 받는다는 점에서 이상치에 민감합니다. 회귀보다 분류에 유용합니다. from sklearn.preprocessing import StandardScaler # standard scaler 선언 및 학습 standardScaler = StandardScaler().fit(X_train) # train셋 내 feature들에 대하여 standard scaling 수행 X_train_standard = standardScaler.transform(X_train) # test셋 내 feature들에 대하여 standard scaling 수행 X_test_standard = standardScaler.transform(X_test) # 스케일링 된 결과 값으로 본래 값을 구할 수도 있다. # X_origin = standardScaler.inverse_transform(X_train_standard) ​ ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:2:3","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["scaling"],"content":"RobustScale 데이터의 중앙값 = 0, IQE(사분위값) = 1이 되도록 스케일링 합니다. IQE(사분위값, 1/4, 3/4에 위치한 값) = IQR = Q3 - Q1 : 즉, 25%과 75%의 값 중앙값(median)과 IQR(interquartile range)을 사용합니다. RobustScaler를 사용할 경우 StandardScaler에 비해 스케일링 결과가 더 넓은 범위로 분포합니다. 양수만 가진 데이터의 경우 StandardScaler와 동일한 결과를 도출합니다. 모든 feature들이 같은 스케일을 갖게 됩니다. 이상치의 영향을 최소화(거의 영향을 받지 않음) 합니다. 사분위 값을 사용하기 때문에 양극값은 제외됨. 회귀분석에 조금 더 유용합니다. from sklearn.preprocessing import RobustScaler # RobustScaler 선언 및 학습 robustScaler = RobustScaler().fit(X_train) # train셋 내 feature들에 대하여 robust scaling 수행 X_train_robust = robustScaler.transform(X_train) # test셋 내 feature들에 대하여 robust scaling 수행 X_test_robust = robustScaler.transform(X_test) # 스케일링 된 결과 값으로 본래 값을 구할 수도 있다. # X_origin = robustScaler.inverse_transform(X_train_robust) ​ ​ ​ ​ ","date":"2022-07-07","objectID":"https://colinder.github.io/what_is_data_scaling/:2:4","tags":["scaling"],"title":"What is Data_Scaling","uri":"https://colinder.github.io/what_is_data_scaling/"},{"categories":["AI","tenserflow","train_test_split"],"content":"​ What is ’train_test_split()'? AI 모델링을 위해 X_train, X_test, y_train, y_test로 나누는 작업은 필수적입니다. 저는 train과 test를 나누는 코드를 직접 짜서 사용했었는데 scikit learn에서 제공되는 함수가 있었습니다. “train_test_split()\"이를 알아보겠습니다. ​ ​ 직접 사용되는 모습을 보며 이해해보겠습니다. import numpy as np from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(data, label, test_size=0.3, random_state=29) ​ ​ ","date":"2022-06-30","objectID":"https://colinder.github.io/what_is_train_test_split/:0:0","tags":["AI","tenserflow","train_test_split"],"title":"What is train_test_split()?","uri":"https://colinder.github.io/what_is_train_test_split/"},{"categories":["AI","tenserflow","train_test_split"],"content":"train_test_split() 함수안에 사용되는 인자에 대하여 하나씩 알아보겠습니다. data는 AI에게 학습시킬 문제 리스트입니다. label은 AI에게 학습시킬 문제의 정답 리스트입니다. test_size는 float 또는 int 값을 받습니다. float의 경우 : 0.0 ~ 1.0 사이의 값을 받습니다. 이는 train과 test 세트를 나누기 위한 test 데이터의 비율을 의미합니다. int의 경우 : 모집단의 수에서 몇 개의 데이터를 test 테이터로 설정할 것인지를 의미합니다. 입력하지 않을 수도 있는데 이때는 임의의 비율로 train과 test를 나누어 줍니다. ​ random_state는 해당 함수를 수행할 때마다 동일한 결과를 얻기 위한 나만의 비밀번호 같은 개념입니다. train_test_split(…, test_size=0.3) 과 같은 함수는 train은 70% , test는 30%의 데이터 세트를 추출합니다. 하지만 추출된 데이터는 수행을 할때마다 다를 수 있습니다. random하게 70%, 30%를 추출하기 때문입니다. 가령 1~ 100까지 일련번호로 된 100개의 데이터를 train_test_split(.., test_size=0.3) 로 수행하면 해당 함수를 첫번째 수행할 때는 train은 170, test는 71100이 될 수 있지만, 다시 수행하면 이번에는 train은 31100 , test는 130이 될 수 있습니다. 70%, 30% 로 나누는건 동일하지만 함수를 수행 시마다 추출한 레코드들을 달라질수 있습니다. 내부적으로 70%, 30%로 나눌때 random 함수를 적용하기 때문입니다. random_state=1 이라고 하면 바로 이 random함수의 seed 값을 고정시키기 때문에 여러 번 수행하더라도 같은 레코드를 추출합니다. random함수의 seed값을 random_state라고 생각하시면 됩니다. random_state는 어떤 값으로 설정해도 상관없습니다. 이는 random값을 고정하는 역할만 수행하기 때문입니다. ​ ​ ​ ​ 👀요약 함수는 기존에도 알고 있었지만, 함수가 동작하는 방식을 정확히 알지 못하면 사용하기가 꺼려졌었어서 이참에 조금 알아보았습니다. 그리고 알보던 중 random_state가 어떤 의민지 몰라서 같이 정리해보았습니다. 실은 random_state를 알아보는 것이 이번 포스팅의 핵심이었습니다. ​ ​ ","date":"2022-06-30","objectID":"https://colinder.github.io/what_is_train_test_split/:0:1","tags":["AI","tenserflow","train_test_split"],"title":"What is train_test_split()?","uri":"https://colinder.github.io/what_is_train_test_split/"},{"categories":["react-native"],"content":"​ React-native (android) icon 변경과 splash를 적용해보겠습니다. icon: 핸드폰에서 어플 접속시 보이는 모습을 의미. splash: 어플 실행시 잠시 노출되는 화면을 의미.\r​ ​ ","date":"2022-06-23","objectID":"https://colinder.github.io/react-native_icon_and_splash/:0:0","tags":["react-native","web","icon","splash"],"title":"React-Native_icon_and_splash","uri":"https://colinder.github.io/react-native_icon_and_splash/"},{"categories":["react-native"],"content":"Icon 변경 방법 결론부터 정리하자면 특정 폴더안에 이미지만 넣으면 됩니다. ​ *프로젝트를 시작할 때 이름을 test로 만들어 진행하였습니다. (버전은 0.67) npx react-native init test --version 0.67.0 ​ 1. android/app/src/main/res 까지 폴더를 들어갑니다. 이미지와 같은 구조가 보인다면 잘 접근한 것입니다. 그리고 오른쪽에 범위 잡혀있는 모든 폴더 속의 이미지를 변경하고 싶은 이미지로 바꾸어 넣으면 됩니다. ​ ​ 2 .mipmap-hdpi 기준으로 살펴본다면, ic_launcher_round.png 와 ic_launcher.png 를 내가 원하는 이미지로 변경. ​ ​ 3. 이미지는 변환이 필요한데 1024px x 1024px 이미지로 변환하여 제작. (반드시 해당 사이즈로 해야 하는지는 모르겠습니다.) 한 번에 두 이미지를 만들어 주는 사이트는 찾지 못해 두 개의 사이트를 이용하여 이미지를 제작하였습니다. ic_launcher_round.png 이미지 생성 사이트 ic_launcher.png 생성 사이트 ​ ​ 4. 제작한 두 이미지를 기존의 파일명과 동일하게 변경하고 덮어씌워 넣기 ​ ​ 5. 캐시 초기화 하기 아래 명령어를 통해 캐시를 초기화 합니다. (이유: 환경설정 및 새롭게 추가된 파일을 읽어오는데 문제없게 하기 위함) # root 폴더 위치(package.json이 있는 위치)에서 명령어를 입력합니다. $ cd android # android 폴더로 이동 $ ./gradlew clean # android 폴더 안에 gradlew을 초기화 #이 둘을 묶어서 한 번에 실행하고 싶다면, cd android \u0026\u0026 ./gradlew clean 해준 후 ​ ​ 6. 다시 root 폴더 위치로 이동해 cd .. # android폴더 안에서 상위 폴더로 빠져나오기 ​ ​ 7. 프로젝트를 실행해 변경된 아이콘을 확인 npm run android # 빌드 및 시뮬레이터 실행 실행하면 변환된 Icon 확인 가능. ​ ​ ​ ​ ​ ","date":"2022-06-23","objectID":"https://colinder.github.io/react-native_icon_and_splash/:1:0","tags":["react-native","web","icon","splash"],"title":"React-Native_icon_and_splash","uri":"https://colinder.github.io/react-native_icon_and_splash/"},{"categories":["react-native"],"content":"splash 변경 방법 icon 변경보다는 복잡하지만, 어렵지 않습니다. ​ 1. 관련 라이브러리 설치 스플래시 이미지를 적용하기 위한 라이브러리를 설치합니다. npm i react-native-splash-screen --save ​ ​ 2. 환경 설정하기 android/app/src/main/java/com/test/MainActivity.java 파일을 열어 수정합니다. (중간에 test는 프로젝트 생성할 당시 만든 프로젝트명) package com.test; import android.os.Bundle; // add import com.facebook.react.ReactActivity; // react-native-splash-screen \u003e= 0.3.1 import org.devio.rn.splashscreen.SplashScreen; // here public class MainActivity extends ReactActivity { @Override protected void onCreate(Bundle savedInstanceState) { SplashScreen.show(this); // here super.onCreate(savedInstanceState); } /** * Returns the name of the main component registered from JavaScript. This is used to schedule * rendering of the component. */ @Override protected String getMainComponentName() { return \"test\"; } } 만약에 react-native navigation을 설치한 상태라면, 중간 “@Override” 부분에 코드 중복이 발생하는데 그냥 무시하셔도 됩니다. ​ ​ 3. splash 화면 그리기 android/app/src/main/res에 layout 폴더를 생성합니다. layout 폴더에 launch_screen.xml 라는 이름의 파일을 생성합니다. 방금 만든 launch_screen.xml 파일에 아래 코드를 복사하여 붙여넣어 줍니다. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cRelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:src=\"@drawable/launch_screen\" android:scaleType=\"centerCrop\" /\u003e \u003c/RelativeLayout\u003e ​ ​ 4, 스플래시 이미지 만들기 이미지를 필요한 사이즈 별로 만들어야 합니다. 단 원본 이미지 1장(권장 사이즈 1242px x 2208px)은 있어야 합니다. 가지고 있는 splash 파일에 이름을 launch_screen.png로 변경합니다. https://appicon.co/#image-sets 사이트에 접속 합니다. 접속한 사이트에 이미지를 넣고 Generate 버튼을 눌러 Splash 이미지를 다운로드 합니다. ​ ​ 5. 다운받은 파일을 압축을 해제 후 android/app/src/main/res/ 경로에 파일을 복붙 ​ ​ 6. 캐시 초기화 하기 아래 명령어를 통해 캐시를 초기화 합니다. (이유: 환경설정 및 새롭게 추가된 파일을 읽어오는데 문제없게 하기 위함) # root 폴더 위치(package.json이 있는 위치)에서 명령어를 입력합니다. $ cd android # android 폴더로 이동 $ ./gradlew clean # android 폴더 안에 gradlew을 초기화 #이 둘을 묶어서 한 번에 실행하고 싶다면, cd android \u0026\u0026 ./gradlew clean 여기까지 진행하고 시뮬레이터에 화면을 띄워보면 splash 이미지가 등장은 하나 사라지지 않습니다. 하여 ​ ​ 7. splash 등장 시간 설정 App.js 파일 SplashScreen Import 하고 import React, {useEffect} from 'react'; import {StyleSheet, Text, View} from 'react-native'; import SplashScreen from 'react-native-splash-screen'; // here export default function App() { useEffect(() =\u003e { try { setTimeout(() =\u003e { SplashScreen.hide(); }, 1000); // here 스플래시 노출 시간 1초 } catch (e) { console.log(e.message); } }); return ( \u003cView\u003e \u003cText\u003e스플래쉬 테스트\u003c/Text\u003e \u003c/View\u003e ); } ​ React Native 에뮬레이터를 실행하여 확인합니다. npm run android ​ ​ ​ 이상 react-native에서 icon 및 splash 설정을 알아보았습니다. ​ ​ ","date":"2022-06-23","objectID":"https://colinder.github.io/react-native_icon_and_splash/:2:0","tags":["react-native","web","icon","splash"],"title":"React-Native_icon_and_splash","uri":"https://colinder.github.io/react-native_icon_and_splash/"},{"categories":["web","selenium","crawling"],"content":"​ Selenium 동작대기 접근하려는 요소가 존재하지 않을 때 발생하는 NoSuchElementException error. 페이지와 서버가 통신중이거나 네트워크 지연 등으로 위의 크롤링을 원하는 요소가 html에 존재하기 전에 요소에 접근을 시도하기 때문에 발생하는 에러입니다. 어떤 멋진 코드로 이를 해결할 수 있을까? 고민하였지만 조금 무식한? 방법인 시간 지연으로 이를 해결하였습니다. ​ ​ ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:0:0","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"1. time.sleep python 내장 library 지정한 시간만큼 지연 (프로세스 자체를 지정한 시간동안 기다림) ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:1:0","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"사용법 from time import sleep sleep(3) //3초간 기다림 ​ ​ ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:1:1","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"2. Implicitly Wait (암묵적 대기) Selenium 메서드 크롬드라이버의 동작을 지연시킴 지정한 시간만큼 대기 (브라우저에서 사용되는 엔진 자체에서 파싱되는 시간을 기다림) ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:2:0","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"사용법 from selenium import webdriver driver = webdriver.Chrome('chromedriver.exe') driver.implicitly_wait(10) //10초간 기다림 ​ ​ ​ ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:2:1","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"3. Explicitly Wait (명시적 대기) Selenium 메서드 조건이 True가 될 때 까지 지정한 시간만큼 대기 가장 멋진 방법 같지만, 사용 조건이 조금 까다로운 편. ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:3:0","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":["web","selenium","crawling"],"content":"사용법 from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC browser=webdriver.Chrome('chromedriver') browser.get(\"https://www.naver.com/\") WebDriverWait(driver, 100).until(EC.presence_of_element_located((By.CSS_SELECTOR, \"div.header\"))) //div.header가 나타날때 까지 최대 100초간 기다림. ​ ​ ​ ​ ","date":"2022-05-17","objectID":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/:3:1","tags":["web","selenium","crawling"],"title":"Selenium 동작 대기 방법","uri":"https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/"},{"categories":null,"content":"​ Epoch의 의미 1~100의 데이터가 input의 양(x_train)으로 주어졌을 때 20 epoch를 적용한다는 의미는 단계별로 설명하자면, 1번째 학습(1 epoch) 시작 초기화된 가중치(w)와 편향(b)을 가지고 1에 대한 계산 진행 \u003e 1을 대입하여 나온 가중치(w) 와 편향(b) 도출 2에게 1을 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 3에게 2를 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 … 100에게 99를 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 1 Epoch 학습 종료 2번째 학습(2 epoch) 시작 1 Epoch를 통해 마지막으로 도출된 가중치(w)와 편향(b)을 가지고 다시 1에 대한 계산 진행 1을 대입하여 나온 가중치(w) 와 편향(b) 도출 2에게 1을 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 3에게 2를 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 … 100에게 99를 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출 …반복 ​ 과 같이 1번의 데이터 전체를 학습하고 난 후 도출된 가중치(w)와 편향(b) 계산하는 과정을 Epoch하고 합니다. ​ ​ ​ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/epoch/:0:0","tags":null,"title":"Epoch","uri":"https://colinder.github.io/epoch/"},{"categories":["AI","optimizer"],"content":"​ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_optimizer/:0:0","tags":["AI","optimizer"],"title":"what is optimizer","uri":"https://colinder.github.io/what_is_optimizer/"},{"categories":["AI","optimizer"],"content":"옵티마이저의 목적 옵티마이저는 학습 데이터(Train data)셋을 이용하여 모델을 학습 할 때 데이터의 실제 결과와 모델이 예측한 결과를 기반으로 오차를 잘 줄일 수 있게 만들어주는 역할입니다. ​ 따라서 최적화(Optimization)은 손실 함수(Loss Function)의 결과값을 최소화하는 모델의 파라미터(가중치)를 찾는 것을 의미합니다. ​ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_optimizer/:1:0","tags":["AI","optimizer"],"title":"what is optimizer","uri":"https://colinder.github.io/what_is_optimizer/"},{"categories":["AI","optimizer"],"content":"옵티마이저 리스트 경사 하강법(Gradient Descent) 확률적 경사 하강법(Stochastic Gradient Descent, SGD) Momentum Nesterov Accelerated Gradient (NAG) Adam AdaGrad RMSProp AdaMax Nadam 참고 https://keras.io/api/optimizers/ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_optimizer/:2:0","tags":["AI","optimizer"],"title":"what is optimizer","uri":"https://colinder.github.io/what_is_optimizer/"},{"categories":["AI","optimizer"],"content":"Loss? loss는 손실함수를 의미합니다. 입력 데이터로 부터 도출한 결과(예측값)가 Label값(정답)과 얼마나 일치하는지 평가해주는 함수를 의미합니다. 여기서는 손실함수를 ‘mse’를 사용하겠다는 의미가 됩니다. mse는 평균제곱오차(mean squared error)를 의미합니다. 나중에 자세히 다룰 내용이고 여기서는 그냥 얼마나 예측과 다른지 평가해주는 값이라고 생각하시면 됩니다. 예측값과의 차이를 의미하므로 작으면 작을수록 좋은 모델이라는 의미가 됩니다. ​ optimizer는 손실 함수를 기반으로 네트워크가 어떻게 업데이트될지 결정합니다. 여기서는 adam을 사용하였습니다. 옵티마이저 종류 더 알아보기 -\u003e https://keras.io/ko/optimizers/ ​ ​ ​ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_optimizer/:3:0","tags":["AI","optimizer"],"title":"what is optimizer","uri":"https://colinder.github.io/what_is_optimizer/"},{"categories":["web","linter"],"content":"​ Linter란? Linter 혹은 Lint는 소스 코드를 분석해 오류나 오타, 잠재적인 버그를 찾아주는 도구입니다. javascript는 다른 언어들에 비해 유연한 문법 구조를 갖습니다. 이런 특징은 찾기 어려운 버그를 만들기도하고, 코드를 실행하기 전까지 알 수 없는 오류를 만들기도 합니다. Lint를 사용하면 검증을 자동화하여 이런 문제를 예방할 수 있습니다. 가장 많이 사용되는 javascript 린터로는 ESLint와 코드 포맷터인 Prettier, css 린터인 Stylelint가 있습니다. ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_linter/:0:0","tags":["web","linter"],"title":"what is Linter?","uri":"https://colinder.github.io/what_is_linter/"},{"categories":["web","linter"],"content":"ESLint 2002년 JSON을 만든 더글라스 크락포드가 자바스크립트 린터인 JSLint를 만들었습니다. 이후 니콜라스 자카스가 JSLint의 확장성에 한계를 느껴 더 유연하고 확장이 용이한 ESLint를 만들었습니다. 개발자가 직접 자신의 컨벤션 가이드를 작성할 수 있고, 다른 곳에서 작성한 가이드를 확장하여 사용할 수 도 있게 기존의 문제라고 인식했던 확장성에 많은 변화를 준 Lint입니다. ​ ​ ​ ​ *해당 포스팅은 기초부터 완성까지, 프런트엔드의 내용을 공부하며 기록해 놓은 것입니다. ​ ​ 👀요약 요새 Lint의 설정은 프론트엔드 개발에 필수적인 도구로 자리잡았고, 개인적인 의견으로 컨벤션 규칙을 정하는 것은 협업, 코드 공개 등 다양한 이유에서건 꼭 필요한 작업이라고 느끼고 있어 설정을 추천하고 싶습니다. ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_linter/:1:0","tags":["web","linter"],"title":"what is Linter?","uri":"https://colinder.github.io/what_is_linter/"},{"categories":null,"content":"​ ROC 곡선이란? Receiver operating characteristic 수신기동작특성? 번역하기에 어려운 용어같습니다. 다만 인공지능의 성능을 파악하는데 자주 사용되기 때문에 어떤 개념이고 어떤 의미인지, 어떻게 해석해야 하는지 정리합니다. ROC(Receiver Operating Characteristic) = 모든 임계값에서 분류 모델의 성능을 보여주는 그래프 ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_roc_curve/:0:0","tags":null,"title":"ROC and AUC","uri":"https://colinder.github.io/what_is_roc_curve/"},{"categories":null,"content":"🤔 결론부터 정리하면 주로 분류로 결과를 확인하는 인공지능 성능 평가 방법으로 자주 쓰임. 그래프로 보자면 좌상단(파란 점)에 가까울수록 좋은 성능을 보이는 모델. ​ 또 그래프의 x축, y축을 보면 “FALSE POSITIVE RATE”, “TRUE POSITIVE RATE“라고 적혀 있는데요. 이들은 Confusion matrix라는 분류에 주로 사용되는 검증 방식에 등장하는 내용입니다. 아래의 표를 보면서 계속하겠습니다. 예를 들어 강아지 인가 아닌가? 를 맞추는 모델을 만든다고 가정. 데이터는 강아지와 강아지가 아닌 것이 섞여 있음. 모델 예측값으론 강아지다. 강아지가 아니다.가 있을 것입니다. ​ 여기서 강아지인 데이터를(True Class - Positive) 강아지라고 예측(Predicted Class - Positive)한 것이 있을 것이고, 강아지가 아니라고 예측(Predicted Class - Negative)한 것이 있습니다. 또 강아지가 아닌 데이터를(True Class - Negative) 강아지라고 예측(Predicted Class - Positive)한 것이 있을 것이고, 강아지가 아니라고(Predicted Class - Negative)한 것가 있을 겁니다. 전 이를 맞맞, 맞틀, 틀맞, 틀틀 이라고 말합니다. (저만 이렇게 말합니다.) Confusion matrix에 대한 내용은 다음 글을 참고 하시고, 위의 표를 다시 보면 파란색 네모의 부분을 그래프화 한 값이 ROC입니다. 즉 ROC_cerve는 AUROC값은 0.5 ~ 1 사이의 값을 가집니다. 0.5 이하의 값을 가지도록 하는 임계치는 폐기해야 합니다. 반면 1에 가까울수록 효율적인 판단 임계치이며. 0.7 미만의 경우 차선으로 고려할 수 있는 정도이며, 0.7~0.8은 좋은 정도 0.8 이상은 훌륭한 정도로 봅니다. ​ ​ ​ ​ ","date":"2022-03-18","objectID":"https://colinder.github.io/what_is_roc_curve/:1:0","tags":null,"title":"ROC and AUC","uri":"https://colinder.github.io/what_is_roc_curve/"},{"categories":["ai","loss","Nan"],"content":"​ ","date":"2022-03-17","objectID":"https://colinder.github.io/loss_nan_solution/:0:0","tags":["ai","loss","Nan"],"title":"모델 학습 시 loss가 Nan으로 나올 때 해결법","uri":"https://colinder.github.io/loss_nan_solution/"},{"categories":["ai","loss","Nan"],"content":"모델 학습 시 loss 값이 Nan으로 나올 때 해결 방법 if df == pandas.DataFrame() df.isnull().any()로 데이터셋에 NaN이나 inf 값이 들어있는지 확인한다. 다른 optimizer들을 사용해본다. (ex. sgd, adam, nadam) 다른 activation function을 사용해본다. 사용하는 모델마다 적합한 activation function이 있습니다. 즉. 모델에 대하여 공부해야하고, 적합한 activation function을 찾아 학습해야 합니다. learning rate(학습률)을 낮춰본다. learnin rate는 batch_size와 연관이 있습니다. 러닝레이트 줄이기 vs 배치사이즈 키우기 결과론적으로 배치 사이즈를 키우는 건 러닝 레이트를 줄이는 거랑 동일한 효과를 나타낸다. 출처: https://honeyjamtech.tistory.com/43 [취미생활하는 공대생] Learning rate \u0026 batch size best 조합 찾기 (feat.논문리뷰와 실험결과) 참고 데이터 스케일링(정규화 등)을 한 후 시도 한다. ​ ​ ​ ​ ​ ","date":"2022-03-17","objectID":"https://colinder.github.io/loss_nan_solution/:1:0","tags":["ai","loss","Nan"],"title":"모델 학습 시 loss가 Nan으로 나올 때 해결법","uri":"https://colinder.github.io/loss_nan_solution/"},{"categories":["web","babel"],"content":"​ Babel이란? Babel은 최신 명세(또는 ES2015 이상)의 문법을 구형 브라우저에서도 동작하는 코드로 *트랜스파일해주는 개발 도구입니다. 만약 Babel이 없다면? 구형 브라우저에서 동작할 수 있는 방식으로 웹 개발을 하고, 최신 브라우저에서 동작할 수 있는 방식으로 다시 개발해야 하는 상황이 발생합니다. 즉 구형 브라우저의 지원이 필요한 프런트엔드 프로젝트라면 현재 Babel의 사용은 필수입니다. ​ *트랜스파일러? ES2015 등장 이후로 javascript는 class문법, 화살표 함수, 모듈 도입 등 많은 변화가 있었습니다. 이후에도 동기, 비동기처리를 위한 async \u0026 await, optional 등 다양한 문법과 편의성 높은 기술들이 추가되고 있습니다. 크롬, 사파리, 파이어폭스 등 현대 브라우저들은 이러한 최신 명제를 잘 따라가고 있지만, 브라우저별로 구현율은 다릅니다. 웹 개발의 입장에서 어떤 브라우저에서는 동작하고 어떤 브라우저에서는 동작하지않는 다는 것은 큰 손실이고, 개발에 많은 제약이 됩니다. 즉, 어떤 브라우저에서든 동일한 실행 및 개발 환경을 구축하는 것이 필요합니다. 그리고 이러한 환경을 만들 때 사용되는 것이 트랜스파일러(Transpiler)입니다. 트랜스파일러는 어떠한 언어로 작성된 코드를 비슷한 수준(기능)의 추상화를 가진 언어로 변환하는 역할을 수행합니다. ​ ​ ​ ​ ​ *해당 포스팅은 기초부터 완성까지, 프런트엔드의 내용을 공부하며 기록해 놓은 것입니다. ​ ​ 👀요약 웹 개발을 하면서 Babel을 어떻게 사용하지? 하는 고민은 한 번도 해본 경험이 없습니다. 왜냐하면 어떤 프로젝트를 생성하면 웬만한건 다 알아서 세팅되기 때문입니다. 다만 Babel 이라는 파일이 생겼는데 이건 뭐지? 하는 고민에서 자유로워지고 싶어서 어떤 것이고 어떤 일을 하는 지 알아봤습니다. ​ ​ ​ ​ ","date":"2022-03-15","objectID":"https://colinder.github.io/what_is_babel/:0:0","tags":["web","babel"],"title":"What is Babel?","uri":"https://colinder.github.io/what_is_babel/"},{"categories":["AI","bias","variance"],"content":"​ 편향(Bias)과 분산(Variance) 인공지능 모델링을 하면 정답을 맞추기 위해 컴퓨터는 여러 번의 예측값을 내놓는데, 컴퓨터가 내놓은 예측값의 동태를 묘사하는 표현이 ‘편향’과 ‘분산’입니다. ​ ​ ​ 🤔결론부터 말하자면 예측값들과 정답이 대체로 멀리 떨어져 있으면 편향이 놓다고 말하고, 예측값들이 서로 멀리 흩어져 있으면 분산이 높다고 말합니다. ​ ​ ​ 아래 그림을 보면\r왼쪽 상단 과녁은 예측값들이 대체로 정답 근방에서 왔다갔다 합니다. \u003e 편향이 낮습니다. 예측값들끼리 서로 몰려 있습니다. \u003e 분산이 낮습니다. 오른쪽 상단 과녁은 예측값들이 대체로 정답 근방에서 왔다갔다 합니다. \u003e 편향이 낮습니다. 예측값들끼리 서로 흩어져 있습니다. \u003e 분산이 높습니다. 왼쪽 하단 과녁은 예측값들이 대체로 정답으로부터 멀어져 있습니다. \u003e 편향이 높습니다. 예측값들끼리 서로 몰려 있습니다. \u003e 분산이 낮습니다. 오른쪽 하단 과녁은 예측값들끼리 대체로 정답으로부터 멀어져 있습니다. \u003e 편향이 높습니다. 예측값들끼리 서로 흩어져 있습니다. \u003e 분산이 높습니다. ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:0:0","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"수식으로 표현하면 아래와 같습니다. 수식으로 굳이 알아보는 이유는 정확하게 알기 위함입니다. 너무 핵심만을 전달해 버리면 구체적인 내용을 모를 수도 있고. 이는 ‘안다.‘고 말하기에는 부족하기 때문입니다. ​ X 는 입력된 데이터를 의미합니다. f(x) (붉은 점)는 우리가 맞추고자하는 정답을 의미합니다. f(x)에 ^ 표시가 있는 것(파란 점)은 f hat x 라고 읽습니다. hat은 머리에 쓰는 모자 라는 뜻인데, 수학에서는 ‘특정 값’ 을 지칭할때 사용합니다. 여기서는 컴퓨터가 내놓은 값(예측값)을 의미합니다. E[_](회색 점)는 기대값(expectation)을 의미(평균)합니다. 파란점으로 표시된 f^(x)는 예측값’들’ 이므로, 여러 예측값’들’의 평균을 의미합니다. ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:1:0","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"‘편향’을 수식으로 바꿔보면 붉은점과 회색점의 관계를 나타냅니다.\r​ ​ 보통 위와 같이 계산해서 파악합니다.\r​ 편향이란, 예측값과 정답이 얼마나 차이가 있는가?를 표현합니다. E[f^*(x)] : 예측값들의 평균 입니다. (위 그림에서 회색 점) f(x): 정답값 입니다. (위 그림에서 빨간 점) 둘을 빼면 정답과 예측값이 서로 떨어진 거리를 알 수 있습니다. 그리고 이 거리는, 정답과 예측값들이 서로 얼마나 떨어져 있는지 알려주는 지표가 됩니다. ​ 그런데 f(x)에 제곱이 붙어 있습니다. 왜냐하면, 어떤 예측값은 정답보다 클 것이고, 어떤 예측값은 정답보다 작을 것이기 때문에 두 값 사이의 거리는 양수가 나오기도, 음수가 나오기도 하기 때문입니다. 제곱을 해서 모두 양수를 만들어 주면, 값들을 ‘쌓는 것’이 가능해집니다. 그럼 얼마나 쌓였는지를 나중에 따로 잴 수가 있죠. 꼭 제곱을 사용해야만 하는 것은 아니고, 절대값을 씌워 주는 것도 좋은 방법입니다. 양수를 만들기 위한 목적이니까, 4제곱, 6제곱을 해 주어도 관계없습니다. 다만 그러면 계산이 복잡해지고 무의미하게 커져, 가장 쉬운 방법으로 거리를 재는 수식에서는 제곱을 해 주는 것이 그냥 상식처럼 되었습니다. ​ ​ ​ ‘분산’을 수식으로 바꿔보면 파란점과 회색점의 관계를 나타냅니다.\r​ ​ 수식은 '파랑 점 하나(예측값)' 를 x로 보고 표현한 식입니다.\r​ 파란점과 회색점(파란점의 평균)의 차를 보는데 혹시 음수일 수 있으니, 제곱하고 평균을 내어 분산을 확인합니다. ​ ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:2:0","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"‘편향’과 ‘분산’은, 머신러닝 모델이 ‘복잡하게 생긴 정도’와 큰 관련이 있습니다. ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:0","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"회귀 모델의 경우 세 그래프는, 세 가지의 서로 다른 머신러닝 모델로 같은 데이터를 설명하는 모습입니다. 정답들은 ‘굵은 점’으로 찍혀 있습니다. 모델이 내놓은 예측값은 ‘연속된 작은 점’으로 표현되어 직선 혹은 구불구불한 곡선 보입니다. 이 문제에서는 여러 점들의 경향을 잘 표현하는 모델을 찾는 것이 목적입니다. ​ 첫 번째 그래프를 보면, 데이터들(‘굵은 점’)이 모델의 예측값과(‘연속된 작은 점’) 멀어져 있으므로 편향(bias)이 높고, 모델의 예측값(‘연속된 작은 점’)들 끼리는 별로 떨어져 있지 않게 되므로(왜냐면 같은 직선위의 점들이니까) 분산(variance)은 낮습니다. 세 번째 그래프를 보면, 정답들이 모델과 아주 붙어 있으므로 편향이 낮고, 모델의 예측값들 끼리는 매우 흩어져 있게 되므로(왜냐면 구불구불한 선 위의 점들이니까) 분산이 높습니다. 두 번째 그래프 정도가 적당하다.고 볼 수 있습니다. ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:1","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"분류 모델의 경우 정답들은 빨강 동그라미 혹은 초록 십자가로 찍혀 있고, 모델이 이 둘을 분류(구분)하는 기준(예측선)은 직선 혹은 구불구불한 곡선으로 표현되어 있습니다. 이 문제에서는 빨강 동그라미와 초록 십자가를 잘 구분하는 모델을 찾는 것이 목적입니다. ​ 첫 번째 그래프를 보면, 데이터들이 모델과 멀어져 있으므로 편향(bias)이 높고, 모델이 구분한 기준선은 별로 떨어져 있지 않아(왜냐면 같은 직선위의 점들이니까) 분산(variance)은 낮습니다. 세 번째 그래프를 보면, 정답들이 모델과 아주 붙어 있으므로 편향이 낮고, 모델이 구분한 기준선은 매우 흩어져 있어(왜냐면 구불구불한 선 위의 점들이니까) 분산이 높습니다. 두 번째 그래프 정도가 적당하다 고 볼 수 있습니다. ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:2","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"Underfitting과 Overfitting 회귀 문제이든, 분류 문제이든 첫 번째 그래프와 같은 상황을 Underfitting 세 번째 그래프와 같은 상황을 Overfitting이라고 합니다. 모델이 너무 단순하게 생겼으면(=훈련이 너무 덜 되어 있으면) =\u003e 정답을 잘 내놓지를 못하고 모델이 너무 복잡하게 생겼으면(=훈련이 너무 심하게 되어 있으면), =\u003e 훈련용 데이터에만 너무 최적화 되어 있어, 새로운 문제(데이터)는 틀린 답을 내놓을 가능성이 높습니다. ​ 훈련이 알아서 적당히 잘되면 좋겠지만, 이 부분은 개발자들의 영역입니다. ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:3","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"Model Complexity 편향(Bias)과 분산(Variance)은 한쪽이 증가하면 다른 한쪽이 감소하고, 한쪽이 감소하면 다른 한쪽이 증가하는 경향을 보입니다. “반비례적 관계” 모델이 데이터를 반복 학습하는 횟수가 늘어날수록 \u003e 모델이 복잡한 정도(Model Complexity)도 따라서 늘어나게 되는데, 이것은 훈련용 데이터를 그대로 외우는 방향이기 때문. 따라서 Training Error(loss)는 갈수록 줄어들게 되지만, Validation Error(val_loss)는 어느 정도까지는 줄어들다가, 어느 지점 이후부터는 다시 상승하게 됩니다. 하여 모델을 훈련시키는 도중에 Validation Error가 최소인 지점에서 훈련을 멈추는 것이 필요합니다. ​ ​ ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:4","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["AI","bias","variance"],"content":"해당 내용은 아래의 블로그 내용을 필사하며 정리한 내용입니다. https://opentutorials.org/module/3653/22071 ​ ​ ​ ​ ","date":"2022-03-14","objectID":"https://colinder.github.io/biasvariance/:3:5","tags":["AI","bias","variance"],"title":"편향(Bias) \u0026 분산(Variance)","uri":"https://colinder.github.io/biasvariance/"},{"categories":["web","webpack"],"content":"​ What is webpack? 오늘나 자바스크립트 개발에서 모듈을 사용하여 개발하는 것은 선택이 아닌 필수입니다. 하지만 아직 모든 브라우저(마이크로소프트 - 앳지, 네이버 - 웨일, 구글 - 크롬 등등)가 *ES2015 모듈을 지원하지 않기 때문에 모듈 단위로 패키지를 관리할 수 없습니다. 이런 경우 전역 스코프를 공유하기 때문에 변수명이 충돌하거나 값이 덮어씌워지는 등 문제가 발생할 수 있습니다. 이런 문제를 해결하기 위해 *번들러를 사용하는데 wabpack은 가장 많이 사용되는 번들러 중 하나입니다. *번들러 애플리케이션에 필요한 모든 종류의 파일들을 모듈 단위로 나누어 최소한의 파일 묶음(번들)으로 만들어 낸다. 또한 자바스크립트 파일을 외부에서 알아 보기 힘들게 코드를 변환하는 작업(Uglyfy)을 한다거나, 최신 문법의 자바스크립트를 모든 웹 브라우저에서 작동할 수 있게 ES5문법으로 변환(Transpile)하는 등 다양한 기능을 지원. ​ ​ ​ webpack의 옵션 webpack에는 많은 옵션들이 존재하는데 그 중 일부의 설명과 예시를 정리합니다. webpack은 모든 것을 모듈로 다룹니다. 제 경험상 모듈은 보통 하나만 사용해선 개발이 진행되지 않고, 여러개를 동시에 사용하게 됩니다. 그리고 모듈 간의 의존성에는 시작점이 존재하게 되는데 이를 entry로 설정합니다. ","date":"2022-03-01","objectID":"https://colinder.github.io/what_is_webpack/:0:0","tags":["web","webpack"],"title":"What is webpack?","uri":"https://colinder.github.io/what_is_webpack/"},{"categories":["web","webpack"],"content":"1. entry module.exports = { entry: \"./src/js/main.js\" } 위의 예제 코드의 경우에, src/js 경로에 있는 main.js가 시작점(진입점)이 됩니다. 시작점이 여러개인 경우에는 옵션을 객체나 리스트로 작성할 수 있습니다. module.exports = { entry: { main: \"./src/js/main.js\", acticles: \"./src/js/acticles.js\", } } // or module.exports = { entry: [\"./src/js/main.js\", \"./src/js/acticles.js\"] } ​ ​ ","date":"2022-03-01","objectID":"https://colinder.github.io/what_is_webpack/:0:1","tags":["web","webpack"],"title":"What is webpack?","uri":"https://colinder.github.io/what_is_webpack/"},{"categories":["web","webpack"],"content":"2. Loader webpack은 기본적으로 javaScript와 JSON 파일만을 이해합니다. 이외에 다양한 파일들을 이해하려면 Loader를 사용하면 됩니다. loader는 번들링 과정에서 이미지나 CSS파일과 같은 자원들을 javaScript로 변환 해줍니다. ​ ​ ","date":"2022-03-01","objectID":"https://colinder.github.io/what_is_webpack/:0:2","tags":["web","webpack"],"title":"What is webpack?","uri":"https://colinder.github.io/what_is_webpack/"},{"categories":["web","webpack"],"content":"3. Plugin Loader가 특정 파일을 javaScript로 변환해준다면, Plugin은 조금 더 광범위한 역할을 수행합니다. Plugin은 번들 파일이 생성되는 방식을 수정할 수도 있으며, 환경 변수 주입, 난도화 및 압축과 같은 작업을 수행합니다. ​ ​ ​ ​ *해당 포스팅은 기초부터 완성까지, 프런트엔드의 내용을 공부하며 기록해 놓은 것입니다. ​ ​ 👀요약 이외에서 많은 webpack이 있으나 그것을 전부 알 필요는 없다고 생각합니다. 실제 개발을 하다보면 cmd에서 error : 너 이webpack 없어서 에러났어. 이거 설치하려면 “command command” 입력해 라고 친절히 알려줍니다. 다만 webpack이 무엇인지? 번들이란 무엇인지? 궁금했기에 내용을 정리해봤습니다. ​ ​ ​ ","date":"2022-03-01","objectID":"https://colinder.github.io/what_is_webpack/:0:3","tags":["web","webpack"],"title":"What is webpack?","uri":"https://colinder.github.io/what_is_webpack/"},{"categories":["web","JavaScript","ECMAScript"],"content":"​ What is ES2015? 웹 개발 도구와 내용을 정리하다보면 등장하던 ES2015. 그냥 어떤 느낌의 단어인지 어렴풋이 알고만 있다가 확실하게 정리해 알아두고 싶어 내용을 정리합니다. ​ ​ ​ 우선 javaScript에 대하여 조금 알아봅시다. javaScript는 프로그래밍 언어입니다. 프로그래밍 언어는 지금도 꾸준히 개선되고 발전됩니다. 계속 변화하고 있기에 특정 시기에 개발된 상태를 1.2.1과 같이 버전으로 등록해 배포합니다. 자바스크립트는 결점이 상당히 많은 언어였고, 사용자들이 직접 결점을 보완하는 방법으로 발전되어 왔는데, **ECMA(European Computer Manufacturer’s Association)**라는 단체에서 기존의 결점을 보완한 표준 자바스크립트 버전을 매년 발표하게 됩니다. 그리고 ES는 바로 EcmaScript의 줄임말입니다. 이 표준은 1997년에 처음 제정되어 계속 발전하고 있는 중입니다. ​ ​ ​ ECMAScript(ES)란? ES는 자바스크립트를 이루는 코어(Core)스크립트 언어로써, 다양한 환경에서 운용될 수 있게 확장성을 갖고 있다. 확장성의 대표적인 예로 웹 브라우저에서 javaScript가 동작할 수 있도록 *BOM과 DOM을 함께 사용하는 확장성이 있다. 이러한 확장성들은 ES버전에 따른 문법과 기능의 확장을 가능하게 한다. *BOM(Browser Object Model) javaScript가 browser와 소통하기 위해 만들어진 모델, window 객체를 통해 접근 ​ ​ ES의 버전관리 히스토리는? ES3 -\u003e ES5 -\u003e ES6(ES2015) -\u003e ES7(ES2016)… 넘버링과 년도가 따로있다. 그래서 숫자만 보고 오해할 수 있지만, ES5는 ES2015가 아니다. ​ ​ ​ 👀요약 ES2015에서 엄청나게 많은 문법과 기능(클래스, 모듈, 분해대입, 템플릿 문자열, 블록 스코프, 반복자, 프록시 등등…)이 추가되고, Node.js 등 웹 브라우저 외에도 JavaScript를 구동할 수 있는 구동 환경의 종류가 많아지면서, 다른 범용 프로그래밍 언어(Python …)와 비교해도 전혀 뒤쳐지지 않는 범용 프로그래밍 언어가 되었습니다. ECMAScript 관련하여 최신 변화점은 여기에서 확인할 수 있습니다. ​ ​ ​ ","date":"2022-02-28","objectID":"https://colinder.github.io/what_is_es2015/:0:0","tags":["web","JavaScript","ECMAScript"],"title":"What is ES2015?","uri":"https://colinder.github.io/what_is_es2015/"},{"categories":["web","JavaScript","ECMAScript"],"content":"참고한 글 https://tc39.es/ecma262/ https://www.ecma-international.org/ https://babeljs.io/docs/en/learn/ https://deeds-not-words.tistory.com/entry/ES6-ES2015-ECMAScript%EB%9E%80-%EB%8F%84%EB%8C%80%EC%B2%B4-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80 https://www.zerocho.com/category/ECMAScript/post/5756d488e9c105aaeb550ea5 ​ ​ ​ ​ ","date":"2022-02-28","objectID":"https://colinder.github.io/what_is_es2015/:0:1","tags":["web","JavaScript","ECMAScript"],"title":"What is ES2015?","uri":"https://colinder.github.io/what_is_es2015/"},{"categories":["web","Web Socket"],"content":"​ What is Web Socket? Web 통신은 무조건 두 단계를 걸쳐 동작합니다. 요청과 응답. 간단히 어떤 요청이 있을 때만 서버와 연결되어 어떤 응답을 하게 됩니다. 이러한 방식을 HTTP라고 합니다. 예를 들어, Naver.com에 접속하는 것은 ‘Naver.com’이라는 요청을 보낸 것이고 그에 대한 응답으로 naver의 메인 화면을 보여주는 것이죠. 그런데 만약 실시간 채팅 서비스나 푸시 알람을 구현해야 한다면, 매우 잦은 요청을 보내야 하고 네트워크 상 많은 부하를 발생시킬 수 있습니다. HTML5이라는 웹 표준이 생긴이래로 이러한 HTTP의 단점을 보완하기 위해 웹 소켓(Web Socket)이 등장했습니다. 웹 소켓은 서버와 사용자 간 연결을 유지한 상태로 추가 요청없이 양방향으로 데이터를 교환할 수 있는 프로토콜입니다. 이런 특성은 실시간으로 데이터 교환이 지속해서 일어냐야 하는 서비스에서 유용합니다. ​ ​ ","date":"2022-02-25","objectID":"https://colinder.github.io/what_is_web_socket/:0:0","tags":["web","Web Socket"],"title":"What is Web Socket?","uri":"https://colinder.github.io/what_is_web_socket/"},{"categories":["web","Web Socket"],"content":"Web Socket 사용법 웹 소켓 연결을 만들 때는 Websocket 생성자를 이용합니다. 이때 매개변수 url에서 사용하는 프로토콜은 ws와 wss입니다. 둘의 관계는 http와 https와의 관계와 비슷하며 상대적으로 wss가 보안과 신회성이 더 높은 프로토콜입니다. const socket = new WebSocket(\"wss://something_URL.com\") 웹 소켓의 핸드쉐이크(handshake) 과정은 HTTP를 이용합니다. HTTP는 반드시 1.1버전 이상이어야 하며 GET method를 이용해 요청을 보냅니다. 핸드쉐이크 과정을 간략하게 정리하면 아래와 같습니다. 브라우저에서 서버로 웹 소켓 지원여부를 물어봅니다. 이때 아래 코드와 같이 Connection 헤더와 Upgrade 헤더의 값을 설정합니다. 이 값의 의미는 클라이언트 측에서 프로토콜을 웹 소켓 프로토콜로 변경하고 싶다는 의미 GET /chat HTTP/1.1 Host: something_URL.com Upgrade: websocket Connection: Upgrade ... 서버에서 웹 소켓 지원 여부를 반환. 서버, 브라우저 모두 웹 소켓을 지원한다면 연결. ​ ​ ","date":"2022-02-25","objectID":"https://colinder.github.io/what_is_web_socket/:1:0","tags":["web","Web Socket"],"title":"What is Web Socket?","uri":"https://colinder.github.io/what_is_web_socket/"},{"categories":["web","Web Socket"],"content":"Web Socket 상태 확인 생성된 웹 소켓 객체는 XMLHttpRequest로 생성된 객체처럼 상태를 나타내는 readyState가 존재합니다. 각각의 상태를 상수 혹은 숫자로 구분하여 사용할 수 있습니다. 상수 값 설명 CONNECTING 0 연결이 수립되고 있는 상태 OPEN 1 연결이 완료된 상태 CLOSE 2 연결이 종료되고 있는 상태 CLOSED 3 연결이 종료된 상태 ​ ​ ","date":"2022-02-25","objectID":"https://colinder.github.io/what_is_web_socket/:2:0","tags":["web","Web Socket"],"title":"What is Web Socket?","uri":"https://colinder.github.io/what_is_web_socket/"},{"categories":["web","Web Socket"],"content":"Web Socket 접근법 각 프로퍼티와 상태 상수에 접근하는 방법 const socket = new WebSocket(\"wss://something_URL.com\"); console.log(socket.readyState, Websocket.CONNECTING); 웹 소켓이 정상적으로 생성되면 4개의 이벤트를 사용할 수 있습니다. 각각의 이벤트는 on(eventName)혹은 addEventListener()를 통해 등록할 수 있습니다. open: readyState가 OPEN 되었을 때, 즉 데이터를 주고 받을 준비가 되었을 때 발생 close: readyState가 CLOSED가 되었을 때, 즉, 연결이 종료되었을 때 발생 message: 서버로부터 메시지를 받았을 때 발생. 이때 이벤트 객체를 통해 수신된 메세지에 접근할 수 있음. error: 에러가 발생했을 때 발생 const socket = new WebSocket(\"wss://something_URL.com\"); socket.addEventListener('open', () =\u003e { console.log('연결 완료') }) socket.addEventListener('message', (event) =\u003e { console.log('메세지 수신', event,data) }) ​ ​ ","date":"2022-02-25","objectID":"https://colinder.github.io/what_is_web_socket/:3:0","tags":["web","Web Socket"],"title":"What is Web Socket?","uri":"https://colinder.github.io/what_is_web_socket/"},{"categories":["web","Web Socket"],"content":"Web Socket 현황 웹 소켓은 HTTP의 요청과 응답의 한계를 넘어선 새로운 프로토콜이지만, 실제 도입시에는 아직 고려해야할 사항들이 많다고 합니다. 구형 브라우저에 대한 지원, 주고 받는 데이터의 크기와 빈도, 에러 처리, 부하 등. 이러한 사항들을 서비스로 제공하기 충분한지 파악하고 도입하는 것을 추천합니다. ​ *해당 포스팅은 기초부터 완성까지, 프런트엔드의 내용을 공부하며 기록해 놓은 것입니다. ​ ​ 👀요약 현재 진행중인 프로젝트에도 웹 소켓을 적용하여 개발중인데 추가로 redis와 함께 사용하고 있습니다. 이제 슬슬 AI 개발에 집중하기 위해 손을 놓고 있는데 재미있는 기술들이 계속 도입되고 있어, 이래저리 정신없는 상태에서 정리된 글이라 더 깊이 있는 내용은 기회가 되면 추가해보겠습니다. ​ ​ ​ ","date":"2022-02-25","objectID":"https://colinder.github.io/what_is_web_socket/:4:0","tags":["web","Web Socket"],"title":"What is Web Socket?","uri":"https://colinder.github.io/what_is_web_socket/"},{"categories":["web","storage","local","session"],"content":"​ Local Storage와 Session Storage의 차이 를 알아보기 전에 ​ ​ ","date":"2022-02-23","objectID":"https://colinder.github.io/localvssession_storage/:0:0","tags":["web","storage","local","session","면접대비"],"title":"localStorage vs sessionStorage","uri":"https://colinder.github.io/localvssession_storage/"},{"categories":["web","storage","local","session"],"content":"‘Storage(web storage)‘란 무엇인지 우선 알아봅시다. HTML5에서 등장한 웹의 데이터를 클라이언트에 저장할 수 있는 기능 인터넷상의 통신을 하는데 어떤 자료를 가지고 있어야 한다거나, 나의 정보(유저정보)를 관리하는 등의 데이터 관리를 위한 저장소 기능. 그리고 storage는 두 가지 종류가 존재 ​ ​ ","date":"2022-02-23","objectID":"https://colinder.github.io/localvssession_storage/:1:0","tags":["web","storage","local","session","면접대비"],"title":"localStorage vs sessionStorage","uri":"https://colinder.github.io/localvssession_storage/"},{"categories":["web","storage","local","session"],"content":"Local Storage와 Session Storage Local storage origin(요청이 시작된 서버를 나타내는 URL)이 같을 경우, 여러 탭과 브라우저 창에서 공유되는 저장소. Session(클라이언트와 웹 서버간에 통신 연결에서 두 개체의 활성화된 접속)이 종료된 이후에도 지속(유지)되는 저장소로 설계되어 컴퓨터를 종료하거나 브라우저를 종료하더라도 저장되어있던 데이터는 사라지지 않고 지속하여 보관한다. ​ Session storage 브라우저의 한 탭에서 페이지의 세션이 유지되는 동안 origin별로 storage를 관리하는 저장소. 페이지가 열려 있는 동안이나, 페이지 reloading 혹은 복원 시에는 데이터가 유지되지만, 다른 session이나 탭창이 종료될 경우, 데이터에 접근할 수 없다. 하여 Local storage보다 제한적으로 사용된다. ​ ​ ","date":"2022-02-23","objectID":"https://colinder.github.io/localvssession_storage/:2:0","tags":["web","storage","local","session","면접대비"],"title":"localStorage vs sessionStorage","uri":"https://colinder.github.io/localvssession_storage/"},{"categories":["web","storage","local","session"],"content":"공통점(특징) Object와 비슷한 key-value의 구조 ex) {‘username’: ‘imdeveloper’, ‘age’: ‘imold’} 모든 key와 value는 String으로 저장 ​ ​ ","date":"2022-02-23","objectID":"https://colinder.github.io/localvssession_storage/:3:0","tags":["web","storage","local","session","면접대비"],"title":"localStorage vs sessionStorage","uri":"https://colinder.github.io/localvssession_storage/"},{"categories":["web","storage","local","session"],"content":"간단한 사용법 // Local Storage // 1 .Local Storage에 정보 저장하기 - setItem() localStorage.setItem(\"name\", \"value\") // 2. Local Storage에서 정보 가져오기 - getItem() localStorage.getItem(\"name\") // Session Storage // 1. Session Storage에 정보 저장하기 - setItem() sessionStorage.setItem(\"name\", \"value\") // 2. Session Storage에서 정보 가져오기 - getItem() sessionStorage.getItem(\"name\") ​ ​ ​ ​ ","date":"2022-02-23","objectID":"https://colinder.github.io/localvssession_storage/:4:0","tags":["web","storage","local","session","면접대비"],"title":"localStorage vs sessionStorage","uri":"https://colinder.github.io/localvssession_storage/"},{"categories":["file list import","pandas"],"content":"​ 폴더 안에 있는 특정 파일 리스트 정리 어떤 폴더 안에 있는 특정 확장자명의 파일들의 리스트를 정리하고 싶을 때 사용합니다. ​ ## 폴더안에 있는 .csv파일 리스트 가져오기 import os path = '/경로/' file_lists = os.listdir(path) file_list_result = [file for file in file_lists if file.endswith('.csv')] ## 파일명 끝이 .csv인 경우 ​ 이후 pandas DataFrame에 넣을 때 import pandas as pd df = pd.DataFrame() for i in file_list_result: data = pd.read_csv(path + i) df = pd.concat([df,data]) ​ ​ ​ ​ ","date":"2022-02-22","objectID":"https://colinder.github.io/filelistimport/:0:0","tags":["file list import","pandas"],"title":"폴더안에 있는 특정 파일 리스트 가져오기","uri":"https://colinder.github.io/filelistimport/"},{"categories":["Machine","Deep","learning"],"content":"​ ","date":"2022-02-22","objectID":"https://colinder.github.io/machinedeep/:0:0","tags":["Machine","Deep","learning"],"title":"Machine VS Deep Learning","uri":"https://colinder.github.io/machinedeep/"},{"categories":["Machine","Deep","learning"],"content":"‘머신러닝’이란 무엇인지 우선 알아봅시다. 머신 러닝(machine learning) 또는 기계 학습(機械學習)은 경험을 통해 자동으로 개선하는 컴퓨터 알고리즘 연구 분야입니다. 이는 인공지능의 한 분야로 간주되며, 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발합니다. 예를 들어 ‘이 운동화가 진품이 맞는지?’, ‘특정 시간대에 A에서 B까지 가는데 얼마나 시간이 걸리는지?’, ‘수신한 메일이 스팸메일인지?’ 등 표현(representation)과 일반화(generalization)가 핵심인 기술입니다. 표현이란 데이터의 평가이며, 일반화란 아직 알 수 없는 데이터의 처리를 의미합니다. 인공지능 ⊃ 머신러닝 ⊃ 딥러닝\r","date":"2022-02-22","objectID":"https://colinder.github.io/machinedeep/:1:0","tags":["Machine","Deep","learning"],"title":"Machine VS Deep Learning","uri":"https://colinder.github.io/machinedeep/"},{"categories":["RNN","LSTM","Activation Function"],"content":"​ RNN \u0026 LSTM 감정분석을 위한 프로젝트를 기획하면서 RNN과 LSTM이라는 신경망 분석에 대하여 알게 되었습니다. 신경망 분석은 기계학습과 인지과학에서 영감을 얻어 설계된 통계학적 학습 알고리즘인데요. 이 둘의 개념를 알아보겠습니다. ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:0:0","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"RNN(Recurrent Neural Network) 순환 신경망 시퀀스(Sequence)라는 것이 있습니다. 시퀀스는 간단히 ‘문맥이 있는 데이터’ 입니다. 문장은 단어들의 시퀀스, 음악은 음계들의 시퀀스, 동영상은 이미지의 시퀀스라고 할 수 있습니다. 그런데 시퀀스의 길이는 가변적입니다. 기존의 뉴럴 네트워크 알고리즘은 이미지처럼 고정된 크기의 입력을 다루는 데는 탁월하지만, 가변적인 크기의 데이터를 모델링하기에는 적합하지 않았습니다. 그리고 이런 시퀀스 테이터를 처리하기 위해 고안된 모델을 시퀀스 모델이라고 하고, 그 중에서도 RNN은 Deep Learning에 있어 가장 기본적인 모델입니다. RNN이 기존의 뉴럴 네트워크와 다른 점은 ‘기억’(다른 말로 hidden state[은닉층])을 갖고 있다는 점입니다. 새로운 입력이 들어올때마다 네트워크는 자신의 기억을 조금씩 수정합니다. 결국 입력을 모두 처리하고 난 후 네트워크에게 남겨진 기억(hidden state)은 시퀀스 전체를 요약하는 정보가 됩니다. 이 과정은 새로운 단어마다 계속해서 반복되기 때문에 RNN에는 Recurrent, 즉 순환적이라는 이름이 붙었으며, 이런 반복을 통해 긴 시퀀스를 처리할 수 있는 것입니다. 아직 이해가 어렵습니다. 동작하는 모습을 보며, 더 알아보겠습니다. RNN은 입력(input)을 받아 출력(Output)를 만들고, 이 출력을 다시 입력으로 받습니다. 일반적으로 RNN을 그림으로 나타낼 때는 위의 그림처럼 하나로 나타내지 않고, 아래의 그림처럼 각 타임 스텝(time step) t마다 순환 뉴런을 펼쳐서 타임스텝 별 입력과 출력을 나타냅니다. ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:1:0","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"RNN 학습 방법 RNN은 순환 구조이므로 hidden state(layer)의 데이터를 저장하고 있습니다. 일반적인 인공신경망과 비슷하게 Gradient Descent와 backpropagation을 이용해 학습을 하는데, 시간의 흐름에 따른 작업이기 때문에 backpropagation을 확장한 BPTT(Back-Propagation Through Time, 역전파)을 사용해서 학습을 합니다. *Gradient Descent(경사 하강법) : 최적해를 구하는 알고리즘. 기본 개념은 함수의 기울기를 구하고 경사의 절대값이 낮은 쪽으로 계속 이동시켜 극값에 이를 때 까지 반복시키는 것. 즉, RNN은 스스로를 반복하면서 과거 자신의 정보(가중치)를 기억하고 이를 학습에 반영합니다. ​ 🤔다만, RNN이 시간을 거슬러 올라가면서 학습을 하는데 과거로 올라가면 올라갈수록 gradient값이 계산이 잘 되지 않습니다. 그리고 Vanishing Gradients Problem이 발생합니다. gradient는 곱연산으로 이루어져 있는데, 미분값 즉 변화량이 매우 작다면, 데이터를 효과적으로 학습시키지 못하고, error rate가 미쳐 다 낮아지지 못한채 수렴해버리는 문제가 발생합니다. 간단히, 길이가 긴 Sequence data 의미를 잘 파악하지 못하며, 짧은 Sequence 데이터만 의미있는 학습이 진행됩니다. == 기억력이 좋지 못한 모델 ​ 그리고 이를 해결하기 위해 LSTM이 등장했습니다. ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:2:0","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"LSTM(Long Short-Term Memory) 장,단기 메모리 잠깐 RNN의 동작원리를 다시 살펴보면, 아래와 같습니다. 위 그림은 싱글 레이어(단일 tanh 레이어)를 가지고 반복되는 simple RNN 모듈을 표현하고 있습니다. 그럼 LSTM네트워크는 어떻게 생겼을까요? Cell의 내부는 RNN에 비해 복잡한 구조를 가지고 있습니다. 차근히 알아보겠습니다. ​ 위의 그림에서 이 (cell) state / 이 hidden state입니다. Cell state (cell) state는 컨베이어 벨트 처럼 담겨있는 정보(state)를 계속 흐르게 하는 부분입니다. (cell) state에는 뭔가를 더하거나 없앨 수 있는데 이는 gate라는 곳에서 제어됩니다. Hidden state hidden state는 ‘이전 출력물(previous output)‘입니다. RNN에서 확인했던 출력을 다시 입력으로 받는 부분입니다. ​ LSTM의 내부에는 ‘3가지 gate’와 ‘1번의 업데이트’가 진행됩니다. 망각게이트(forget gate) : 장기기억에서 필요없는 정보를 삭제하는 게이트 입력게이트(input gate) : 장기기억에 저장할 정보를 입력하는 게이트 Update : forget gate에서 삭제할 정보를, input gate에서 저장할 정보를 결정했고 이를 더해주는 단계 출력게이트(output gate) : 다음 시점으로 전달할 state(단기상태)를 결정하는 게이트 ​ 단계별로 확인해보겠습니다. ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:3:0","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"1. 망각게이트(Forget gate) [이전 output, 현재 input]를 종합해 cell state으로 전달되는 ‘어떤 값’을 계산합니다. / 다만 이 계산의 활성함수가 σ(시그모이드)로 진행되기 때문에 전달되는 값은 ‘0 ~ 1’이 됩니다. ​ \u003e ‘0’일 경우, 이전의 cell state값은 모두 ‘0’이 되어 미래의 결과에 아무런 영향을 주지 않음 ​ \u003e ‘1’일 경우, 미래의 예측 결과에 영향을 주도록 이전의 cell state 값(Ct-1)을 그대로 보내 완전히 유지함 즉, Forget Gate는 [현재 입력과 이전 출력]을 고려해서, cell state의 어떤 값을 버릴지/지워버릴지(‘0’이 출력되면 날려버림) 결정하는 역할을 합니다. ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:3:1","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"2. 입력게이트(Input gate) input gate는 현재 정보를 기억하기 위한 게이트입니다. forget gate와 동일하게 [이전 output, 현재 input]를 종합해 라는 필터를 만들고 을 cell state에 얼마나 등록할지 결정하는 부분입니다. ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:3:2","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"3. Update Update는 지난 두 과정[forget gate, input gate]을 통해 cell state에 반영하는 과정입니다. ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:3:3","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"4. 출력게이트(Output gate == hidden state) 최종적으로 cell state에 반영된 값을 얼마나 출력할지? 결정하는 구간입니다. ​ ​ ​ ​ ​ 👀요약 딥러닝에 있어 가장 기본적인 모델이라는 RNN과 LSTM에 대하여 정리하였습니다. 기술을 사용하는 것은 이론을 학습하는 것보단 난이도가 낮다는 평가가 지배적입니다. 즉 그냥 가져다 쓸 수는 있지만, 개념적으로 어떤 분석이 되고 어떤 학습이 되는지 이해하고 사용하는 것과 아닌 것과는 분명 차이가 있을 것입니다. 간단하게라도 어떤 프로세스로 진행되는 지 알아보면 좋을 것 같습니다. ​ ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:3:4","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["RNN","LSTM","Activation Function"],"content":"참고 했던 글 https://www.jksmer.or.kr/articles/xml/x2eO/ https://dreamgonfly.github.io/blog/understanding-rnn/ https://brunch.co.kr/@gdhan/2 https://ratsgo.github.io/natural%20language%20processing/2017/03/09/rnnlstm/ https://m.blog.naver.com/PostView.nhn?blogId=magnking\u0026logNo=221311273459\u0026proxyReferer=https:%2F%2Fwww.google.com%2F https://www.edwith.org/deeplearningchoi/lecture/15840?isDesc=false http://colah.github.io/posts/2015-08-Understanding-LSTMs/ https://excelsior-cjh.tistory.com/183 ​ ​ ​ ​ ","date":"2022-02-21","objectID":"https://colinder.github.io/rnnlstm/:4:0","tags":["RNN","LSTM","Activation Function"],"title":"RNN \u0026 LSTM","uri":"https://colinder.github.io/rnnlstm/"},{"categories":["typescript","vue"],"content":"​ vue typescript_$refs error Object is possibly ‘undefined’ Property ‘value’ does not exist on type ‘Vue | Element | (Vue | Element)[]’. Property ‘value’ does not exist on type ‘Vue’ typescript를 적용한 vue에서 $refs 값을 가져와 사용하는데 위와 같은 문제가 발생했습니다. ​ ","date":"2022-02-16","objectID":"https://colinder.github.io/refs_error/:0:0","tags":["web","vue","typescript"],"title":"typescript Refs_error","uri":"https://colinder.github.io/refs_error/"},{"categories":["typescript","vue"],"content":"에러가 나오는 이유 개발자가 보기에는 너무 당연히 데이터가 있지만, 객체가 비어 있을 수도 있는데 해당 객체의 내부 메소드를 사용하거나 내부 객체 키에 값을 넣어주려고 할 때 발생합니다. const refs = this.$refs.image //👈 여기서 에러 발생 const name = refs.value.name ​ 옵셔널체이닝, if문으로 undefined 거르기 등을 시도해 보았지만, 오류가 계속 되었고 타입 단언 사용으로 해결하였습니다. // eslint-disable-next-line const refs = this.$refs.image as any //👈 const name = refs.value.name any 타입으로 지정해주며 깔끔히 무시해버리기. ​ ​ 관련해 자료를 찾아보니 별로 권장되는 방법은 아닌 것 같습니다. 다만, 저는 옵셔널 체이닝과 if문으로 걸리지지 않았기 때문에 적용해 보았고 해결이 되어 그냥 진행하기로 하였습니다. ​ ","date":"2022-02-16","objectID":"https://colinder.github.io/refs_error/:1:0","tags":["web","vue","typescript"],"title":"typescript Refs_error","uri":"https://colinder.github.io/refs_error/"},{"categories":["typescript","vue"],"content":"🤔선택적으로 적용해보세요. 아마, 옵셔널체이닝이 가장 권장되는 방법이 아닐까 예측해봅니다. ​ ​ ","date":"2022-02-16","objectID":"https://colinder.github.io/refs_error/:2:0","tags":["web","vue","typescript"],"title":"typescript Refs_error","uri":"https://colinder.github.io/refs_error/"},{"categories":["analysis","boxplot"],"content":"​ What is Boxplot? 데이터 분석을 진행하면서 다른 분들의 분석 레퍼런스를 보며 공부하다보니 많은 분들이 boxplot을 사용하는 것을 보았습니다. 다만, 저는 그 박스가 어떤 경우에 사용하는 것인지? 어떤 의미로 그려지는 것인지? 어떻게 해석하면 좋은지? 개념이 약했기 때문에 내용을 정리해보겠습니다. ​ ​ ","date":"2021-12-23","objectID":"https://colinder.github.io/boxplot/:0:0","tags":["analysis","boxplot"],"title":"boxplot 해석 방법","uri":"https://colinder.github.io/boxplot/"},{"categories":["analysis","boxplot"],"content":"Box Plot 최댓값, 최솟값, 중앙값, 사분편차를 사용하여 자료의 측정값들이 어떤 모양으로 분포되어 있으며, 극단값들은 어떠한지 등을 쉽게 알 수 있도록 하는 그림이다. 자료들이 비대칭으로 분포되어 있을 경우에는 상자그림을 그려 극단값의 개수, 비대칭 여부 등을 파악할 수 있으므로 측정값들의 중심위치와 산포도의 척도로 사용할 수 있다. 출처 : [네이버 지식백과] 상자그림 [box plot, box and whisker plot] (교육평가용어사전, 2004. 5. 31., 한국교육평가학회) 👉 박스로 표현한 데이터에 4분위 값들의 분포와 특이값을 표현한 그림 ​ ​ ","date":"2021-12-23","objectID":"https://colinder.github.io/boxplot/:1:0","tags":["analysis","boxplot"],"title":"boxplot 해석 방법","uri":"https://colinder.github.io/boxplot/"},{"categories":["analysis","boxplot"],"content":"어떤 경우에 Box Plot을 사용할까? 데이터 분포에 관한 정보를 얻고 싶을 때 사용. ​ ​ ​ ","date":"2021-12-23","objectID":"https://colinder.github.io/boxplot/:2:0","tags":["analysis","boxplot"],"title":"boxplot 해석 방법","uri":"https://colinder.github.io/boxplot/"},{"categories":["analysis","boxplot"],"content":"Box Plot은 어떻게 해석해야 하는가? ​ ​ 사분위수? 자료를 크기 순으로 배열하고, 누적 백분율을 4 등분한 각 점에 해당하는 값을 말한다. 제1사분위수는 누적 백분율이 25%에 해당하는 점수이고, 제2사분위수는 누적 백분율이 50%, 제3사분위수는 75%, 제4사분위수는 100%에 해당하는 점수이다. 특히 제2사분위수는 누적 백분율이 50%이므로 개념적으로 중앙값과 동일하다. 출처: [네이버 지식백과] 사분위수 [quartile] (교육평가용어사전, 2004. 5. 31., 한국교육평가학회) ​ ​ 중앙값? 자료를 크기 순서대로 배열했을 때, 중앙에 위치하게 되는 값이다. 중앙값을 기준으로 자료의 반은 중앙값보다 큰 값을 갖고, 나머지 반은 중앙값보다 작은 값을 갖는다. 자료가 (4, 5, 7, 8, 10)으로 구성되어 있다면, 7보다 작은 값이 2개, 7보다 큰 값이 2개 있으므로 7이 중앙값이 된다. 자료가 (1, 3, 5, 7, 8, 9)와 같이 짝수로 구성되어 있는 경우, 가운데 있는 두 값인 5와 7의 평균으로 중앙값이 결정된다. 자료에 중복된 값이 있는 경우 중앙값 계산은 복잡해지며, 이 경우는 누적 백분율이 50%인 점을 계산하는 공식을 활용하여 중앙값을 산출할 수 있다. 출처: [네이버 지식백과] 중앙값 [median] (교육평가용어사전, 2004. 5. 31., 한국교육평가학회) ​ ​ ​ ","date":"2021-12-23","objectID":"https://colinder.github.io/boxplot/:3:0","tags":["analysis","boxplot"],"title":"boxplot 해석 방법","uri":"https://colinder.github.io/boxplot/"},{"categories":["Django","JWT"],"content":"​ Django JWT(Json Web Token) Django의 대표적인 jwt 패키지는 djangorestframework-jwt, djangorestframework-simplejwt가 있지만 전자는 업데이트가 더이상 진행되지 않아서 후자를 사용하는 것을 추천합니다. ​ ","date":"2021-12-22","objectID":"https://colinder.github.io/django_11_simple_jwt/:0:0","tags":["Django","JWT"],"title":"Django_11_simple_JWT","uri":"https://colinder.github.io/django_11_simple_jwt/"},{"categories":["Django","JWT"],"content":"djangorestframework-simplejwt 간단한 사용법 정리 def Usage(request): ## SIMPLEJWT METHOD TEST # print(\"================================\") # a = JWTAuthentication() # b = a.get_header(request) # print(b) # print(\"================================\") # raw_token = a.get_raw_token(b) # print(raw_token) # print(\"================================\") # d = a.get_validated_token(raw_token) # print('유효한가', d) # print(\"================================\") # auth = a.authenticate(request) # print(auth) # print(auth[0]) # print(\"=================================\") # # print(auth[1]) # epoch_time = 1637654588 # date_time = datetime.fromtimestamp( epoch_time ) # print(\"Given epoch time:\", epoch_time) # print(\"Converted Datetime:\", date_time ) # ts= (datetime.now() - datetime(1970,1,1)).total_seconds() # print('현재시간 에포크로 변환', round(ts)) return JsonResponse({'detail': 'ok', \"messages\": {\"message\": \"true\"}}, status=200) ​ ​ ​ ​ ​ ","date":"2021-12-22","objectID":"https://colinder.github.io/django_11_simple_jwt/:1:0","tags":["Django","JWT"],"title":"Django_11_simple_JWT","uri":"https://colinder.github.io/django_11_simple_jwt/"},{"categories":["Numpy","Pandas"],"content":"​ Numpy ML, AI 등 개발을 진행하다보면 무지성으로 import하는 library가 있다. import numpy as np python만 할 줄 안다면 어렵지 않게 사용이 가능하지만, 그래도 numpy의 개념을 알고 진행하고 싶은 마음에 내용을 정리해보자 ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:0:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"What is Numpy(Numerical Python)? 공식문서를 따르면, NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. NumPy는 python의 과학 컴퓨팅(scientific computing)을 위한 기본 패키지 scientific computing: 과학 및 공학 문제의 수학적 모델을 컴퓨터로 푸는 데 필요한 도구, 기술 및 이론의 모음 ‘다차원 배열’ 여기서 ‘파생되는 객체’ 및 ‘수학’, ‘논리’, ‘기본 선형대수’ 등을 지원하는 python library ​ At the core of the NumPy package, is the ndarray object. This encapsulates n-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. Numpy의 핵심은 ndarray 객체이며, 이는 코드의 빠른 처리를 위해 동일 데이터 타입의 n차원 배열을 캡슐화한다. == 하나의 데이터 타입만 배열에 넣을 수 있다. ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:1:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"특징 일반 리스트에 비해 빠르고 효율적 반복문 없이 데이터 배열에 대한 처리 지원 선형대수와 관련된 다양한 기능을 제공 Scalar, Vector, Matrix, Tensor 형태의 데이터를 다루기 좋음. numpy에서 제공하는 데이터 형태 ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:1:1","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Scalar ? Scalar는 0차원 데이터 ​ ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:2:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Vector ? Vector는 1차원 데이터 ​ \u003e\u003e\u003e import numpy as np \u003e\u003e\u003e a = np.array([1, 2, 3]) 다음과 같이 배열을 시각화할 수 있습니다. 여기서 잠깐! ✋ d는 5행 1열이 맞습니다. 다만 출력된 화면은 1행 5열로 보입니다. e는 2행 5열이 맞습니다. 출력된 화면대로 이해하면 됩니다. ​ ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:3:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Matrix ? Matrix는 2차원(행, 열) 데이터 ​ ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:4:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Tensor ? Tensor는 3차원 이상의 다차원 행렬 데이터 ​ ​ ​ ​ 👉추가로 Numpy와 비슷하지만 사용법 및 용도가 다른 Library 하나를 더 정리해보자 Pandas import pandas as pd 역시 무지성으로 입력하고 시작하게 되는 코드이다. pandas의 용도는 무엇인지? numpy와의 차이는 무엇인지 알아보자 ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:5:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"What is Pandas(Python data analysis)? [pandas](https://pandas.pydata.org/docs/#module-pandas) is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language. 겸손한 pandas 공식문서 설명이다. 하여 추가로 Wikipedia의 내용을 조금 더 보면 pandas is a software library written for the Python programming language for data manipulation and analysis. In particular, it offers data structures and operations for manipulating numerical tables and time series. 특히 숫자 테이블과 시계열을 조작하기 위한 데이터 구조 와 연산을 제공하며 이에 특화된 library. 역시 제공하는 데이터 형태를 알면 좋은데, Series, DataFrame 두 가지가 대표적. ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:6:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Series 1차원 형태의 데이터, numpy array 와 유사 차이점 - numpy 와 달리 Series 는 axis (행, 열)에 label 을 부여할 수 있다. 즉, numpy 와 같이 숫자로만 indexing 하는 것이 아니라 label 명으로 indexing 을 할 수 있다. 또한 숫자 뿐 아니라 임의의 Python object 를 모두 element 로 가질 수 있다. list, numpy array, dictionary 를 모두 Series 로 변환할 수 있다. dictionary 의 경우 “key\"가 label, “value\"가 value로 변환된다. ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:7:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"DataFrame 2차원(table) 형태의 데이터 python program 안의 excel. DataFrame 은 여러개의 Series 를 같은 index 기준으로 모아 Table 을 만든 것. ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:8:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["Numpy","Pandas"],"content":"Series \u0026 DataFrame의 관계 구조적인 관계 ​ Index관점의 Pandas 구조 ​ ​ ​ ​ ","date":"2021-12-15","objectID":"https://colinder.github.io/numpypandas/:9:0","tags":["Numpy","Pandas"],"title":"Numpy \u0026 Pandas","uri":"https://colinder.github.io/numpypandas/"},{"categories":["mariaDB"],"content":"​ MariaDB 외부 접속 허용 해당 MariaDB 공유는 root PC에서 진행하는 것이며, 외부에서 접속할 client는 별도로 설정할 건 없습니다. 또한 무조건 이 방법이 맞다!라기보다는 제가 이렇게 하니 외부 접속이 되었다. 는 경험의 기록입니다. ​ MySQL Client를 실행합니다. ​ 실행하면 아래와 같은 초기 화면에 진입합니다. ​ MariaDB 설치를 진행하면서 등록한 password입력하면 아래와 같은 화면이 나옵니다. ​ 초기 접속의 경우, DB table이 ’none’으로 설정되어 있는데, **공유를 원하는 table로 설정을 바꿔줍니다. ** \u003e use 사용할DB ​ 이제 접속을 허용할 PC 정보(ip)와 권한에 대하여 명령어를 입력합니다. \u003e grant all privileges on *.* to ‘아이디’@‘접속허용할PC의IP’ identified by ‘비밀번호’; ","date":"2021-11-03","objectID":"https://colinder.github.io/mariadb_share/:0:0","tags":["mariaDB"],"title":"MariaDB 외부접속 허용","uri":"https://colinder.github.io/mariadb_share/"},{"categories":["mariaDB"],"content":"이제 client에서 DB로 접속이 가능합니다. 😊 ​ 마지막으로 설정한 내용이 잘 반영되어있는지 확인하기 위해 등록된 user계정을 확인해보겠습니다. \u003e SELECT Host,User,plugin,authentication_string FROM mysql.user; 이상으로 MariaDB 외부 접속 허용을 위한 설정을 완료하였습니다. ​ ​ 생각보다 외부 접속 허용이 간단했습니다. 혹시 제가 문제가 있는 방법으로 진행한 것이라면 피드백 부탁드립니다!! ​ ​ ​ ","date":"2021-11-03","objectID":"https://colinder.github.io/mariadb_share/:0:1","tags":["mariaDB"],"title":"MariaDB 외부접속 허용","uri":"https://colinder.github.io/mariadb_share/"},{"categories":["Django","AbstractUser"],"content":"​ Django AbstractUser 이전에 AbstractBaseUser를 사용한 커스텀 사용자 인증 테이블을 구성해보았습니다. 해당 내용에 이어서 AbstractUser로 커스텀 사용자 인증 테이블을 구성해보고 createsuperuser 명령어 입력시, 관리자 계정이 커스텀한 테이블에 생성되게 해보겠습니다. ​ ","date":"2021-10-08","objectID":"https://colinder.github.io/django_10_customauthuser_abstractuser/:0:0","tags":["Django","AbstractUser"],"title":"Django_10_CustomAuthUser_AbstractUser","uri":"https://colinder.github.io/django_10_customauthuser_abstractuser/"},{"categories":["Django","AbstractUser"],"content":"AbstractUser을 상속받아 커스텀을 진행 우선 AbstractUser는 Django에서 기본으로 제공해주는 사용자 인증 테이블의 요소를 그대로 가져와 사용하기 때문에 그 요소들은 어떤 것들이 있는지 알아보자. id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined 총 11개의 column이 존재하며 이외에 column을 추가 하고 싶을 때 코드를 추가로 작성합니다. 전 이전에 AbstractBaseUser의 경우와 같이, 추가로 nickname을 필수로 등록받는 것으로 시작하여 createsuperuser했을 때, myabuser 테이블에 nickname을 필수로 입력받는 관리자 계정이 생기도록 진행해보겠습니다. ​ 아래 정리는 이전에 AbstractUser관련 테스트를 진행한 후에 내용입니다. 즉, 프로젝트를 만들고, accounts라는 앱을 만들고, settings.py에 AUTH_USER_MODEL=‘accounts/myabuser’를 등록한 후 진행합니다. ​ 🤔 소스 코드를 작성해보려는데 궁금증이 생겼습니다. AbstractUser도 BaseUserManager가 필요한가? 소스코드로 확인해보겠습니다. # accounts/models.py from django.db import models from django.contrib.auth.models import AbstractUser # Create your models here. class MyAbUser(AbstractUser): nickname = models.CharField(max_length=100, default=None) 까지만 설정하고 # Terminal에 명령어 입력 \u003e python manage.py makemigrations \u003e python manage.py migrate DB를 확인해보니 nickname column이 생겼고 이제, # Terminal에 관리자 계정 생성을 시도 \u003e python manage.py createsuperuser 했더니 제가 원했던 email, nickname, password를 받는 것이 아닌 default로 createsuperuser를 했을 때 입력받는 항목들이 나왔습니다. 즉, AbstractBaseUser를 사용하든지 AbstractUser을 사용하든지 간에, 최소한 커스텀된 관리자 계정을 생성하기 위해서는 BaseUserManager가 필요하다는 것을 알았습니다. ​ createsuperuser를 했을 때 email, nickname, password만 기록한 관리자 계정을 만들 수 있는가? 우선 BaseUserManager를 추가한 소스코드 # accounts/models.py from django.db import models from django.contrib.auth.models import AbstractUser, BaseUserManager # Create your models here. class MyUserManager(BaseUserManager): def create_user(self, email, nickname, password=None): if not email: raise ValueError('Users must have an email address') user = self.model( email=self.normalize_email(email), nickname=nickname ) user.set_password(password) user.save(using=self._db) return user def create_superuser(self, email, nickname, password): user = self.create_user( email, password=password, nickname=nickname, ) user.is_admin = True user.save(using=self._db) return user class MyAbUser(AbstractUser): nickname = models.CharField(max_length=100, default=None) objects = MyUserManager() REQUIRED_FIELDS = ['nickname'] 모델에 변경사항이 있는 것은 아니니 makemigrations \u0026 migrate는 하지 않습니다. 이후에 # Terminal에 관리자 계정 생성을 시도 \u003e python manage.py createsuperuser 하였지만, REQUIRED_FIELDS에 등록된 nickname을 추가로 받긴 하지만, 아직 email을 필수로 받지 않고, Username이 고윳값(PK)로 설정되어 있는 것 같습니다. ​ 그렇다면, 고윳값(PK)를 변경할 수 있는 USERNAME_FIELD를 설정하고 # accounts/models.py class MyAbUser(AbstractUser): nickname = models.CharField(max_length=100, default=None) objects = MyUserManager() USERNAME_FIELD = 'email' #👈 REQUIRED_FIELDS = ['nickname'] createsuperuser를 해보겠습니다. # Terminal에 관리자 계정 생성을 시도 \u003e python manage.py createsuperuser 하지만, 오류가 납니다. email을 unique하게 세팅해야 한다는 말 같아서 email의 필드설정을 해보겠습니다. # accounts/models.py class MyAbUser(AbstractUser): email = models.EmailField( #👈 verbose_name='email addresss', #👈 max_length=255, unique=True, #👈 default=None, ) nickname = models.CharField(max_length=100, default=None) objects = MyUserManager() USERNAME_FIELD = 'email' REQUIRED_FIELDS = ['nickname'] 이제 됩니다. 제가 작성한 코드가 동작하는지 확인하려 일부로 오기재한 ’email addresss’으로 입력을 받고, 제가 원하던 모습인 email, nickname, password만 입력을 받으며 관리자 계정이 생성되었습니다. ​ DB를 확인해보니 ​ AbstractUser를 상속받아 커스텀한 사용자 인증 항목 중, Default로 설정되는 값인 is_superuser, is_staff, is_active, date_joinnd를 제외한 email, nickname, password가 입력된 값으로 반영된 것을 확인하였습니다. ​ 아마, is_superuser와 date_joined는 필수값이 아니기 때문에 강제로 기록하고 싶지 않다면 방법이 있을 것입니다. 다만 이번에 알아보지는 않겠습니다. ​ 이렇게 AbstractUser의 기본적인 사용법을 알아보았습니다. ​ AbstractBaseUser와 AbstractUser의 차이를 알아보았고 코드와 DB의 모습까지 살펴보았습니다. 이 둘의 차이와 장,단점을 이해하는데 많은 도움이 되었으면 합니다. ​ ​ ​ ​ ","date":"2021-10-08","objectID":"https://colinder.github.io/django_10_customauthuser_abstractuser/:1:0","tags":["Django","AbstractUser"],"title":"Django_10_CustomAuthUser_AbstractUser","uri":"https://colinder.github.io/django_10_customauthuser_abstractuser/"},{"categories":["Django","AbstractBaseUser"],"content":"​ Django AbstractBaseUser django는 기본적으로 username 과 password를 가지고 로그인합니다. 하지만 요즘에는 대부분의 웹사이트들이 email 과 password로 로그인(사용자를 인식 및 인증)을 합니다. ​ 제가 진행할 것은 django의 AbstractBaseUser을 사용해 테이블을 만들고 사용자 인증하기 입니다. 조건 email, password, nickname 및 필수 요소(is_active, is_admin)로만 인증 테이블 구성. createsuperuser 명령어 입력시, 관리자 계정이 커스텀한 테이블에 생성. ​ Django 공식문서에는 models.py에서 기본적인 사용자모델을 설정하고 이를 활용해 admin.py에서 관리자모델을 만드는 예제가 있어 이를 따라하며 약간의 수정을 더해 진행해보려 합니다. ​ ","date":"2021-10-08","objectID":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/:0:0","tags":["Django","AbstractBaseUser"],"title":"Django_09_CustomAuthUser_AbstractBaseUser","uri":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/"},{"categories":["Django","AbstractBaseUser"],"content":"먼저 AbstractBaseUser를 상속받아 커스텀을 진행 django의 예제에는 AbstractBaseUser라는 클래스를 상속받은 모델을 제작하는데, Abstract(추상적인)Base(기초)User(사용자)의 틀을 가져와 이를 활용해 내 입맛대로 커스텀 하는 과정. 또한, 계정관련 모델을 만드는 경우에는 항상 두가지를 생각해야 합니다. 일반사용자, 관리자 AbstractBaseUser를 사용하면 로그인 방식도 변경할 수 있고(내마음대로 구성), 원하는 필드들로 유저 모델을 구성할 수 있습니다. 아래는 email, password를 활용하여 로그인하고 추가적으로 nickname을 가지는 유저 모델을 구현해보겠습니다. 이 때 BaseUserManager를 상속하는 UserManager를 함께 정의하여 일반 유저 및 슈퍼유저의 생성 방식을 정의해줘야 합니다. (또 PermissionsMixin 을 함께 상속하면 Django의 기본그룹, 허가권 관리 등을 사용할 수 있습니다. 하지만 여기서는 사용하지 않겠습니다.) ​ ","date":"2021-10-08","objectID":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/:1:0","tags":["Django","AbstractBaseUser"],"title":"Django_09_CustomAuthUser_AbstractBaseUser","uri":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/"},{"categories":["Django","AbstractBaseUser"],"content":"BaseUserManager를 상속받는 UserManager 정의 BaseUserManager 클래스는 유저를 생성할 때 사용하는 헬퍼(helper) 클래스이며, 실제 모델(model)에 반영되는 것은 AbstractBaseUser을 상속받아 생성하는 클래스가 될 것입니다. 아래의 코드는 크게 두가지 class를 선언해 사용하고 있고, 동작의 흐름은,아래 class(MyUser) → 위 class(MyUserManager) 순서로 동작합니다. 소스 코드 # accounts/models.py from django.db import models from django.contrib.auth.models import AbstractBaseUser, BaseUserManager class MyUserManager(BaseUserManager): def create_user(self, email, nickname, password=None): if not email: raise ValueError('Users must have an email address') user = self.model( email=self.normalize_email(email), nickname=nickname ) user.set_password(password) user.save(using=self._db) return user def create_superuser(self, email, nickname, password): user = self.create_user( email, password=password, nickname=nickname, ) user.is_admin = True user.save(using=self._db) return user class MyUser(AbstractBaseUser): email = models.EmailField( verbose_name='email addresss', max_length=255, unique=True, ) nickname = models.CharField(max_length=100, default = None) is_active = models.BooleanField(default=True) is_admin = models.BooleanField(default=False) objects = MyUserManager() USERNAME_FIELD = 'email' REQUIRED_FIELDS = ['nickname',] @property def is_staff(self): return self.is_admin ​ 설명이 있는 소스코드(위와 동일한 코드이나 자세한 설명이 있습니다.) # accounts/models.py from django.db import models from django.contrib.auth.models import AbstractBaseUser, BaseUserManager # 위에서 설명한 일반 유저 및 슈퍼유저의 생성 방식을 정의할 BaseUserManager를 상속받는 # 나만의 사용자 매니저 모델을 생성합니다. 필수입니다. class MyUserManager(BaseUserManager): def create_user(self, email, nickname, password=None): # 만약 email을 입력하지 않으면 바로 에러를 뱉습니다. if not email: raise ValueError('Users must have an email address') user = self.model( email=self.normalize_email(email), nickname=nickname ) # 비밀번호는 암호화(set_password)함수를 사용해 변수에 저장합니다. user.set_password(password) # 등록된 사용자 정보를 DB에 저장합니다. user.save(using=self._db) # 마지막으로 사용자 정보를 return합니다. return user # python manage.py createsuperuser 명령어 입력시 = 관리자 계정 생성시 def create_superuser(self, email, nickname, password): user = self.create_user( email, password=password, nickname=nickname, ) user.is_admin = True user.save(using=self._db) return user class MyUser(AbstractBaseUser): # DB에 저장할 column들을 설정합니다. # 저는 email, nickname을 설정하겠습니다. # password는 필수값이기에 설정하지 않아도 입력받습니다. email = models.EmailField( verbose_name='email addresss', max_length=255, unique=True, ) nickname = models.CharField(max_length=100, default = None) # 사용자 인증에 사용될 계정을 등록할 때 is_active와 is_admin도 필수값이기 때문에 # 반드시 지정해주어야 합니다. (안하면 오류를 뱉습니다.) is_active = models.BooleanField(default=True) is_admin = models.BooleanField(default=False) # 테이블을 생성하면 last_login 컬럼도 생성되는데 models.~~을 설정해주지 않으면 NULL값으로 입력됩니다. # 위에서 생성한 일반 유저 및 슈퍼유저의 생성 방식을 정의할 나만의 사용자 매니저 모델을 가져옵니다. objects = MyUserManager() # unique한 값으로 설정할 것을 주로 USERNAME_FIELD로 설정합니다. # 저는 email의 중복을 허용하지 않고 이를 식별값(PK) 사용하겠습니다.(필수) USERNAME_FIELD = 'email' # createsuperuser 시 USERNAME_FIELD와 password 말고 추가로 받아야 하는 인자를 기재. # 상기 프로젝트의 경우 email, nickname, password를 받아야 하니 # 기본으로 받는 인자인 USERNAME_FIELD = 'email'과 password 말고 나머지 요소를 기재 REQUIRED_FIELDS = ['nickname',] # 이 아래는 선택사항입니다. def has_perm(self, perm, obj=None): \"Does the user have a specific permission?\" # Simplest possible answer: Yes, always return True def has_module_perms(self, app_label): \"Does the user have permissions to view the app `app_label`?\" # Simplest possible answer: Yes, always return True @property def is_staff(self): \"Is the user a member of staff?\" # Simplest possible answer: All admins are staff return self.is_admin 해당 사항을 정리하면서 필수라고 기재된 내용은 커스텀 사용자 인증 테이블을 만들 최소한의 필수 요소입니다. ​ 이후 MyUser를 settings.py에 등록. # setting.py 아무곳에나 ex) '앱이름.클래스명' AUTH_USER_MODEL = 'accounts.MyUser' ... ​ 이제 Terminal에 관리자 생성 명령어 입력.. 잠깐! 제가 만든 코드들이 동작하는지 알기 위해서 의도한 실수 표기법인 “Email addresss\"라는 input 메시지를 볼 수 있습니다. ​ 이제 DB를 확인하는데 제가 만든 accounts앱의 myuser 테이블에 생성되었는지 확인합니다. 또 django 기본 사용자 인증 테이블인 auth_user에 생기지 않았는지도 확인합니다. 의도한대로 관리자 계정이 생긴것을 확인하였고 AbstractBaseUser의 기본","date":"2021-10-08","objectID":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/:2:0","tags":["Django","AbstractBaseUser"],"title":"Django_09_CustomAuthUser_AbstractBaseUser","uri":"https://colinder.github.io/django_09_customauthuser_abstractbaseuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"​ Django AbstractBaseUser VS AbstractUser Django로 프로젝트를 진행하면서 계정관련 내용을 등록하는 것을 가장 많이 했음에도, 아직 명확하게 차이를 알지 못하고 사용했던 것이 있었습니다. 바로! User custom에 관한 부분이었는데요. 크게 AbstractBaseUser와 AbstractUser를 사용하는 방법이 있는데 이 둘의 차이를 꼼꼼히 알아보기 위해 해당 포스팅이 작성되었습니다. ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:0:0","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"AbstractBaseUser VS AbstractUser 프로젝트 생성 후 accounts 라는 app을 만들고 makemigrations \u0026 migrate를 하기 전 ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:1:0","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"1. Model 설정 AbstractBaseUser 위치: accounts/models.py MyUser라는 커스텀 table을 만들고 python manage.py runserver를 하게되면, 일단 오류없이 동작하는 것을 확인할 수 있습니다. 다만, 아직 변경사항을 DB에 반영하지 않았음으로 DB에 생성된 table의 모습은 확인할 수 없습니다. ​ AbstractUser 위치: accounts/models.py MyAbUser라는 커스텀 table을 만들고 python manage.py runserver를 하게되면, 아래와 같은 오류를 만나게 됩니다. 해당 오류는 Django 공식문서에 해결방법이 있다. 하여 settings.py 에 AUTH_USER_MODEL = ‘accounts.MyAbUser’를 추가 하였으나, 그럼에도 의존성(Dependency) 오류가 발생한다. 이를 해결하기위해 검색해보니 이제 makemigrations \u0026 migrate를 진행해야 한다고 확인했습니다. ​ 초기 설정만 진행되었지만 일단, AbstractBaseUser는 makemigrations \u0026 migrate없이 models.py에 등록만해도 오류없이 서버구동이 가능하나, AbstractUser는 불가능하였습니다. ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:1:1","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"2. makemigrations \u0026 migrate 진행 후 \u003e python manage.py makemigrations \u003e python manage.py migrate ​ AbstractBaseUser 오류 없이 동작되었으며, DB에 아래와 같이 12개의 테이블이 생겼고, 커스텀한 accounts_myuser 테이블에 3개의 column이 기본으로 생기는 것을 확인했습니다. ​ AbstractUser 우선 makemigrations \u0026 migrate을 진행하고 나니 python manage.py runserver가 오류 없이 동작되었습니다. DB를 확인해보면, 아래와 같이 커스텀한 accounts_myabuser테이블을 포함한 11개의 테이블이 생겼습니다. 생성된 column들은 django에서 default로 user를 생성하면 만들어지는 항목입니다. ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:1:2","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"3. AbstractBaseUser VS AbstractUser 비교 생성된 DB모습의 차이는 아래와 같고 대응되는 table들을 연결해 보았습니다. 간단히 AbstractBaseUser를 사용하면 auth_user가 상대적으로 하나 더 생성된다는 차이가 있습니다. 그런데 그 안의 요소는 아래와 같습니다. AbstractUser 클래스를 상속받아 custom한 accounts_myabuser의 항복들과 동일했고, 이는 Django에서 기본으로 제공하는 인증에 사용되는 계정관련 테이블의 항목들입니다. ​ 즉, 테이블 별 column 항목을 기준으로 대응해보면 이것이 맞는 표현이 됩니다. 간단히 AbstractBaseUser를 사용하면, Django default DB Table 외에 사용자 인증에 사용할(커스텀할) 테이블(accounts_myuser)를 추가로 만들고, AbstractUser를 사용하면, django default DB Table 중 인증에 사용되는 user table 자체를 커스텀해 사용한다는 차이가 있다. ​ 🤔돌이켜 생각해보면 AbstractUser의 경우 setting.py에 AUTH_USER_MODEL = ‘accounts.MyAbUser’를 추가해주는 행위가 이러한 차이를 유발하는 코드임을 알 수 있습니다. 이로인해 다른 설명들에 나와있는 표현인 “AbstractUser는 무겁기(django의 default 사용자 인증 column들을 그대로 사용하기 때문) 때문에 AbstractBaseUser를 사용한다.“가 이해됬으면 합니다. ​ ​ ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:1:3","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["Django","AbstractBaseUser","AbstractUser"],"content":"그.리.고! 내가 AbstractBaseUser를 상속받아 커스텀하여 만든 table을 사용자 인증을 하는데 사용하고 싶다면, settings.py에서 AUTH_USER_MODEL = 'accounts.테이블이름'로 지정해줘야 합니다! 결과적으로 인증에 사용할 테이블은 settings.py에 AUTH_USER_MODEL = “앱이름.테이블” 형태로 등록해주어 설정한다. 는 점을 이해하면 좋겠습니다. ​ ​ ​ ","date":"2021-10-07","objectID":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/:1:4","tags":["Django","AbstractBaseUser","AbstractUser"],"title":"Django_08_AbstractBaseUser VS AbstractUser","uri":"https://colinder.github.io/django_08_abstractbaseuservsabstractuser/"},{"categories":["mariaDB"],"content":"​ MariaDB 설치 방법 ","date":"2021-09-15","objectID":"https://colinder.github.io/mariadb_setting/:0:0","tags":["mariaDB"],"title":"MariaDB 설치 방법","uri":"https://colinder.github.io/mariadb_setting/"},{"categories":["mariaDB"],"content":"1. 설치 https://mariadb.org/download/ 에서 자동으로 확인된 버전으로 다운로드 받습니다. ​ Next 클릭\r​ 별도의 커스텀은 하지 않습니다.\r​ ‘root 비밀번호 설정’과 ‘UTF 변환 및 외부에서 root 접속을 허용 할 것’인지 물어보는 데 이곳이 중요합니다. 단순 개발용이라면 상관없을 수 있으나 개인적으로 실제 운용할 서버 or 개발 서버라도 외부에서 root에 접속하게 하는 것은 보안상 좋지 않을 것이라고 생각합니다. 실제로 서비스를 운영 할 서버라면 절때 root를 원격지에서 사용할 수 없게 하는 것을 추천합니다. root의 비밀번호를 등록하고, UTF-8 설정은 체크하겠습니다. (나중에 변경할 수 있습니다.) 이렇게 Next 하겠습니다.\r​ Database 서버에 접속할 port와 서비스 이름을 설정하는 곳입니다. (혹시 Maria DB 설치전에 Mysql 서버가 설지되있는 경우에는 3306 port로 지정했을 때 충돌이 날 수 있으니 Maria DB의 port를 바꾸어사용하는 것을 추천합니다.) ​ Install 클릭하면 설치가 마무리됩니다.\r​ ​ ","date":"2021-09-15","objectID":"https://colinder.github.io/mariadb_setting/:1:0","tags":["mariaDB"],"title":"MariaDB 설치 방법","uri":"https://colinder.github.io/mariadb_setting/"},{"categories":["mariaDB"],"content":"2. DB setting 정상적으로 설치가 되었다면 배경화면에서 해당 아이콘을 발견할 수 있습니다. (실행)\r​ 실행 초기 화면\r​ 왼쪽 하단에 \"⊕신규\" 클릭 후 화면\r​ 설치하면서 등록했던 root의 비밀번호를 입력 후 하단에 '열기'를 클릭합니다.\r​ 이제 새로운 DB table이 생성되었고 개발하는 프로그램과 연결하여 사용할 준비가 끝났습니다.\r​ ​ ​ ","date":"2021-09-15","objectID":"https://colinder.github.io/mariadb_setting/:2:0","tags":["mariaDB"],"title":"MariaDB 설치 방법","uri":"https://colinder.github.io/mariadb_setting/"},{"categories":["Django","1:N"],"content":"​ Django 1:N 불러오기 prefetch_related() or annotate() ​ models.py 구성 class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE, related_name='choices') choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) ​ ​ ","date":"2021-09-14","objectID":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/:0:0","tags":["Django","1:N"],"title":"Django_07_1:N 불러오기","uri":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/"},{"categories":["Django","1:N"],"content":"prefetch_related() # views.py def get_context_data(): context[\"questions\"] = Question.objects.prefetch_related('choices') return context # templates/.html {% for question in questions %} \u003cb\u003e{{ question.question_text }}\u003c/b\u003e \u003cul\u003e {% for choice in question.choices.all %} \u003cli\u003e{{ choice.choice_text }}\u003c/li\u003e {% endfor %} \u003c/ul\u003e {% endfor %} # Choice 모델에서 related_name을 지정하지 않았을 경우에는 템플릿 쪽에서 question.choice_set.all 을 사용하면 된다. ​ ​ ","date":"2021-09-14","objectID":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/:0:1","tags":["Django","1:N"],"title":"Django_07_1:N 불러오기","uri":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/"},{"categories":["Django","1:N"],"content":"annotate() def get_context_data(): question_data_with_choices = Question.objects.annotate(choice_id=F('choices__id'), choice_text=F('choices__choice_text'), votes=F('choices__votes')).annotate(Count('id)) ​ ​ ​ ​ ","date":"2021-09-14","objectID":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/:0:2","tags":["Django","1:N"],"title":"Django_07_1:N 불러오기","uri":"https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/"},{"categories":["Django","Oracle"],"content":"​ Django \u0026 Oracle 18 오류 일지 각종 스트레스의 원인에 대하여 해결방법을 정리합니다. ​ ORA-00955: name is already used by an existing object # 해결법 python manage.py makemigrations python manage.py migrate --fake-initial 이미 migrate 한 내용을 수정하니 반영되지 않아 오류가 발생하였는데 위의 명령어는 migratie를 초기화해서 재설정 하는 것 같습니다. ​ 그리고 많은 경우에 python manage.py migrate --fake \u003cappName\u003e zero python manage.py migrate \u003cappName\u003e Django의 app별 migrate 초기화 명령 이게 많은 도움이 됩니다. ​ ​ ​ Javascript 이슈사항 정리 각종 javascript 스트레스 원인에 대하여 해결방법을 정리. ​ object type에 dict 추가하기 foo['tracker'] = bar // from this... foo.tracker = bar; // to this!!!! ​ localstorage는 string 타입만 담을 수 있다. 하여 보통 응답으로 JSON 타입을 반환해주지만 이를 string으로 변환하여 localstorega에 담는데 이를 위해 JSON.stringify(담을 데이터) 의 형태로 저장한다. ​ ​ ​ Django 이슈사항 정리 각종 django 스트레스 원인에 대하여 해결방법을 정리 authenticate(조건) 와 model.objects.get(조건)의 출력값은 동일 A = authenticate(username=username, password=old_password) B = MyAuthUser.objects.get(username=username) print(type(A)) # \u003cclass 'accounts.models.MyAuthUser'\u003e print(type(B)) # \u003cclass 'accounts.models.MyAuthUser'\u003e A == B # True ​ .catch(error =\u003e { console.log(error.response.data) } \u003e catch는 이렇게 받으면 JsonResponse로 보낸 것을 확인할 수 있다. ​ ​ ​ ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/django_06_djangooracle18_error_log/:0:0","tags":["Django","Oracle"],"title":"Django_06_Django \u0026 Oracle18 error LOG","uri":"https://colinder.github.io/django_06_djangooracle18_error_log/"},{"categories":["Django"],"content":"​ Django DB 연결 확인 ​ python manage.py createsuperuser 후.. default로 생기는 DB를 기준으로 실행 ​ ## setting.py AUTH_USER_MODEL = 'auth.User' # default 설정. ​ 이후 terminal에서 $ python manage.py shell_plus # 모델에 접근하기 위해 shell_plus 실행 \u003e Post = get_user_model() # 생성된 모델의 user table 불러오기 \u003e post = Post.objects.all() # user table의 모든 값 가져오기 \u003e for i in post: # for문으로 user table값 순환 \u003e print(i) # user table 값 출력 하면 연결된 모델의 값을 확인할 수 있다. ​ ​ ​ ​ ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/django_05_check-db-connection/:0:0","tags":["Django"],"title":"Django_05_Check DB connection","uri":"https://colinder.github.io/django_05_check-db-connection/"},{"categories":["Link"],"content":"​ 정적(Static) 링크 Vs 동적(Dynamic) 링크 ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/staticvsdynamic_link/:0:0","tags":["Link"],"title":"정적(Static) 링크 Vs 동적(Dynamic) 링크","uri":"https://colinder.github.io/staticvsdynamic_link/"},{"categories":["Link"],"content":"정적(Static) 링크 란? link 단계에서 라이브러리(*.lib 파일)을 실행 바이너리(컴퓨터가 이해할 수 있는 문법으로 만들어진 결과물)에 포함한다는 의미 *.lib 파일이란? \u003e Library 파일, 개발 코드에서 반복되는 기능들을 모아둔 파일 ex) *.exe 파일 라이브러리 관련 수정사항이 생기면 파일 전체를 다시 컴파일하여 재배포해야 한다. ​ ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/staticvsdynamic_link/:1:0","tags":["Link"],"title":"정적(Static) 링크 Vs 동적(Dynamic) 링크","uri":"https://colinder.github.io/staticvsdynamic_link/"},{"categories":["Link"],"content":"동적(Dynamic) 링크 란? 특정 기능을 사용하고자 하는 실행 바이너리에서 필요시 사용할 수 있도록 최소한의 정보만 포함하여 링크하거나, 독립적으로 dll을 로드/사용/해제 시킨다는 의미. *.dll 파일이란? \u003e Dynamic Link Library 파일, 개발 코드에서 반복되는 기능들을 모아둔 파일 (다만, 동적 링크로 사용되는 라이브러리 파일) 라이브러리 관련 수정사항이 생기면 .dll 파일만 다시 컴파일 하여 재배포하며 된다. ​ ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/staticvsdynamic_link/:2:0","tags":["Link"],"title":"정적(Static) 링크 Vs 동적(Dynamic) 링크","uri":"https://colinder.github.io/staticvsdynamic_link/"},{"categories":["Link"],"content":"둘의 차이점 *.lib 파일은 링크 시에 필요한 파일이고, *.dll 파일은 실행 시에 필요한 파일이다. ​ ​ ​ ","date":"2021-09-06","objectID":"https://colinder.github.io/staticvsdynamic_link/:3:0","tags":["Link"],"title":"정적(Static) 링크 Vs 동적(Dynamic) 링크","uri":"https://colinder.github.io/staticvsdynamic_link/"},{"categories":["license"],"content":"​ License 배포 시 소스코드 제공 의무와 범위 License에 대하여 알아보다보니, 배포 시 준수해야 하는 내용이 별도로 존재하고 있어 오픈소스 SW라이선스 종합정보시스템에서 발최한 내용을 추가로 정리합니다. ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:0","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- Work Based on the Code -제공의무: 원 저작물의 소스코드를 원본 그대로, 혹은 수정하여 새로운 SW에 포함하였을 경우 -제공범위: 원 저작물의 소스코드가 포함되어, 파생 저작물로 인정되는 범위내의 모든 소스코드 -GNU GPL, GNU AGPL 등 ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:1","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- Derivative Work -제공의무: 원 저작물의 소스코드를 수정하여 사용한 경우 제공의무가 존재하며, 수정 없이 그대로 사용하였을 경우에는 소스코드를 제공하지 않아도 됨 -제공범위: 원 저작물을 사용함에 있어 수정을 거쳤다면, 원 저작물의 소스코드에서부터 존재하던 파일을 모두 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 부분에 대해서는 공개하지 않아도 됨 -GNU LGPL, NASA Open Source Agreement, Simple Public License 등 ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:2","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- O 혹은 O(표준버전) -비명시적으로 소스코드의 제공을 요구 -Artistic License에서 표현하고 있는 “O(표준버전)“는, ‘표준버전’의 소스코드를 제공해야 함을 의미하며, 따라서 ‘수정버전’의 소스코드는 공개하지 않아도 됨 -Artistic License(Standard Version), Qt Public License, Frameworx License 등 ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:3","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- File -제공의무: 원 저작물의 소스코드를 원본 그대로, 혹은 수정하여 새로운 SW에 포함하였을 경우 -제공범위: 원 저작물을 사용함에 있어 수정을 거쳤다면, 원 저작물의 소스코드에서부터 존재하던 파일 중, 수정된 부분을 포함하는 파생 저작물을 모두 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 파일에 대해서는 공개하지 않아도 됨 -Mozilla Public License, Common Development and Distribution License, Sun Public License 등 ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:4","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- Module -제공의무: 원 저작물의 소스코드를 원본 그대로, 혹은 수정하여 새로운 SW에 포함하였을 경우 -제공범위: 원 저작물을 사용함에 있어 수정을 거쳤다면, 원 저작물의 소스코드에서부터 존재하던 파일 중 수정된 부분을 포함하는 모듈을 모두 공개해야 하며, 파생 저작물의 저작자가 새로이 생성한 부분 중 기존 모듈에 해당되지 않는 부분에 대해서는 공개하지 않아도 됨 -Eclipse Public License, Common Public License, Adaptive Public License 등 ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:5","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- File Derivative Work -제공의무: 원 저작물의 소스코드를 수정하여 사용한 경우 제공의무가 존재하며, 수정 없이 그대로 사용하였을 경우에는 소스코드를 제공하지 않아도 됨 -제공범위: 원 저작물의 소스코드에서부터 존재하던 파일 중 수정된 부분을 파일 단위로 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 파일에 대해서는 공개하지 않아도 됨 -Reciprocal Public License ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:6","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- Module Derivative Work -제공의무: 원 저작물의 소스코드를 수정하여 사용한 경우 제공의무가 존재하며, 수정 없이 그대로 사용하였을 경우에는 소스코드를 제공하지 않아도 됨 -제공범위: 원 저작물의 소스코드에서부터 존재하던 파일 중 수정된 부분을 모듈 단위로 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 부분 중 기존 모듈에 해당되지 않는 부분에 대해서는 공개하지 않아도 됨 -Computer Associates Trusted Open Source License ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:7","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"- Accompanying Software -DB SW나 DB SW를 사용하는 동봉된 SW에 대하여, 완전한 소스코드를 구할 수 있는 방법을 첨부하기를 요구 -Sleepycat License ​ ​ ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/01_dutis_and_scope_at_deployment/:0:8","tags":["license"],"title":"License 배포 시 소스코드 제공 의무와 범위","uri":"https://colinder.github.io/01_dutis_and_scope_at_deployment/"},{"categories":["license"],"content":"​ License 실무를 담당하고 있다면, 새로운 프로젝트에 앞서 어떤 기술을 사용할 것인지 조사하는 것도 업무중의 하나입니다. 근데 항상 고민이 되는 부분. 비용과 권한 그리고 비용과 권한 정리되어 있는 것이 License ​ 한국저작권위원회의 OLIS(오픈소스SW 라이선스 종합정보시스템)에는 라이선스에 대한 내용이 잘 정리 되어 있습니다. 많은 라이선스들이 있지만, 접해본 라이선스 위주로, 개발을 위해 중요하게 보았던 부분을 정리합니다. ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:0:0","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["license"],"content":"1. MIT License 아마 가장 흔하게 접하는 라이선스일 것입니다. “MIT 라이선스(MIT License)는 미국 매사추세츠 공과대학교(MIT)에서 해당 대학의 소프트웨어 공학도들을 돕기 위해 개발한 라이선스다. MIT 라이선스를 따르는 소프트웨어를 개조한 제품을 반드시 오픈 소스로 배포해야 한다는 규정이 없으며 GNU 일반 공중 라이선스의 엄격함을 피하려는 사용자들에게 인기가 있다.” ​ 주요 특징 복제, 배포, 수정의 권한 허용: 가능 배포시 라이선스 사본 첨부: 가능 배포시 소스코드 제공의무(Reciprocity)와 범위: 명시되어 있지 않음 조합저작물(Lager Work) 작성 및 타 라이선스 배포 허용: 가능 책임의 제한: 가능 ​ MIT license를 사용한 프로젝트 배포시 의무사항 저작권 안내문구, MIT 라이선스 문구가 모든 복제본에 포함 ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:1:0","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["license"],"content":"2. GPL(GNU) License - 일반 공중 사용 허가서 “자유나 죽음이냐” 완전한 자유를 꿈꾸는 라이선스입니다. 자유에는 제한이 없으며, 모든 것이 공유되어야하며, 책임이 따른다. 는 관점의 라이선스입니다. “자유 소프트웨어 재단(FSF)에서 만든 자유 소프트웨어 라이선스다. 미국의 리처드 스톨만(Richard Stallman)이 GNU-프로젝트로 배포된 프로그램의 라이선스로 사용하기 위해 작성했다. ‘① 컴퓨터 프로그램을 어떤 목적으로든지 사용할 수 있다 ② 컴퓨터 프로그램의 복사를 언제나 프로그램의 코드와 함께 판매 또는 무료로 배포할 수 있다 ③ 컴퓨터 프로그램의 코드를 용도에 따라 결정할 수 있다 ④ 변경된 컴퓨터 프로그램 역시 프로그램의 코드와 함께 자유로이 배포할 수 있다’라는 네 가지 조항을 명시하고 있다.” “대부분의 소프트웨어에 대한 라이선스는 소프트웨어를 공유하거나 수정할 수 있는 자유를 금지하기 위 고안되었다. 반면에 GNU 일반 공중 라이선스는 자유 소프트웨어를 공유하고 수정할 수 있는 자유를 보장하기 위해 의도되었다. 즉, 소프트웨어가 사용자 모두에게 자유롭게 이용될 수 있도록 하는 것이다. 이 일반 공중 라이선스는 자유 소프트웨어 재단의 소프트웨어 대부분을 비롯하여, 저작자가 이 라이선스의 사용을 지정한 기타 모든 프로그램에 적용된다. (자유 소프트웨어 재단의 소프트웨어 중 일부는 이 라이선스 대신 GNU 라이브러리 일반 공중 라이선스가 적용된다.) 누구나 자신의 프로그램에 이 라이선스를 적용시킬 수 있다.” ​ 주요 특징 복제, 배포, 수정의 권한 허용: 가능 배포시 라이선스 사본 첨부: 가능 배포시 소스코드 제공의무(Reciprocity)와 범위: WORK BASED ON THE CODE WORK BASED ON THE CODE 제공의무: 원 저작물의 소스코드를 원본 그대로, 혹은 수정하여 새로운 SW에 포함하였을 경우 공개 제공범위: 원 저작물의 소스코드가 포함되어, 파생 저작물로 인정되는 범위내의 모든 소스코드 공개 조합저작물(Lager Work) 작성 및 타 라이선스 배포 허용: 조건부 가능 보통의 경우 상업용 라이선스가 별도로 존재하는 것 같습니다. (비용 ㅎㄷㄷ…) 명시적 특허 라이선스의 허용: 명시되어 있지 않음. ​ GPL(GNU) license를 사용한 프로젝트 배포시 의무사항 각 복제본에 적절한 저작권 고지와 보증책임이 없음을 명시 GPL 라이선스를 언급하는 고지사항과 보증책임 관련 고지사항을 원본 그대로 유지 프로그램을 양도 받는 모든 이들에게 프로그램과 함께 GPL 라이선스 사본 제공 파일 수정의 경우 수정사실과 날짜를 파일에 명기 원본저작물과 파생저작물을 GPL 2.0에 의해 배포 원본저작물 및 파생저작물에 대한 소스코드를 제공하거나, 요청시 제공하겠다는 약정서 제공 ​ 간단히, 프로젝트의 코드가 공개되지 않아야 한다면, 비용없이 개발하고 싶다면 이 License의 오픈소스는 사용하면 안됩니다. ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:2:0","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["license"],"content":"3. LGPL3 (Lesser General Public License version 3.0) LGPL은 GPL보다는 훨씬 완화된(Lesser) 조건의 공개 소프트웨어 라이선스입니다. 라이브러리는 공유하되 개발된 제품에 대해서는 소스를 공개하지 않고 상용 SW 판매가 가능한 GPL 보다 완화된 라이선스를 말함. 가장 큰 차이점은 LGPL 코드를 정적(static) 또는 동적(dynamic) 라이브러리로 사용한 프로그램을 개발하여 판매/배포할 경우에 프로그램의 소스코드를 공개하지 않아도 된다는 점입니다. LGPL 코드를 사용했음을 명시만 하면 됩니다. 단, LGPL 코드를 단순히 이용하는 것이 아니라 이를 수정한 또는 이로부터 파생된 라이브러리를 개발하여 배포하는 경우에는 전체 코드를 공개해야 합니다. ​ 주요 특징 복제, 배포, 수정의 권한 허용: 가능 배포시 라이선스 사본 첨부: 가능 배포시 소스코드 제공의무(Reciprocity)와 범위: DERIVATIVE WORK (파생작업물) DERIVATIVE WORK 제공의무: 원 저작물의 소스코드를 수정하여 사용한 경우 제공의무가 존재하며, 수정 없이 그대로 사용하였을 경우에는 소스코드를 제공하지 않아도 됨 제공범위: 원 저작물을 사용함에 있어 수정을 거쳤다면, 원 저작물의 소스코드에서부터 존재하던 파일을 모두 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 부분에 대해서는 공개하지 않아도 됨 조합저작물(Lager Work) 작성 및 타 라이선스 배포 허용: 가능 이름, 상표, 상호에 대한 사용제한: 명시되어있지 않음. ​ LGPLv3 license를 사용한 프로젝트 배포시 의무사항 각 복제본에 저작권 고지와 보증책임이 없음을 명시 LGPL 3.0의 조건 및 제7조의 조건에 관한 내용을 있는 그대로 유지 프로그램을 양도 받는 모든 이들에게 프로그램과 함께 GPL 및 LGPL 라이선스 사본 제공 수정시 수정사실 및 일시를 명시 원본저작물과 파생저작물을 LGPL3.0에 의해 배포 원본저작물 및 파생저작물에 대한 소스코드를 제공하거나, 요청시 제공하겠다는 약정서 제공 사용자제품에 대한 인증키 등 설치정보의 제공 응용프로그램을 배포할 경우, LGPL 라이브러리를 사용하고 있다는 사실을 명시 사용자가 라이브러리를 수정해도 응용프로그램을 사용할 수 있도록 (예를 들어 오브젝트코드 등을 제공하거나 공유라이브러리 방식등을 이용하여) 허용 ​ 라이브러리 소스코드를 수정 또는 파생하여 사용한 경우에는 공개의무가 발생하지만, 그렇지 않으면 상업용으로 사용해도 공개 의무가 없습니다. 또 정적링크(ex. .exe 파일)로 개발하여 사용 시 수정코드를 포함한 라이브러리의 소스코드와 응용프로그램의 오브젝트 코드에 대한 공개의무가 발생합니다. ​ ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:3:0","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["license"],"content":"✨라이브러리마다 자체의 라이센스 내용이 추가되는 경우가 많습니다. 라이브러리 제작자(제공자) 자체 라이센스 내용도 확인해야 합니다. ​ ​ ​ ​ ​ ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:4:0","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["license"],"content":"정보통신산업진흥원에서는 공개SW 라이선스를 아래와 같이 정리하고 있습니다. 공개SW(Open Source Software)는 소스가 공개되어 사용, 복제, 배포,수정 할 수 있지만, 원 저작자의 라이선스 규칙에 따라야 함 공개SW(Open Source Software) 라이선스란 공개SW 개발자와 이용자 간의 사용 방법 및 조건의 범위를 명시한 계약을 말한다. 따라서 공개SW를 이용하려면 공개SW 개발자가 만들어놓은 조건의 범위에 따라 해당 소프트웨어를 사용해야 하며, 이를 위반할 경우에는 라이선스 위반 및 저작권 침해로 이에 대한 법적 책임을 져야한다. ​ ​ ​ ​ ​ ​ ​ ​ ","date":"2021-09-02","objectID":"https://colinder.github.io/00_license/:4:1","tags":["license"],"title":"Software License","uri":"https://colinder.github.io/00_license/"},{"categories":["Vue"],"content":"​ Vue Dev_Info Vue 개발을 하면서 알게 된(깨닫게 된) 내용을 정리해 기록합니다. ​ ","date":"2021-08-08","objectID":"https://colinder.github.io/vue_devinfo/:0:0","tags":["Vue"],"title":"Vue_DevInfo","uri":"https://colinder.github.io/vue_devinfo/"},{"categories":["Vue"],"content":"1. Vuex 동작에 대한 고찰 개인적으로 DB의 자료를 가져오는데 5개 이상의 테이블에서 DB를 가져오고, 이를 종합해 새로운 리스트 혹은 데이터를 만들어야 한다면 무조건 vuex의 사용을 추천합니다. 다만, vuex를 사용하는데 일반적으로 알려진 단계를 지켜야 하는 이유와 방법에 대하여 정리합니다. 위의 그래프를 보면 .vue 파일에서 .dispatch()를 사용에 vuex의 store.js에 등록된 actions의 함수를 동작하는 신호를 보냅니다. 이어서 actions에서는 .commit()함수로 mutations를 동작하는 신호를 보냅니다. ​ 왜 이런 단계를 만들어 냈을까요? vuex는 상태를 관리하기 위해 만들어졌습니다. 상태는 무결성을 유지해야 합니다. 데이터를 보호하고, 항상 정상적인 상태를 유지해야 하는데 여러 사람이 동시에 데이터의 변화를 요청하고 처리된다면 무결성을 유지하는데 문제가 될 수 있기 때문에 동기적인 처리가 중요합니다. 그런데 actions는 비동기적 처리를 하며 mutatinos는 동기적으로 처리합니다. 이렇게 단계가 나누어져 있는 것에 이유는 1. 일단 사용자들의 요청(actions)는 접수받고(쌓아두고) 2. 이를 반영하는 처리(mutations)는 동기(순차)적으로 처리하여 3. 데이터의 무결성을 유지하기 위함이라고 생각합니다. 간단히 선착순의 개념을 떠올려 접수는 일단 쌓아두고 내 능력에 따라 처리하는 사람과 비슷한 모양새의 일처리 방식입니다. 공식문서를 확인해보면 actions도 동기적으로 사용할 수 있습니다. 다만, 굳이 필요하지 않다면, vue 개발자가 의도한 흐름대로 사용하는 것을 권장하고 싶습니다. (동기적인 actions를 실제 프로젝트에 적용해보려했으나 쉽지 않았습니다…) ​ ​ ","date":"2021-08-08","objectID":"https://colinder.github.io/vue_devinfo/:1:0","tags":["Vue"],"title":"Vue_DevInfo","uri":"https://colinder.github.io/vue_devinfo/"},{"categories":["Vue"],"content":"2. EventBus 사용시 주의사항 EventBus 사용 로직을 생각해보자 어떤 동작(method)을 하여 신호나 데이터를 보내려는 파일(A)이 존재할 것이고, 그 신호나 데이터를 받는 파일(B)이 존재한다. 보통 A에서는 어떤 동작과 함께 신호나 데이터를 보내려는 동작(EventBus.$emit())을 method에 등록하고, B에서는 신호나 동작을 받는 것(EventBus.$on())을 created나 mounted에 등록합니다. //// 이벤트버스 생성 var EventBus = new Vue() //// 이벤트 발행 // 신호 or 데이터를 보내려는 .vue파일 안에서 EventBus.$emit('message', 'hello world'); // message라는 이름의 신호에 'hello world'를 데이터로 보냄 //// 이벤트 수신(구독) // 신호 or 데이터를 받으려는 .vue파일 안에서 EventBus.$on('message', function(text) { // message라는 신호를 수신하고 전달받은 인자(text)를 console.log(text); // console에 찍어본다. }); //// 이벤트 한번 만 수신 EventBus.$once('message', function(text) { // message라는 신호를 단 한번 만 수신한다. console.log(text); }); //// 이벤트 제거 EventBus.$off('message') // message라는 신호를 제거(보통 beforeDestroy()에 등록) 개인적으로 EventBus.$off() 를 잘 사용하는 것이 중요하다고 생각합니다. 이벤트 버스는 객체가 계속 쌓이기 때문에 $off()를 해주지 않으면 첫 번째 신호에서는 1번 동작, 두 번째 신호에서는 2번 동작, 세 번째 신호에서는 3번이 동작되어 누적된 신호를 수신하게 됩니다. ​ ​ ","date":"2021-08-08","objectID":"https://colinder.github.io/vue_devinfo/:2:0","tags":["Vue"],"title":"Vue_DevInfo","uri":"https://colinder.github.io/vue_devinfo/"},{"categories":["Vue"],"content":"3. Backend 개발의 중요성 이전 개발을 하면서 Front 중심의 개발을 진행하였습니다. 전임자가 DB를 신경쓰지 않아 외래키 연결 및 테이블관의 관계 설정이 엉망이었습니다. 물론 Backend 로직으로 어느 정도 개선이 가능하지만… Back은 DB 자료를 넘겨주기만 하고 Front 중심으로 개발을 해보았습니다. 그러지 맙시다ㅎ. DB를 최대한 정교하게 설정하고 Backend에서 최대한 필요한 형태로 자료를 변환하여 Front로 넘겨주는 것이 가장 이상적인 방법이라는 생각이 들었습니다. Front에서 데이터 형태를 변환하여 사용하것도 좋지만, .vue 파일과 .js 파일과 vuex간의 데이터 연동되는 속도에 이슈가 발생할 가능성이 매우 높습니다. lifecycle에 능통하지않고, 참조하는 파일이 많은 경우에는 최대한 back에서 처리를 한다음 front로 데이터를 넘겨줄 수 있게 기획하는 것을 권장합니다. 추가로 axios통신을 하는데 당연히 DB에 적제된 순서대로 데이터가 Front로 넘어오겠지 했는데, sort를 해주지 않으면 데이터가 무작위 순서로 전달되었습니다. sort하여 데이터를 넘겨주는 것을 권장합니다. ​ ​ ","date":"2021-08-08","objectID":"https://colinder.github.io/vue_devinfo/:3:0","tags":["Vue"],"title":"Vue_DevInfo","uri":"https://colinder.github.io/vue_devinfo/"},{"categories":["Vue"],"content":"4. Vuex - actions(async await) 동기화 처리를 위해 async await을 사용하려 했습니다. 다만 원하는 대로 개발은 되지 않았습니다. 많은 레퍼런스를 찾아보았고 방법을 찾았지만 적용하는 것은 어려웠습니다. 원인 1. actions에서 axios .vue → (.dispatch()) → actions → (.commit()) → mutations → axios 의 로직으로 개발하였습니다. 하지만 제가 확인한 레퍼런스들 중 API 통신을 actions에서 axios를 사용하는 형태의 async await 구현이 많았습니다. 또 저는 actions에서 여러개의 .commit()을 날려 여러개의 mutations동작을 원했고 이미 개발된 형태에서 변경하는데 시간이 많이 소요될 것으로 예상해 acitions에서 API통신 하는 방식으로 개발하지 못했습니다. 😂의도한 개발 흐름 혹시 1개의 actions에서 여러개의 .commit()을 날리는데 async await을 구현하는 레퍼런스 혹은 방법을 알고있다면 조언 부탁드립니다. ​ ","date":"2021-08-08","objectID":"https://colinder.github.io/vue_devinfo/:4:0","tags":["Vue"],"title":"Vue_DevInfo","uri":"https://colinder.github.io/vue_devinfo/"},{"categories":["oracle"],"content":"​ 오라클 18C_외부DB 접근(네트워크 연동) 방법 오라클 18 버전의 외부 DB 접근(네트워크 연동) 방법에 대하여 정리합니다. 제가 네트워크 연동을 기획하면서 두 가지 관점으로 생각했습니다. 첫째, DB를 가진 host가 있을 것이고 둘째, DB에 연결할 guest가 있을 것이다. 그렇다면, host가 guest의 IP를 등록해놓으면 guest가 접근하면 DB가 연결되는 걸까? guest가 host의 IP를 입력해 DB를 연결하는 걸까? 아래 내용은 위의 두 가지를 다 진행하여 연결하였습니다. ​ 👀주의 각 단계 단계들이 필수적인 사항인지는 파악되지 않았습니다. 다만, 저는 해당 방법으로 진행했더니 연결이 되었기에 그 내용을 정리하였습니다. ​ ","date":"2021-07-06","objectID":"https://colinder.github.io/oracle_network_connect/:0:0","tags":["oracle","network"],"title":"Oracle 18C_network_connect","uri":"https://colinder.github.io/oracle_network_connect/"},{"categories":["oracle"],"content":"🧔 우선 host가 할 일. tnsnames.ora tnsnames.ora를 찾아야 합니다. (저는 C:\\app\\UESR\\product\\18.0.0\\dbhomeXE\\network\\admin에 위치했으나, 이는 다른 블로그에 내용을 참고해 직접 찾은 것이고 상황에 따라 다를 수 있습니다.) 파일을 찾았다면 내용을 수정합니다. # tnsnames.ora Network Configuration File: # C:\\app\\kjong\\product\\18.0.0\\dbhomeXE\\NETWORK\\ADMIN\\tnsnames.ora # Generated by Oracle configuration tools. XE = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = DESKTOP-HKDL12K)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = XE) ) ) LISTENER_XE = (ADDRESS = (PROTOCOL = TCP)(HOST = DESKTOP-HKDL12K)(PORT = 1521)) ORACLR_CONNECTION_DATA = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) ) (CONNECT_DATA = (SID = CLRExtProc) (PRESENTATION = RO) ) ) ########################여기 아래가 추가된 내용######################## my_DataBase = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = guest_IP)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = XE) ) ) ## 3가지 요소에 대하여 알아봅시다. # 1. Database Name = (my_DataBase, host가 설정한 공유할 DB의 이름입니다. 아무렇게나 해도 됨.) # 2. HOST = (guest_IP, host DB에 접근할 guest의 IP주소를 입력합니다. 아래에 확인방법 있음) # 3. SERVICE_NAME = (XE, 처음 오라클을 설치할 때 설정하게 됩니다. 아래에 확인방법 있음) IP 확인 방법 cmd(명령 프롬프트)를 연다. ipconfig 입력 후 enter 출력된 항목 중 IPv4 주소 값 == IP ​ SERVICE_NAME 확인 방법 oracle을 설치하면서 같이 설치되는 SQL Plus 실행 sys as sysdba 입력 (이어서 비밀번호를 입력해야 하는데 전 그냥 enter하니 넘어감) SQL\u003e 가 생기면 select name from v$database; 입력 NAME 아래에 SERVICE_NAME 확인 가능 ​ ​ tnsnames.ora가 있는 폴더 안에 있는 listener.ora파일과 관련있는 Listener를 재시작한다. 오라클 리스너는 네트워크를 이용하여 클라이언트에서 오라클 서버로 연결하기 위한 오라클 네트워크 관리자 입니다. 네트워크를 통한 연결은 모두 리스너가 담당하며 리스너와 연결되기 위해서는 클라이언트에 오라클 NET8(오라클 클라이언트)이 설치되어 있고 이를 통해 오라클 서비스명이라는 것을 만들어 접속을 해야 합니다. 오라클 서버에서 리스너를 시작시켜줘야 클라이언트들이 접속을 할 수 있습니다. (한 번 켜주니 재실행할 필요 없이 계속 접속 가능했음.) cmd(명령 프롬프트)를 관리자 권한으로 실행한다. lsnrctl stop 입력 (상태 끄기) lsnrctl start 입력 (상태 시작) ​ ​ ​ ​ ","date":"2021-07-06","objectID":"https://colinder.github.io/oracle_network_connect/:1:0","tags":["oracle","network"],"title":"Oracle 18C_network_connect","uri":"https://colinder.github.io/oracle_network_connect/"},{"categories":["oracle"],"content":"🙋‍♂️이제는 guest에서 진행 SQL Developer 접속 후 초록색 ➕ 클릭 채워야 할 값들 정리 Name : host의 DB를 guest가 사용할 건데 이름 설정 (아무렇게나 설정 해도 ok) 사용자 이름(U) : host가 DB를 만들면서 등록한 ID 비밀번호(P) : host가 DB를 만들면서 등록한 PW 호스트 이름(A) : host의 IP를 기재 포트(R) : 전 따로 손대지 않았어서 defualt값인 1521 기재. (아마 아까 tnsnames.ora의 추가한 내용 중 (ADDRESS = (PROTOCOL = TCP)(HOST = guest_IP)(PORT = 1521))여기 PORT 값일 듯.) SID(I) : host PC에서 확인 할 수 있습니다. SQL Plus 실행 /as sysdba 입력 SQL\u003e 가 생기면 select name from v$thread; 입력 INSTANCE 아래에서 확인 가능 Service Name : 서버관련, 클라이언트에서 사용하고자 하는 DB SID : 오라클 DB가 설치되어있는 곳에서 생성한 DB명 네트워크를 연결하는 경우 host가 생성한 DB의 고유한 값과 guest가 불러온 DB의 구분을 위해 존재하는 것 같습니다. ​ ​ ​ ​ ​ ","date":"2021-07-06","objectID":"https://colinder.github.io/oracle_network_connect/:2:0","tags":["oracle","network"],"title":"Oracle 18C_network_connect","uri":"https://colinder.github.io/oracle_network_connect/"},{"categories":["oracle"],"content":"👍이상 연결이 완료되고 host가 생성한 DB를 guest PC에서 확인할 수 있었습니다. 찾아보면 더 간편한 방법이 있을 수 있습니다. 정리한 방법은 다양한 정답 중 하나 정도로만 생각하고 참고하시면 좋을 것 같습니다. ","date":"2021-07-06","objectID":"https://colinder.github.io/oracle_network_connect/:3:0","tags":["oracle","network"],"title":"Oracle 18C_network_connect","uri":"https://colinder.github.io/oracle_network_connect/"},{"categories":["AI","Activation Function"],"content":"​ Activation Function(활성화 함수) 입력 신호의 총합을 출력신호로 변환하는 함수를 일반적으로 Activation Function이라고 합니다. ​ 아직 잘 모르겠습니다. 하여 인공신경망에 빗대어 이해해보겠습니다. 인공 신경망은 인간의 중추신경계(뇌)속의 뉴런들이 정보를 전달하고 학습하여 결과를 도출해내는 과정을 모방한 학습알고리즘입니다. 여기서 의문점이 생깁니다. 예를 들어 지나가다 귤을 보았는데 맛이 있을지 없을지 어떻게 알 수 있을까요? 저 귤의 데이터를 수집해 봅시다. 타원형, 이쁜 노란색, 푸르른 꼭지 라는 데이터를 눈으로 보고 뇌속의 뉴런들이 이 정보를 분석해 맛있겠다.라는 출력을 불러왔습니다. 입력된 데이터를 어떤 규칙? 방법에 따라 분석하여 출력 데이터로 변환하였는데요. 이 역할을 해주는 것이 Activation Function입니다. ​ ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:0:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"✋ ‘Node와 Layer’가 어떻게 생겼는지 다시 알아봅시다. Node는 뇌속의 뉴런과 같은 역할이고, Node들이 모여 인공신경망의 층이라 불리는 Layer가 됩니다. ​ ​ ​ ​ Features of activation function 활성화 함수는 주로 비선형 함수(곡선 그래프로 표현되는 함수)를 사용합니다. 왜 그럴까요? 선형함수(직선 그래프로 표현되는 함수)를 사용하면 Layer(층)을 깊게 쌓아 학습하는 의미가 줄어들기 때문입니다. 예를 들어 어떤 현상(or 데이터)를 분석(or 학습)하는데 선형(linear)함수 H(x) = ax 활성화 함수로 사용하는 3-Layer 네트워크가 있을 때. 해당 네트워크는 결국 Y(x) = H(H(H(x)))와 동일해집니다. 간단히 Y(x) = a^3x 로도 표현할 수 있습니다. 하나의 Layer( Y(x) = a^3x )로도 3-Layer를 대신할 수 있게 됩니다. 즉, 선형(linear)적인 연산을 갖는 Layer는 몇개를 쌓는다 해도, 결국 하나의 선형적인 연산처리하는 Layer로 대체될 수 있습니다. 또 위의 그림을 보면 파란원(특이점)을 더 많이 만족하는 것은 비선형 함수가 됩니다. 실제 자연환경에서는 선형적이지 않은 복잡한 일(특이점)들이 더 많기 때문에 다양한 조건에 대응하기 위해서 비선형 함수를 사용하는 것입니다. ​ ​ ​ ​ Type of activation function 대표적인 활성화 함수에 대하여 알아보겠습니다. 활성화 함수는 엄청 많습니다. Threshold, Binary step, Sigmoid, Tanh or Hyperbolic tangent, Softmax, ReLU, Leaky ReLU, Parametric ReLU, ETC….. 활성화 함수는 ‘하이퍼 파라미터‘라고 불립니다. 간단히 사용자가 설정해주는 값인데, 결국 정답은 없으며, 우리의 직관? 판단?으로 설정해야하는 값입니다. 막연하지만, 함수의 특징을 안다면 상황에 맞게 최적의 함수를 선택해 사용할 수 있으니 알아보겠습니다. ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 Binary Step function 마치 계단 같이 0을 기준으로 0 or 1로 극명하게 값을 결정됩니다. =\u003e Output은 0 또는 1 0.01도 1로 처리되어 100배의 결과값 차이가 발생합니다. 마치 선형(linear)함수와 비슷해 학습할 내용이 많으면 사용하지 않는 것이 좋습니다. ​ ​ ​ ​ 🤔 너무 극단적인 구분값말고 융통성있는 이진 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:1","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 Sigmoid function 선형함수의 결과를 0 ~ 1까지의 비선형 형태로 변환하는 Logit 함수입니다. =\u003e Output은 0~1 사이의 실수 로지스틱, 정규분포 등과 같이 이진 분류 문제(1 or 0 /성공 or 실패…)의 확률 표현에 자주 사용됩니다. 0~1 사이의 실수를 output으로 가져 0.5를 기준으로 1에 가까우면 1, 0에 가까우면 0으로 나누는 등 으로 활용합니다. binary classification의 출력층 노드에서 0~1사이의 값을 만들고 싶을때 사용합니다. ✨인공 신경망이 학습하는 과정에서 저번엔 안 중요했는데, 이번에는 중요하네? 와 같이 학습하는 요소의 가중치를 잘 반영해야 하는데 Sigmoid는 원점이 중심이 아닙니다.(Not zero-centered). 평균이 0.5이며 항상 양수를 출력하기 때문에 출력의 가중치합이 입력의 가중치합보다 커질 가능성이 높아집니다. 이것을 편향 이동(bias shift)이라고 하는데, 이러한 이유로 각 Layer를 지날 때마다 분산이 계속 커져 가장 높은 Layer에서는 활성화 함수의 출력이 그래프의 극값인 0 or 1로 수렴하게 되고 결국 기울기가 0이 되어 버리는 Gradient Vanishing이 일어나게 됩니다. 또 애초에 매우 높거나, 낮은 입력에 대한 예측을 거의 변경하지 않아(크면 무조건1, 작으면 무조건 0) 궁극적으로 신경망이 학습을 거부하게 됩니다. ​ ​ ​ ​ 🤔 Sigmoid보다 가중치를 조금 더 잘 반영하는 이진 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:2","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 Tanh(Hyperbolic tangent) function Hyperbolic Tangent(tanh) 함수는 Sigmoid의 대체제로 사용되는 함수입니다. 매우 유사하게 생겼습니다. 실제로, Hyperbolic Tangent 함수는 확장 된 Sigmoid 함수입니다. 차이점은 출력범위가 0 ≤ Sigmoid ≤ 1이고 -1 ≤ tanh ≤ 1 이라는 점입니다. 원점 중심(zero-centered)이기 때문에, 시그모이드와 달리 편향 이동이 일어나지 않습니다. 하지만, tanh함수 또한 입력의 절대값이 클 경우 -1이나 1로 수렴하게 되므로 Gradient Vanishing가 발생하지만, Sigmoid보다 발생 경향이 적어 효과적으로 사용이 가능합니다. 보통 Sigmoid와 비교하는데 주로 미분한 결과를 보며 설명합니다. 왜 미분한 결과 일까요? ∴ 표현할 수 있는 기울기가 결국 출력될 수 있는 값이기 때문입니다. tanh그래프의 미분계수의 최댓값은 1입니다. sigmoid와 비교하여 최대값이 약 4배가 크고이는 약 4배 더 다양한 분석이 가능하다고 해석할 수 있습니다. ​ ​ ​ ​ 🤔 만약 이진분류가 아닌 다중 분류가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:3","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 Softmax function 세 개 이상으로 분류하는 다중 클래스 분류에서 사용되는 활성화 함수입니다. 입력받은 값을 출력으로 0~1사이의 값으로 모두 정규화하며 출력 값들의 총합은 항상 1이 되는 특성을 가진 함수입니다. 예를 들어 어떤 이미지가 주어지고 이것이 사과인지, 배인지, 귤인지 판단해야 할 때, Softmax함수는 사과일 확률, 배일 확률, 귤일 확률[0.5, 0.3, 0.2]을 출력해줍니다. 즉, Output은 class 별 확률이고 class별 출력값의 총합은 1이 됩니다. class별로 확률을 알려주다보니, 출력 노드에서 확률을 확인하고 이를 최종결과로 반영하는 상황에서 많이 사용됩니다. 근데, 위의 Softmax공식을 보니 자연 상수e를 사용하고 있습니다. 왜 ‘자연 상수e’일까요? 그 이유는 크게 2가지가 있습니다. 미분이 쉽습니다. ( == 값을 계산하기 용이하다.) 큰 값은 더 크게, 작은 값은 더 작게 가중치를 주어 확률을 계산합니다. 예로 0.1, 1.0, 2.0의 입력값을 Softmax로 출력해보면 0.03, 0.33, 0.63가 아닌 0.1, 0.2, 0.7이 나옵니다. Softmax는 1과 2가 아닌 e^1 (2.718), e^2 (7.389)로 확률을 계산합니다. 즉 입력값이 커짐에 따라 기울기가 증가하며 더 큰 차이를 만들며, Soft하게 “Max\"한 값을 선정하는데 용이합니다. ​ ​ ​ 🤔 Gradient Vanishing 문제가 없는 활성화 함수가 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:4","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 ReLU(Rectified Linear Unit) function 가장 많이 사용되는 활성화 함수 중 하나입니다. 음수를 입력하면 0을 출력하고, 양수를 입력하면 입력값을 그대로 반환 =\u003e Output은 0 이상의 실수 tanh함수 대비 약 6배 빠른 속도로 학습이 가능하고, Gradient Vanishing가 발생하지 않습니다. 주로 hidden Layer에 사용됩니다. ReLu의 문제점은 음수 값은 무조건 0으로 처리하기 때문에 학습 능력이 감소한다.는 것에 있습니다. 이를 죽은 렐루(Dying ReLU)라고 합니다. 그리고 이 문제를 완화하기 위해 Leaky ReLu함수가 등장하였습니다. ​ ​ ​ ​ 🤔 ReLU의 음수값을 살린를 학습법이 필요하다면? ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:5","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"🔗 Leaky ReLU function 위 그래프에서 공식 αx (x ≤ 0)에서 α는 사용자가 지정하는데 ‘매우 작은 수‘로 지정하며 보통 0.01로 설정합니다. ReLU에서 음수값을 물이 누수(Leaky)되듯이 매우 작게나마 표시해주는 함수입니다. ​ ​ ​ ​ ​ ​ ​ ​ 이밖에도 많은 활성화 함수가 있으니 더 찾아보는 것을 추천합니다. ​ ​ ​ 👀참고 Sigmoid 함수의 개념은 오즈(odds)에서 부터 출발합니다. 일반적으로는 ELU -\u003e LeakyReLU -\u003e ReLU -\u003e tanh -\u003e sigmoid 순으로 사용한다고 합니다. cs231n 강의에서는 ReLU를 먼저 쓰고, 그 다음으로 LeakyReLU나 ELU 같은 ReLU Family를 사용하며, sigmoid는 사용하지 말라고 하고 있습니다. chain rule은 두 함수를 합성한 합성 함수의 도함수(derivative)에 관한 공식입니다. chain rule = 연쇄법칙 = 합성함수의 미분법. 합성 함수 두 개 이상의 함수를 하나의 함수로 결합하여 만들어진 함수. 어떤 함수 속에 또 다른 함수가 들어있고, 그 또 다른 함수 속에 다른 함수가 들어있다. ​ ​ ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:1:6","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["AI","Activation Function"],"content":"참고한 글 https://kejdev.github.io https://wooono.tistory.com/209 https://inhovation97.tistory.com/30 ","date":"2021-06-24","objectID":"https://colinder.github.io/activation_function/:2:0","tags":["AI","Activation Function"],"title":"Activation_Function","uri":"https://colinder.github.io/activation_function/"},{"categories":["Vue"],"content":"​ A Singularity in vue3. vue2. 버전의 프로젝트 경험만 있었기에 최근에 새롭게 웹 개발 프로젝트를 준비하면서 변화된 Vue3. 버전에 대한 몇 가지 내용들을 정리합니다. ​ ","date":"2021-06-23","objectID":"https://colinder.github.io/09_vue3._global_variable/:0:0","tags":["Vue"],"title":"09_Vue3. global variable","uri":"https://colinder.github.io/09_vue3._global_variable/"},{"categories":["Vue"],"content":"Vue3. 전역 변수(Global Variable) 등록 간단하게 axios를 사용해보려고 했는데 Vue2. 버전과 Vue3. 버전의 main.js 초기 세팅이 달랐습니다. 한참을 헤매다 방법을 찾아 기록으로 남김니다. ​ 1. 프로젝트 생성 후 axios 설치 # 프로젝트 폴더(package.json이 있는 폴더)에서 npm install axios ​ 2. 전역 설정을 위한 main.js 수정 // main.js 초기 모습 import { createApp } from 'vue' import App from './App.vue' import router from './router' createApp(App).use(router).mount('#app') // main.js 변경 import { createApp } from 'vue' import App from './App.vue' import router from './router' import axios from 'axios' //👈 const app = createApp(App) //👈 app.use(router) //👈 app.mount('#app') //👈 app.config.globalProperties.$axios = axios //👈 // 위에서 $axios가 axios를 담은 변수 명. ​ 3. 사용하기 // 사용하려는 .vue 파일에서 methods: { axiosTest: function() { this.$axios.get('https://jsonplaceholder.typicode.com/users/2') //👈 this.변수 형태로 사용 .then(res =\u003e console.log(res)) .catch(error =\u003e console.error(error)) } } ","date":"2021-06-23","objectID":"https://colinder.github.io/09_vue3._global_variable/:1:0","tags":["Vue"],"title":"09_Vue3. global variable","uri":"https://colinder.github.io/09_vue3._global_variable/"},{"categories":["web"],"content":"​ 🎈질문을 받았습니다. 저희는 이전에는 django로 풀스택 개발을 했어요. 개발자님은 django - vue.js로 개발을 하신다고 들었는데, vue는 javaScript 언어고 django는 Python 언어인데 둘이 뭔가 통신? 데이터를 주고 받고 하는 것에 있어서 문제는 없나요? 또 같은 javaScript 언어인 node.js 라는 것으로도 Backend 개발이 가능하다고 봤는데 node.js를 Backend로 개발하는 것이, 같은 javaScript로 개발하니까 더 효율적? 좋은거 아닌가요? ​ ","date":"2021-06-22","objectID":"https://colinder.github.io/django_vs_node.js_%EC%A7%88%EB%AC%B8%EC%9D%84_%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/:0:0","tags":["web"],"title":"Django vs Node.js 질문을 받았습니다.","uri":"https://colinder.github.io/django_vs_node.js_%EC%A7%88%EB%AC%B8%EC%9D%84_%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"},{"categories":["web"],"content":"👨‍💻 하나는 명확히 답을 드릴 수 있는데, 하나는 모르겠네요. 알아보고 말씀드리겠습니다 . ​ Vue는 javaScript고 django는 Python인데 둘이 뭔가 통신? 데이터를 주고 받고 하는 것에 있어서 문제는 없나요? =\u003e 네 없습니다. 아마 기존에 django로 풀스택 개발한 코드를 보면 JSON 아니면, XML이라는 표기법(혹은 문법)으로 frontend와 backend 간에 데이터를 주고 받았을 것입니다. 저는 JSON, XML만 알고 있어서 frontend와 backend간에 데이터 통신을 하는 표기법에 대하여 조사를 해보면 더 많은 방법이 있겠지만, 요새는 거의 JSON만 사용하는 것으로 알고 있습니다. python기반의 django로 웹을 개발하더라도 frontend는 html문법으로 개발하기 때문에 python을 할 줄아는 것이 무의미합니다. 결론으로 frontend와 backend 간에 데이터를 주고 받는 것은 python이 아닌 별도의 표기법(JSON or XML 등)을 따르기 때문에 문제는 없습니다. ​ 같은 javaScript언어를 사용하는 node.js를 활용해 Backend개발을 하는 것이 더 효율적? 좋은거 아닌가요? =\u003e 어느쪽이 더 좋다는 명확한 답을 드리기 어렵습니다. (솔직히 잘 모르겠습니다.) 정확하게는 node.js의 웹개발 프레임워크인 express.js랑 비교해야 할 것 같은데요. 자료를 찾아보니 static site는 node.js가 유리하고, dynamic site는 Django가 유리하다고 합니다. 저는 dynamic site를 CRUD가 필요한 site라고 이해하고 있습니다. 사용자 반응에 따라 다른 화면이 구성되어야 하는 site를 기획한다면, Django는 이부분에 강점이 있습니다. (ex. instargram) 반면 API와 실시간 기능이 필요하다면 이는 static site고 이때는 django보다 속도가 빠른 node.js가 유리합니다. 그런데 개인적으로 본인에게 편한 언어로 개발하는 것이 제일 유리하다고 생각합니다. 이 방법이 결국에는 가장 빠르고 효율적인 개발을 할 수 있을 것이라고 생각하기 때문입니다. (저는 python이 편합니다.ㅎ) 부가적으로 사용자는 이를 고려할 필요가 없습니다. 사용자는 개발자들이 서버에서 처리한 웹페이지를 보기 때문입니다. 또 static site에도 javaScript를 활용해 동적인 처리를 하는 경우도 많아, 칼 처럼 구분지을 필요도 이유도 없을 것 같습니다. ","date":"2021-06-22","objectID":"https://colinder.github.io/django_vs_node.js_%EC%A7%88%EB%AC%B8%EC%9D%84_%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/:0:1","tags":["web"],"title":"Django vs Node.js 질문을 받았습니다.","uri":"https://colinder.github.io/django_vs_node.js_%EC%A7%88%EB%AC%B8%EC%9D%84_%EB%B0%9B%EC%95%98%EC%8A%B5%EB%8B%88%EB%8B%A4/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"​ Collaborative filtering by auto Encoder 협업필터링을 딥러닝 방식의 하나인 오토 인코더로 구현하는데 알아두어야 할 배경지식에 대하여 정리 ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative_filtering_by_autoencoder/:0:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative_filtering_by_autoencoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Machine learning 기계가 명시적으로 코딩되지 않은 동작을 스스로 학습해 수행하게 하는 연구 분야. 인공지능(AI)의 한 분야로 간주된다. 기계 학습의 핵심은 표현(representation)과 일반화(generalization)에 있다. 표현이란 데이터의 평가이며, 일반화란 아직 알 수 없는 데이터에 대한 처리이다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative_filtering_by_autoencoder/:1:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative_filtering_by_autoencoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"What’s the difference with ‘Deep learning’? Machine learning은 어떤 문제와 답을 막 던져주면 기계가 계속 풀어내면서 추상적인 원리를 스스로 깨우치고 새로운 문제가 주어져도 스스로 답을 낼 수 있게 하는 것이다. Deep learning은 Machine learning보다 조금 더 편리?한 방법이라고 할 수 있다. Machine learning의 경우 알고리즘에 입력 하기 전 필요한 특징을 사람이 직접 선정해야 한다. 예를 들어 사람의 나이를 추정한다고 하면, 얼굴의 주름 개수, 피부 색상의 균일도, 특정 주름의 짙은 정도, 머리카락의 색깔과 같이 나이를 추정하는 데에 유용한 ‘특징’을 사람이 알려주어야(선택) 특징을 기준으로 기계가 학습한다. Deep learning의 경우에는 ‘특징’을 선정하는 부분까지 기계가 직접 선택해 학습한다. 머신러닝과 달리 사람 얼굴을 찍은 사진을 입력으로 넣어주면, 스스로 어떤 특징이 나이를 추정하는 데에 유용한지 분석한다. 그런 식으로 사람이 좀 더 손을 대 줘야 하던 부분들을 컴퓨터가 더 많이 처리해주는 편리함이 강점이다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative_filtering_by_autoencoder/:2:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative_filtering_by_autoencoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Collaborative Filtering 많은 사용자들로부터 얻은 기호정보(taste information)에 따라 사용자들의 관심사를 자동적으로 예측하게 해주는 방법이다. 협력 필터링 접근법의 근본적인 가정은 사용자들의 과거의 경향이 미래에서도 그대로 유지 될 것이라는 전제에 있다. 예를 들어, 음악에 관한 협력 필터링 혹은 추천시스템(recommendation system)은 사용자들의 기호(좋음, 싫음)에 대한 부분적인 목록(partial list)을 이용하여 그 사용자의 음악에 대한 기호를 예측하게 된다. 이 시스템은 특정 사용자의 정보에만 국한 된 것이 아니라 많은 사용자들로부터 수집한 정보를 사용한다는 것이 특징이다. 이것이 단순히 투표를 한 수를 기반으로 각 아이템의 관심사에 대한 평균적인 평가로 처리하는 방법과 차별화 된 것이다. 즉 고객들의 선호도와 관심 표현을 바탕으로 선호도, 관심에서 비슷한 패턴을 가진 고객들을 식별해 내는 기법이다. 협업 필터링의 종류에는 Memory-based, Model-based, Hybrid 가 있지만 이중에서 간단하게 구현할 수 있으며, 적당히 합당한 결과를 도출하는 Memory-based 협업 필터링을 사용한다. ​ ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative_filtering_by_autoencoder/:3:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative_filtering_by_autoencoder/"},{"categories":["AI","Collaborative filtering","auto-Encode"],"content":"Auto Encoder 오토인코더(Autoencoder)는 아래의 그림과 같이 단순히 입력을 출력으로 복사하는 신경망. Auto Encoder의 신경망 구조는 input과 output이 동일하며 좌우를 대칭으로 구축된 구조이다. 어떻게 보면 간단한 신경망처럼 보이지만 네트워크(hidden layer)에 여러가지 방법으로 제약을 줌으로써 어려운 신경망으로 만들어 사용한다. 예를들어 아래 그림처럼 hidden layer(회색 동그라미)의 뉴런 수를 input layer(입력층)보다 작게해서 데이터를 압축(차원을 축소)한다거나, 입력 데이터에 노이즈(noise)를 추가한 후 원본 입력을 복원할 수 있도록 네트워크를 학습시키는 등 다양한 오토인코더가 있다. 이러한 제약들은 오토인코더가 단순히 입력을 바로 출력으로 복사하지 못하도록 방지하며, 데이터를 효율적으로 표현(representation)하는 방법을 학습하도록 컨트롤한다. ","date":"2021-06-16","objectID":"https://colinder.github.io/collaborative_filtering_by_autoencoder/:4:0","tags":["AI","Collaborative filtering","auto-Encode"],"title":"Collaborative filtering by auto Encoder","uri":"https://colinder.github.io/collaborative_filtering_by_autoencoder/"},{"categories":["web"],"content":"​ form 태그의 고찰 form tag의 inline 요소 중 **‘action’**과 ‘onsubmit’ \u003cform action=\"/oh my god\" onsubmit=\"return test()\"\u003e \u003cinput type=\"submit\" value=\"hahaha\"\u003e \u003c/form\u003e \u003cscript\u003e function test(){ console.log('HHHI') } \u003c/script\u003e submit 형태의 input을 클릭하게 되면, submit이 동작하면서 form의 ‘onsubmit’이 실행 이후 에 form 태그의 ‘action’이 실행 즉, 두가지의 행동이 실행됩니다. ​ 비효율적이지만, 만약 위와 같은 코드에서 나중에 실행되는 action은 동작하지 않게 하고 싶다면. \u003cform action=\"/oh my god\" onsubmit=\"return test()\"\u003e \u003cinput type=\"submit\" value=\"hahaha\"\u003e \u003c/form\u003e \u003cscript\u003e function test(){ console.log('HHHI') return false; //👈 이것을 넣어줘서 action에 false를 전달해 동작을 막음 } \u003c/script\u003e ​ ","date":"2021-06-10","objectID":"https://colinder.github.io/form/:0:0","tags":["html","web","form"],"title":"form 태그","uri":"https://colinder.github.io/form/"},{"categories":["NLP"],"content":"‘NAVER’ HyperCLOVA의 한국어 모델 2021.05.25 NAVER AI NOW reference 내용 중 HyperCLOVA의 자연어 전처리 과정의 토근화 방법에 대하여 정리 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:0:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"데이터 토큰화 자연어 처리를 위한 문장 데이터 토큰화에 대한 NAVER의 처리 방법을 정리해보겠습니다. 말뭉치를 어떻게 구성하고 나눌 것인가에 대한 고민 → 서브워드 토크나이저를 활용. 서브워드는 어떤방식으로 진행할 것인가? → Byte-Pair Encoding (BPE)를 사용 그 중에서도 Morpheme-Aware Byte-Level BPE (형태소 단위 분리)을 사용 Morpheme-Aware Byte-Level BPE는 많은 메모리를 필요로 하여 말뭉치 데이터의 크기를 최적화하는 것이 필요함. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:1:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"서브워드란? 자연어 처리를 하려면 기계가 문장을 끊어 읽을 수 있게 만들어줘야 합니다. 이를 보통 토크나이징(tokenizing)이라고 하며 나눠진 단어나 형태소를 토큰이라고 합니다. 하지만 토큰은 ‘문장’에서 추출한 데이터고 / ‘문장’은 작성한 사람에 따라 구성이 다르기도 하며, 신조어를 사용하는 등 고려해야하는 사항이 많습니다. 특히 Out of Vocabulary(OOV) 미등록 된 단어의 문제는 자연어 처리에 있어서 해결이 어려운 이슈사항입니다. 그리고 이를 보완하기 위해 Subword 방식이 대두되었습니다. 하나의 단어는 더 작은 단위의 의미있는 여러 서브워드들의 조합으로 구성된 경우가 많기 때문에, 하나의 단어를 여러 서브워드로 분리해서 기계어로 변환하기 위한 작업입니다. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:2:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"BPE(Byte Pair Encoding) BPE은 압축 알고리즘으로 연속적으로 가장 많이 등장한 글자의 쌍을 찾아서 하나의 글자로 병합하는 방식을 수행합니다. # dictionary l o w : 5, l o w e r : 2, n e w e s t : 6, w i d e s t : 3 딕셔너리를 참고로 한 초기 단어 집합(vocabulary)을 아래와 같습니다. 간단히 말해 초기 구성은 글자 단위로 분리된 상태입니다. # vocabulary l, o, w, e, r, n, w, s, t, i, d BPE의 특징은 알고리즘의 동작을 몇 회 반복(iteration)할 것인지를 사용자가 정한다는 점입니다. 여기서는 총 10회를 수행한다고 가정합니다. 다시 말해 가장 빈도수가 높은 유니그램의 쌍을 하나의 유니그램으로 통합하는 과정을 총 10회 반복합니다. 위의 딕셔너리에 따르면 빈도수가 현재 가장 높은 유니그램의 쌍은 (e, s)입니다. 1회 - 딕셔너리를 참고로 하였을 때 빈도수가 9로 가장 높은 (e, s)의 쌍을 es로 통합합니다. # dictionary update! l o w : 5, l o w e r : 2, n e w es t : 6, w i d es t : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es 2회 - 빈도수가 9로 가장 높은 (es, t)의 쌍을 est로 통합합니다. # dictionary update! l o w : 5, l o w e r : 2, n e w est : 6, w i d est : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est 3회 - 빈도수가 7로 가장 높은 (l, o)의 쌍을 lo로 통합합니다. # dictionary update! lo w : 5, lo w e r : 2, n e w est : 6, w i d est : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est, lo 이와 같은 방식으로 총 10회 반복하였을 때 얻은 딕셔너리와 단어 집합은 아래와 같습니다. # dictionary update! low : 5, low e r : 2, newest : 6, widest : 3 # vocabulary update! l, o, w, e, r, n, w, s, t, i, d, es, est, lo, low, ne, new, newest, wi, wid, widest 출처 https://wikidocs.net/22592 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:3:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"Morpheme-Aware Byte-Level Byte Pair Encoding Byte Pair Encoding을 한국어를 형태소 수준으로 나누어 진행 ex) ‘나는 배가고프다.’ → ‘나’, ‘는’, ‘배’, ‘가’, ‘고’, ‘프’, ‘다’. 로 나누어 Byte Pair Encoding을 진행 ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:4:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"서브워드로 나눈 말뭉치의 크기는 얼마나 설정할 것인가? 일반적으로 자연어 말뭉치에 사용된 단어를 빈도순으로 나열했을 경우 지프의 법칙(Zipf’s Law)을 따름. Zipf’s Law : 어떠한 자연어 말뭉치 표현에 나타나는 단어들을 그 사용 빈도가 높은 순서대로 나열하였을 때, 모든 단어의 사용 빈도는 해당 단어의 순위에 반비례한다. 따라서 가장 사용 빈도가 높은 단어는 두 번째 단어보다 빈도가 약 두 배 높으며, 세 번째 단어보다는 빈도가 세 배 높다. 한가지 예로 약 135개 항목의 어휘만으로 브라운 대학 말뭉치의 절반을 나타낼 수 있었다. 1에 따라 네이버는 학습에 사용한 말뭉치 양의 차이에 따른 서브워드 토크나이저의 어위 집합에는 큰 차이가 없을 것으로 판단. 👉 네이버의 경우, 전체 말뭉치와 전체 말뭉치의 1% (20GB)로 서브워드 토크나이저를 실행한 결과를 비교해보니 어휘 집합 구성의 유사함을 확인. ​ ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:5:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["NLP"],"content":"성능 평가 - 언어 생성관점 NAVER는 발전한 대규모 모델의 언어생성능력에 비해 기존의 평가 지표(품질: BLEU, ROUGE, METEOR… / 다양성: Self-BLEU, Distinct-N, Unique-N…)들이 여전이 2000년대 초반에 머물러 있다는 점을 파악 ‘생성 문장’과 ‘레퍼런스 문장’의 유사성이 더 이상 문장의 품질을 보장하지 않는다. 학습 어휘에 따라 성능에 차이가 발생함으로 perplexity(ppL)로 비교하는 것은 부적절하다. 펄플렉서티(perplexity)는 언어 모델을 평가하기 위한 내부 평가 지표. ‘perplexed’는 ‘헷갈리는’과 유사한 의미. 여기서 PPL은 ‘헷갈리는 정도’로 레퍼런스들과의 차이를 판별하는 지표로 이해하면 된다. 👉 네이버의 경우, ‘언어의 유창함’을 판별활 수 있는 모델을 만들어 자체적으로 성능을 평가함. ​ ​ 👀요약 NLP관련 자료와 여러 테스트를 해보니 ‘완벽한 토큰화’가 모델 성능에 큰 영향이 없는 것으로 보입니다. 또한 네이버는 작은 양의 데이터라면서 20GB의 자료를 사용해 학습한 결과를 내보였지만, _약 135개 항목의 어휘만으로 브라운 대학 홈페이지 말뭉치의 절반을 나타낼 수 있다._는 결과를 보며 자연어 처리 모델 학습에 많은 양의 토큰이 필요하지 않겠다는 생각이 들었습니다. 다만, 이번에 개발된 네이버의 자연어 처리기술이 한국어에 있어서는 가장 진보되었고 ‘사람다운’ 처리를 보여주는 것 같습니다 만약 일부라도 오픈소스로 풀린다면 시장에 독점적인 기술이 될 것으로 보입니다. ","date":"2021-05-31","objectID":"https://colinder.github.io/naver_hyperclova/:6:0","tags":["NLP","naver"],"title":"'NAVER AI NOW' HyperCLOVA_NLP","uri":"https://colinder.github.io/naver_hyperclova/"},{"categories":["web"],"content":"​ 웹 개발을 위해 인터넷의 레퍼런스들을 참고하다보면, 눈에 띄는 기호가 있습니다. $ 이게 뭘까요.? 검색해보니 제이쿼리라는데 많이 쓰이는 것 같습니다. 이에 알아봅시다! ​ jQuery란? jQuery(제이쿼리)는 HTML의 클라이언트 사이드 조작(ex. 사용자가 어떤 버튼을 누른다. 사용자가 드랍박스에 선택지를 고른다.)을 단순화 하도록 설계된 크로스 플랫폼(여러 종류의 컴퓨터 플랫폼에서 동작할 수 있다는 것)의 자바스크립트 라이브러리다. 존 레식이 2006년 뉴욕 시 바캠프(Barcamp NYC)에서 공식적으로 소개하였다. 출처: 위키백과 최대한 구체적으로 알아보았는데요. 이 내용이 이해되었다면 다음으로 넘어갑시다. *라이브러리(library): 자주 사용하는 코드들을 재사용할 수 있는 형태로 가공해서 프로그래밍 효율을 높여주는 코드들. ​ jQuery를 왜 알아야 할까? 제가 생각하는 이유는 제이쿼리를 사용하면 짧고 단순한 코드로도 웹 페이지에 다양한 효과나 연출을 적용할 수 있기 때문입니다. 다양한 자바스크립트 라이브러리 중에서도 제이쿼리가 사용되는 이유는 다음과 같습니다. 제이쿼리는 주요 웹 브라우저의 구버전을 포함한 대부분의 브라우저에서 지원됩니다. HTML DOM을 손쉽게 조작할 수 있으며, CSS 스타일도 간단히 적용할 수 있습니다. 애니메이션 효과나 대화형 처리를 간단하게 적용해 줍니다. 같은 동작을 하는 프로그램을 더욱 짧은 코드로 구현할 수 있습니다. ✨레퍼런스가 많습니다.✨ 오픈 라이선스를 적용하여 누구나 자유롭게 사용할 수 있습니다. 개인적으로 특히 5번이 마음에 드는데요. 레퍼런스가 많아야 배우기 수월하다고 생각하기 때문입니다. ​ ​ JQuery의 문법 ​ ​ ","date":"2021-04-29","objectID":"https://colinder.github.io/what_is_jquery/:0:0","tags":["web"],"title":"What is jQuery($)?","uri":"https://colinder.github.io/what_is_jquery/"},{"categories":["Django"],"content":"​ Django Overriding Templates 웹개발을 하다보면 재활용되어야 하는 부분. 즉, 변경되지 않아야 하는 부분과, 변해야 하는 부분이 있습니다. (대표적으로 navbar) 그리고 이런 개발의 편의성을 위해 Django는 Overriding 이라는 기술을 제공합니다. ​ 지난 “app\"에 이어 진행 변경되지 않아야 하는 부분은 그림의 ‘배경’이고, 변해야 하는 부분은 그림의 ‘디테일 요소’라고 생각하면 이해가 쉽습니다. / 그럼 변경되지 않아야 하는 부분을 먼저 제작해봅시다. ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:0","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"1. 변경 하지 않을 부분 == 배경 제작 \u003c!-- /templates/base.html 생성 --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"background-color: green\"\u003e여기는 base.html Overriding templates\u003c/h1\u003e 👈 {% block body %} 👈 body 시작 위치 {% endblock %} 👈 body 종료 위치 \u003c/body\u003e \u003c/html\u003e ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:1","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"2. 배경을 setting.py에 등록 ## blog/setting.py BASE_DIR = Path(__file__).resolve().parent.parent ... ... TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR / 'templates'], # 👈👈 '/'로 구분합니다. 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] ✨Point 1. TEMPLATES정보를 등록하는데, DIRS(디렉토리)가 BASE_DIR부터 'blog', 'templates' 주소 안에 있다.는 뜻. ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:2","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"3. 변해야 하는 부분 == 디테일 요소 제작 \u003c!-- articles/templates/articles/overriding.html 생성 --\u003e {% extends 'base.html' %} 👈 setting.py에서 등록한 templates인 base.html을 불러오겠다. {% block body %} 👈 base.html의 body 시작위치 \u003cdiv\u003e \u003ch1\u003eOverriding 페이지입니다.\u003c/h1\u003e \u003c/div\u003e {% endblock %} 👈 base.html의 body 종료위치 templates설정이 완료되었으니 이제 url을 연결해주어야 합니다. ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:3","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"4. url 설정 도메인 root주소/overriding으로 접속하면 위에서 구현한 화면이 보이도록 만들어 보겠습니다. ## articles/urls.py from django.urls import path, include from . import views urlpatterns = [ path('', views.main), path('overriding/', views.overriding), # 👈 ] ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:4","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"5. views.py 설정 urls.py에서 views의 overriding함수를 실행한다고 구현했으니 overriding함수를 만들어 봅시다. ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') def overriding(request): # 👈 return render(request, 'articles/overriding.html') # 👈 3.에서 만든 overriding.html을 노출 ​ ​ 완성된 화면은 아래와 같습니다. ​ ​ 👀요약 프로젝트를 진행하다 보면, 생각보다 변하지 않아야 하는 부분과, 변해야 하는 부분의 고려가 간단하진 않습니다. 하지만, templates의 재사용성을 높이는 방식으로 개발하는 것이 편리한 경우가 많이 있으니, 잘 알아보고 기획해서 사용하면 좋습니다. ​ ​ ","date":"2021-04-27","objectID":"https://colinder.github.io/django_03_overridingtemplates/:0:5","tags":["Django"],"title":"Django_03_overriding templates","uri":"https://colinder.github.io/django_03_overridingtemplates/"},{"categories":["Django"],"content":"​ Django_form 이제 여러 html파일을 만들어 여러 화면을 돌아다닐 수 있게 되었습니다. 그렇다면 A화면에서 입력한 정보를 B화면으로 가져가고 싶다면 어떻게 해야 할까요? form테그를 사용하면 됩니다. ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:0","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"👨‍💻 개발해봅시다. 기존에 만들었던 main.html을 활용해 만들어 보겠습니다. ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:1","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"1. form 태그 생성 \u003c!-- articles/templates/articles/main.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003emain 페이지 입니다.\u003c/h1\u003e \u003cform action=\"/articles/output\"\u003e 👈 action = form으로 입력된 정보를 보낼 곳입니다. 제목 : \u003cinput type=\"text\" name=\"title\"\u003e 👈 입력된 text타입 정보를 title이라는 이름으로 할당 내용 : \u003cinput type=\"text\" name=\"content\"\u003e 👈 입력된 text타입 정보를 content라는 이름으로 할당 \u003cbutton type=\"submit\" \u003e 제출 \u003c/button\u003e 👈 button을 누르면 form의 action주소로 이동 \u003c/form\u003e 👈 \u003c/body\u003e \u003c/html\u003e ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:2","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"2. urls.py 설정 위에서 articles/output으로 데이터를 보냈으니 ## articles/urls.py from django.urls import path, include from . import views urlpatterns = [ path('', views.main), path('overriding/', views.overriding), path('articles/output/', views.output), 👈 ] ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:3","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"3. views.py 설정 위에서 articles/output/ 로 접속하면 views의 output함수를 동작시킨다고 선언했으니. ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') def overriding(request): return render(request, 'articles/overriding.html') def output(request): 👈 output함수 선언 title = request.GET.get('title') 👈 output함수의 request에서 title항목 추출 content = request.GET.get('content') 👈 output함수에 request에서 content항목 추출 context = { 👈 추출한 두 요소를 context라는 하나로 묶고 'title':title, 👈 'content':content 👈 } 👈 return render(request, 'articles/output.html', context) 👈 render함수의 마지막 인자로 context 전달. ​ ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:4","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"4. output.html 제작 \u003c!-- articles/templates/articles/output.html --\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eoutput 페이지 입니다.\u003c/h1\u003e \u003ch2\u003e{{title}}\u003c/h2\u003e \u003ch3\u003e{{content}}\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e ​ 완성된 화면은 아래와 같습니다. main.html output.html ​ ​ ​ 👀요약 데이터를 주고 난 후 url을 보면 /?title=\"…\"\u0026content=\"…\"의 형태로 구성된 것을 볼 수 있습니다. 이는 앞으로 많이 보게 될 구성이니 익숙해지면 좋습니다. ","date":"2021-04-23","objectID":"https://colinder.github.io/django_04_form/:0:5","tags":["Django"],"title":"Django_04_form","uri":"https://colinder.github.io/django_04_form/"},{"categories":["Django"],"content":"​ Django_app 이번에는 생성된 프로젝트에서 1. app을 추가해 등록해보고 2. 서버 접속시 첫 메인 페이지를 제작해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:0:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"뜬금없이 CRUD를 알아보고 갑시다. CRUD는 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말입니다. 사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신 등) 중 가장 기본이라고 생각되는 기술들입니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"이제 이어서 개발해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:1","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"1. App 생성 지난번에는 프로젝트를 생성하고 setting.py에서 기본 설정만 변경해주었습니다. 이제 app을 생성해봅시다. ## DJ폴더 안에서 django-admin startproject blog / django-admin startproject blog . 두가지 중 ## 후자로 프로젝트를 생성하고 진행하겠습니다. 그러면 폴더 구조가 아래와 같습니다. # DJ # blog # manage.py \u003e python manage.py startapp articles # articles라는 app을 manage.py라는 python파일로 만들겠다. # 입력 후 폴더 구조 # DJ # blog # manage.py # articles 👈👈 ✨Point 1. 명령어는 manage.py가 있는 root폴더안에서 입력해야 합니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:2","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"2. 생성한 app을 프로젝트 폴더(blog)에 등록합니다. ## blog/setting.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'articles', #👈👈 ] 잠시 django의 개발 패턴을 보면 url로 요청을 접수한다는 것을 알 수 있습니다. urls.py로 들어오는 요청을 접수해봅시다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:3","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"3. urls.py 등록 ## blog/urls.py \"\"\"blog URL Configuration The `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/3.2/topics/http/urls/ Examples: Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: path('', views.home, name='home') Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: path('', Home.as_view(), name='home') Including another URLconf 1. Import the include() function: from django.urls import include, path 2. Add a URL to urlpatterns: path('blog/', include('blog.urls')) \"\"\" from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('', include('articles.urls')), #👈👈도메인 ''로 접속시 articles.urls로 요청을 보낸다. ] ✨Point 1. 상단에 주석처리되어있는 내용을 읽어보며, 어떻게 url설정을 하는지 파악하는 것이 중요합니다. 이어서 articles 폴더에 urls.py 파일을 만들고 url을 만들어 줍시다. ## articles/urls.py 생성 from django.urls import path from . import views #👈👈 articles 폴더에 있는 views.py폴더 사용할 수 있게 등록. urlpatterns = [ path('', views.main), #👈👈도메인 ''로 접속시 views에 있는 main함수를 동작한다. ] ✨Point 1. blog/urls → articles/urls → articles/views 로 요청을 전달하는 과정을 이해하는 것이 중요합니다. ​ ​ 이제는 views를 설정합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:4","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"3. articles/views.py 세팅 ## articles/views.py from django.shortcuts import render # Create your views here. def main(request): return render(request, 'articles/main.html') #👈👈 main함수는 render함수를 사용해 인자로 받은 request를 articles/main.html에 담아 사용자에게 보여준다. # 아직 articles/main.html파일이 없습니다. 이제 우리가 사용자에게 응답할 페이지를 만들어야 합니다. ​ ​ 이제 마지막 templates를 설정합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:5","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"4. articles/templates/articles/main.html 생성 ## articles/templates/articles/main.html 생성 # !+tab 하면 html 기본 프레임이 나옵니다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003emain 페이지 입니다.\u003c/h1\u003e #👈👈 \u003c/body\u003e \u003c/html\u003e ​ ​ 완성된 화면은 아래와 같습니다. ​ ​ ​ 👀요약 폴더 구조를 이해하면서 진행합시다! ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:1:6","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"더 알아보기 1️⃣ urls.py를 통해 요청을 전달할때 왜? include를 사용했을까요? django공식문서에는 아래와 같이 설명합니다. ​ 2️⃣ 왜 templates를 만드는데 articles폴더를 안에 하나 더 만들까요? ∴ 이는 1. templates 상속시 오류를 없게 하기 위함과 2. 대규모 프로젝트의 경우 하나의 app안에 다양한 templates 구성이 있는 경우 관리의 편리성 때문입니다. ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:2:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"참고 했던 글 https://senticoding.tistory.com/77 ","date":"2021-04-22","objectID":"https://colinder.github.io/django_02_addapp/:3:0","tags":["Django"],"title":"Django_02_addapp","uri":"https://colinder.github.io/django_02_addapp/"},{"categories":["Django"],"content":"Django 개발환경준비 편리함을 추구하기 위해 AWS Cloud9을 사용하여 진행 https://ide.cs50.io/ 주소로 접속하면 진행이 가능하며, 진행을 위해선 Git 아이디가 있어야 한다. Git? : 버전 관리 시스템이며 Git은 소프트웨어를 개발하는 기업의 핵심 자산인 소스코드를 효과적으로 관리할 수 있게 해주는 무료, 공개소프트웨어. git에 대한 내용은 따로 정리해보도록 한다. 로그인까지 마치면 이제 Django 개발 준비 끝. ​ 👏 21.04.18 기준 django : 3.2 V 으로 다시 정리 합니다. 개발은 로컬(내 PC)진행합니다. ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:0","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"1. DJango 설치 ## 개발을 진행하려는 폴더에서 \u003e pip install django # 설치가 진행될 것입니다. # 저는 DJ라는 폴더를 생성하고 진행하였습니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:1","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"2. 프로젝트 생성 \u0026 구동 확인 ## 1. 프로젝트 생성 # case 1 \u003e django-admin startproject blog # blog라는 root폴더를 만들고 django프로젝트를 시작 # case 2 \u003e django-admin startproject blog . # . 을 붙이면, root폴더 생성없이 django프로젝트 시작 #========================================================================================# ## 2. 프로젝트 구동 테스트 \u003e cd blog # blog 폴더로 \u003e python manage.py runserver 8080 # 프로젝트 구동 / 8080은 생략가능 ✨Point 1. blog라는 이름(root폴더)은 내가 원하는 프로젝트 명으로 변경이 가능 2. cd blog → django의 명령어는 모두 manage.py가 존재하는 폴더안에서 실행해야 함, 이를 위한 이동 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:2","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"3. 기본 설정(setting.py) 등록 # settings.py # 웹 사용자를 특정하는 부분 ALLOWED_HOSTS = ['*'] # '*' == 모든 사용자가 입장가능 # 프로젝트에 사용되는 APP 및 기능들을 등록 INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] ... ... LANGUAGE_CODE = 'ko-KR' #한글로 설정 변경 TIME_ZONE = 'Asia/Seoul' #시간대 서울로 변경 이와 같은 화면이 나오면 Basic Setting 완료입니다. ​ ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:0:3","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"더 알아보기 1️⃣ python manage.py runserver 8080 입력시 붉은 오류가 보일 수 있습니다. ‘python manage.py migrate’를 진행하라는 말 같은데 해당 내용은 나중에 ‘model’이라는 것을 설정할 때 자세히 보겠습니다. django의 공식문서 역시 지금 단계에서는 아래와 같이 안내합니다. ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_01_startproject/:1:0","tags":["Django"],"title":"Django_01_startproject","uri":"https://colinder.github.io/django_01_startproject/"},{"categories":["Django"],"content":"​ Web ? 월드 와이드 웹(World Wide Web)이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미하며, 줄여서 WWW나 W3라고도 부르며, 간단히 웹(Web)이라고 가장 많이 불린다. 인터넷과 같은 의미로 많이 사용되고 있지만, 정확히 말해 웹은 인터넷상의 인기 있는 하나의 서비스일 뿐. Web의 작동방식을 간단히 설명하자면, 요청과 응답. 사용자는 서버에 어떠한 요구사항을 요청하고 서버는 이에 따라 처리결과를 응답한다. 예를들어 사용자가 Login 버튼을 누른 행위는 user가 서버에 로그인 하고 싶다고 요청한 것이며, 서버는 로그인 창을 띄움으로서 user가 로그인할 수 있게 응답한 것입니다. ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:0:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"web Protocal 요청에 대한 응답을 처리할 서버를 만드는 것이 Django ​ Django ? python 기반의 web framework ​ framework? : web 개발시 어려움을 줄이는데 목적이 있는 기능을 통칭 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:1:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"Django의 개발 방식 (MTV) Django의 개발 방식은 MTV(Model, Template, View) 패턴을 따른다. Model: data를 구성 Template: 사용자(User)에서 보여주는 화면을 구성 (HTML로 구현) View: data 처리 및 전달 ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:2:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["Django"],"content":"Django_basic 장고는 하나의 프로젝트 단위로 web을 개발한다. 프로젝트 안에는 여러 app별로 기능을 나누어 구성한다. ​ ex) 회원들 계정을 관리하는 app (accounts) / 게시판을 관리하는 app (articles) 등등 요청은 Url로 접수하고 (ex. 게시판으로 이동하고 싶어 게시판 버튼을 클릭) 접수된 내용을 View에서 처리 (ex. 게시판버튼을 클릭하면 게시판 화면을 사용자에게 보여주게 구성) 처리한 화면을 Template로 꾸며(구성해) 사용자에게 응답 ​ ​ ","date":"2021-04-22","objectID":"https://colinder.github.io/django_00_whatisdjango/:3:0","tags":["Django"],"title":"Django_00_basic","uri":"https://colinder.github.io/django_00_whatisdjango/"},{"categories":["programmers"],"content":"​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:0","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"타겟 넘버 numbers = [1, 1, 1, 1, 1] target = 3 # return = 5 from itertools import product l = [(-number, number)for number in numbers] s = list(map(sum, product(*l))) print(s.count(target)) ## 미쳤다. product().. ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:1","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"K번째 수 array = [1, 5, 2, 6, 3, 7, 4] commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]] def solution(array, commands): answer = [] for _ in commands: i, j, k = _ q = array[i-1: j] q.sort() answer.append(q[k-1]) return answer print(solution(array, commands)) ​ ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:2","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["programmers"],"content":"다리를 지나는 트럭 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 from collections import deque truck_weights = deque(truck_weights) bridge = deque([0 for _ in range(bridge_length)]) time = 0 bridge_weight = 0 #현재 다리를 건너고 있는 무게 # bridge = [0, 0] while(len(bridge)) != 0 out = bridge.popleft() bridge_weight -= out time += 1 if truck_weights: if bridge_weight + truck_weights[0] \u003c= weight: left = truck_weights.popleft() bridge_weight += left bridge.append(left) else: bridge.append(0) ## 다리가 지나는 위치를 bridge로 표현하고 디큐를 이용해 속도를 올린다. ","date":"2021-04-21","objectID":"https://colinder.github.io/pg_21.04.21/:0:3","tags":["programmers"],"title":"programmers_21.04.21","uri":"https://colinder.github.io/pg_21.04.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SW Expert Academy"],"content":"D4_11316_주기 찾기 for T in range(int(input())): s, p, q, m = map(int, input().split()) V = s visited = [0]*m i = 1 while True: V = (p*V + q) % m i += 1 if visited[V] != 0: result = i - visited[V] break visited[V] = i print(f'#{T+1} {result}') # 한 번 나왔던 숫자의 '위치 정보(i)'를 # visited에 저장해 두었다가 # 한 번이라도 방문했던 숫자가 나왔을 때 # 저장해주었던 '위치 정보'의 차리를 계산해 준다. # 코딩중. # 만약 [6,8,6,4,3,5,4,3,5,4,3,5...] 경우가 있을 수 있나? 는 고민으로 # 시간을 썼으나. # 문제 조건 중 # 슈도랜덤 제너레이터의 주기란, # 어떤 정수 n0 이상인 '모든 n에 대해' An+p = An을 만족하는 가장 작은 자연수 p # 라는 내용을 보고, 반복되는 수의 등장은 동일 배열 순환의 시작이라고 파악해야 했다. ​ ","date":"2021-04-04","objectID":"https://colinder.github.io/sw_21.04.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 11316","uri":"https://colinder.github.io/sw_21.04.04/"},{"categories":["SQLD"],"content":"​ # SQLD 제2 장 데이터 모델과 성능 ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:0:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"제1 절 성능데이터모델링의 개요 성능데이터모델링의 정의 데이터 용량이 커질수록 처리 속도 증가가 필요해진다. 성능 저하의 대표적인 원인 3가지 데이터 모델 구조에 의해 성능 저하 데이터가 대용량이 됨으로 인해 성능 저하 인덱스 특성을 고려하지 않고 생성해 성능 저하 즉, 어떤 작업 유형에 따라 성능향상을 도모해야 하는지 목표를 분명하게 해야 정확한 성능향상 모델링을 할 수 있다. ​ 성능데이터모델링 수행 시점 사전에 할수록 비용이 줄어들며, 특히 분석/설계단계에서 데이터베이스 처리 성능을 향상시킬 수 있는 방법을 고려하면 좋다. ​ 성능데이터모델링 고려사항 데이터 모델링을 할 때 정규화를 정확하게 수행한다. 데이터베이스 용량산정을 수행한다. 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다. 용량과 트랜잭션의 유형에 따라, 반정규화를 수행한다. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등을 수행한다. 성능관점에서 데이터 모델을 검증한다. ​ ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:1:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"제2 절 정규화와 성능 정규화를 통한 성능 향상 전략 정규화는 기본적으로 데이터에 대한 중복성을 제거하고, 데이터가 관심사별로 처리되는 경우가 많아 대부분 성능을 향상시키는 특징이 있다. 다만, 성능을 판단할 때 (조회)와 (입력,수정,삭제) 두 부류로 구분하여 고려한다. “엔터티가 많은 경우” 다량의 JOIN이 발생하고 그런 경우 보통 (조회) 성능은 하락하고 / (입력,수정,삭제) 성능은 향상된다. 1차 정규화 : table의 cell값은 원자 값을 가져야한다. == 중복된 값을 제거 or 분할. (row, column 모두) 행(row) 정규화 1차 정규화 전\rstudent age subject 보리 1 수학, 과학 쌀 2 수학 수수 3 수학 1차 정규화 후\rstudent age subject 보리 1 수학, 과학 보리 1 과학 쌀 2 수학 수수 3 수학 ​ 열(column) 정규화 ​ ​ 2차 정규화 : 테이블의 부분함수적 종속 제거 == 테이블 값이 완전 함수적 종속인지 확인해야 한다. *완전 함수적 종속 : 기본키가 아닌 컬럼중에 특정 기본키에만 종속하는 부분적 종속이 없는 상태. 1차 정규화가 된 table에서 기본키는 (student, subject). 그 이유는 학생과 과목을 알아야 레코드를 구분할 수 있기 때문이다. 그렇다면 기본키가 아닌 age속성은 student와 subject 두 개의 속성 모두에 종속인지 확인해보면 된다. age속성는 student에만 종속되어있기 때문에 2차 정규화의 조건인 완전함수적 종속에 위배된다. 즉, age 속성은 student 의 이름만 알아도 찾을 수 있는 속성 ​ 2차 정규화 전\rstudent age subject 보리 1 수학, 과학 보리 1 과학 쌀 2 수학 수수 3 수학 ​ 2차 정규화 후\r*학생 테이블 student age 보리 1 쌀 2 수수 3 *과목 테이블 student subject 보리 수학 보리 과학 쌀 수학 수수 수학 ​ ​ 3차 정규화 : 기본키를 제외한 속성들 간의 이행적 함수 종속이 없는 경우 *이행적 함수 종속 : 기본키를 제외한 다른 속성이 특정 속성을 결정지으면 안된다는 것 ​ 3차 정규화 전\r학생id 학생이름 생년월일 주소 시 동 구 와 같이 컬럼이 있을 때 “주소“만 알면 “시”, “동”, “구\"도 알 수 있다. 3차 정규화 후\r*학생 테이블 학생id 학생이름 생년월일 주소 *주소 테이블 주소 시 동 구 위 테이블 처럼 주소속성으로 구분지어 정규화 한다. ​ 정규화를 한다고 해서 무조건 (조회)성능이 하락하는 것도 아니다. 성능에 대한 이슈는 어떻게 테이블을 구성할 것이며, 어떤 데이블 들이 있는지 등 고려해야하는 사항이 많다. 즉 함수의 종속성(Functional Dependency)에 근거한 정규화 수행이 필요하다. 함수의 종속성(Functional Dependency) - ex) 2차 정규화 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭. 이때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다. ","date":"2021-04-02","objectID":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/:2:0","tags":["SQLD"],"title":"04_SQLD_제1 절 성능데이터모델링의 개요 \u0026 제2 절 정규화와 성능","uri":"https://colinder.github.io/04_sqld_%EC%A0%9C2-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EC%84%B1%EB%8A%A5/"},{"categories":["SQLD"],"content":"​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:0:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["SQLD"],"content":"제4 절 관계(Relationship) 관계의 개념 관계의 정의 “인스턴스 사이의 논리적인 연관성으로서 존재의 형태 or 행위로서 서로에게 연관성이 부여된 상태” 관계의 페어링 “관계는 인스턴스가 개별적으로 관계를 가지는 것(페어링)이고, 이것의 집합을 관계로 표현하는 것” “따라서 개별 인스턴스가 각각 다른 종류의 관계를 가지고 있다면, 두 엔터티 사이에 두 개 이상의 관계가 형성될 수 도 있다.” ​ 관계의 분류 ERD : 존재의 의한 관계 / 행위에 의한 관계 UML(Unified Modeling Language) : 연관 관계 / 의존 관계 ​ 관계의 표기법 관계명(Membership) : 관계의 이름을 기록 관계차수 : 엔터티간의 관계에서 참여자의 수를 표현 1 : 1 1 : N N : N 관계선택사양 필수 관계(Mandatory) ex) 지하철은 반드시 문이 닫혀야, 출발할 수 있다. 에서 “문 닫힘” \u0026 “출발” 은 필수참여관계(Mandatory)이다. 선택 관계(Optional) ex) 지하철의 출발을 알리는 안내음성이 나온다. 에서 “안내음성\"은 나오면 좋지만 “출발\"과 필수적인 관계는 아닌 선택적인(Optional) 관계이다. ​ 관계의 정의 및 읽는 방법 관계 체크사항 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가? 두 개의 엔터티 사이에 정보의 조합이 발생하는가? 업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가? 업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가? 관계 읽기 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다. 대상(Target) 엔터티의 관계참여도 단수, 복수로 읽는다. 관계선택사항과 관계명을 읽는다. ​ ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:1:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["SQLD"],"content":"제5 절 식별자(Identifiers) 식별자(Identifiers) 개념 엔터티를 대표할 수 있는 속성 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다. 식별자는 엔터티내에서 인스턴스들을 구분할 수 있는 구분자다. ​ 식별자의 특징 주식별자 유일성 : 주식별자에 의해 엔터티내에 모든 인스턴스들이 유일하게 구분되어야 한다. 최소성 : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다. 불변성 : 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다. 존재성 : 주식별자로 지정되면 반드시 값이 들어와야 한다. 외부식별자 참조무결성 제약조건(Referential Integrity)에 따른 특징을 가진다. ​ 식별자의 분류 및 표기법 식별자 분류 주식별자 : 엔터티 내에서 대표성을 가지는 식별자 (대표성이 있어 참조 연결 가능) 보조식별자 : 엔터티 내에서 대표성을 가지지 않는 식별자 (대표성이 있어 참조 연결 불가능) 내부식별자 : 엔터티 내에서 스스로 생성된 식별자 외부식별자 : 타 엔터티와의 관계를 통해 받아오는 식별자 단일식별자 : 하나의 속성으로 구성된 식별자 복합식별자 : 둘 이상의 속성으로 구성된 식별자 본질식별자 : 원래 있던 식별자 (업무에 의해 만들어지는 식별자) 인조식별자 : 새롭게 만든 식별자 (인위적으로 만든 식별자) 식별자 표기법 ​ 주식별자 도출 기준 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다. 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면, 주식별자로 지정하지 않는다. (차라리 새로 생성!) 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다. ​ 식별자관계와 비식별자관계에 따른 식별자 구분 식별자관계 or 비식별자관계의 결정방법 부모엔터티 쪽의 주식별자를 자식엔터티의 속성으로 내려 보낸다. 이때 자식엔터티는 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 써도 되며 ( == 식별자 관계), 단순히 부모와 연결되는 속성으로만 이용 ( == 비식별자 관계) 할 것인지 결정한다. 이때 외부식별자는 Foreign Key 역할을 한다. 식별자 관계 → 부모엔터티로 부터 속성을 받고, 이를 자식엔터티에서 주식별자로 사용 하는 경우 - 식별자 관계 부모로 부터 받은 속성을 자식이 주식별자로 사용하면 / 부모와 자식의 관계는 1:1 A부모 엔터티로부터 받은 속성a와 B부모 엔터티로부터 받은 속성b를 포함하거나 / 스스로 가지고 있는 속성과 함께 주식별자를 구성하면 / 부모와 자식의 관계는 1:M 비식별자 관계 → 부모엔터티로 부터 속성을 받았지만, 자식엔터티에서 주식별자가 아닌 일반 속성으로 사용하는 경우 - 비식별자 관계 식별자 관계로만 설정할 경우 문제점 주식별자의 속성이 지속적으로 증가하는 경우 - 복잡성↑ 하고 오류가능성 유발 비식별자 관계로만 설정할 경우 문제점 상속의 개념이 없어, 쓸데없이 부모엔터티까지 찾아가서 데이터를 관리해야 하는 경우 발생 식별자관계 \u0026 비식별자관계 모델링 비식별자관계 선택 프로세스 → 선택적으로 식별자, 비식별자를 구성 (난이도가 높다.) 식별자와 비식별자관계 비교 식별자와 비식별자를 적용한 데이터 모델 (예시) ​ ​ ","date":"2021-03-28","objectID":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/:2:0","tags":["SQLD"],"title":"03_SQLD_제4 절 관계 \u0026 제5 절 식별자","uri":"https://colinder.github.io/03_sqld_%EC%A0%9C4-%EC%A0%88-%EA%B4%80%EA%B3%84-%EC%A0%9C5-%EC%A0%88-%EC%8B%9D%EB%B3%84%EC%9E%90/"},{"categories":["git"],"content":"​ Git LFS(Large File Storage) 사용법 Git은 개당 파일에 100MB의 용량 제한이 걸려 있다. (전체 용량 제한은 없다.) 다만, 프로젝트를 하다보면 대용량의 자료나 파일이 생기는 경우가 있다. 이때 용량 제한의 문제를 해소할 수 있는 방법이 LFS이다. LFS는 별도로 설치하여 사용하면 되며, 방법을 정리한다. *주소: https://git-lfs.github.com ​ git LFS을 다운을 받고 설치 합니다. ​ git LFS를 적용할 폴더로 이동해 다음 명령어를 입력합니다. $ git lfs install ​ git LFS로 관리할 파일을 지정해줍니다. // mp4 확장자 모두를 lfs로 관리 $ git lfs track \"*.mp4\" // 특정 파일만 lfs로 관리 (예시) $ git lfs track \"video/hahaha.mp4\" ​ 해당 경로의 설정을 저장할 .gitattributes 파일을 추가 합니다. $ git add .gitattributes ​ 이후로는 평소 git을 사용하는 것처럼 commit / push하면 됩니다. ​ 끝 ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/git_lfslarge-file-storage/:0:0","tags":["git","LFS"],"title":"Git_LFS","uri":"https://colinder.github.io/git_lfslarge-file-storage/"},{"categories":["git"],"content":"🙂부록 *혹시 LFS를 풀고 싶다면 LFS설정한 폴더로 가서 아래 명령어를 입력하면 됩니다. $ git lfs uninstall ​ *또 LFS없이 대용량 파일을 올리려고 하면 오류가 발생하는데, 잘 보면 LFS를 소개 해줍니다. ​ ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/git_lfslarge-file-storage/:1:0","tags":["git","LFS"],"title":"Git_LFS","uri":"https://colinder.github.io/git_lfslarge-file-storage/"},{"categories":["SQLD"],"content":"​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:0:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SQLD"],"content":"제2 절 엔터티(Entity) 엔터티의 개념 실체, 객체 / 실무적으론는 앤터티라고 부른다. 즉 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것 ​ 엔터티와 인스턴스에 대한 내용과 표기법 ​ 엔터티의 특징 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다. 유일한 식별자에 의해 식별이 가능해야 한다. 영속적으로 존재하는 인스턴스의 집합이어야 한다. (반드시 ‘두 개 이상’) 엔터티는 업무에 이용되어야 한다. 엔터티는 반드시 ‘두 개 이상’의 속성을 갖는다. 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다. ​ 엔터티의 분류 우뮤형에 따른 분류 - 유형, 개념, 사건엔터티 발생시점에 따른 분류 - 기본(키), 중심, 행위엔터 스스로 생성할 수 있는지에 따라 - 독립, 의존 엔터티 ​ 엔터티의 명명 현업 업무에서 사용하는 용어를 사용 약어를 가능하면 사용하지 않는다. 단수 명사를 사용 모든 엔티티명은 유일해야 함 엔티티 생성 의미대로 이름을 부여 ​ ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:1:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SQLD"],"content":"제3 절 속성(Attribute) 속성의 개념 업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 즉, 속성이란 의미상 더 이상 분리되지 않으며, 엔터티를 설명하는 요소이며, 인스턴스의 구성요소이다. 엔터티, 인스턴스, 속성, 속성값 엔터티, 인스턴스, 속성, 속성값의 관계 한 개의 엔터티는 두 개 이상의 인스턴스 집합이어야 한다. 한 개의 엔터티는 두 개 이상의 속성을 갖는다. 한 개의 속성은 한 개의 속성값을 갖는다. 속성의 표기법 IE 표기법 Barker 표기법 ​ 속성의 특징 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다. 정규화 이론에 근간하여 정해진 주식별자에 함수 종속성을 가져야 한다. 한 개의 속성은 한 개의 속성값을 갖는다. 만약 한 개의 속성에 여러 속성값을 갖는 다중 값일 경우 별도의 엔터티로 분리하여 관리한다. ​ 속성의 분류 속성의 특성에 따른 분류 기본속성 업무로부터 추출한 모든 속성 설계속성 기본속성 외에 새롭게 만들거나 변형하여 정의한 속성 파생속성 타 속성에 의해 지속적으로 영향을 받아 값이 변하는 성질을 가지고 있는 속성 파생속성은 그 속성이 가지고 있는 계산방법에 대해 반드시 어떤 엔터티에 어떤 속성에 의해 영향을 받는지 정의가 되어야 한다. 파생속성은 꼭 필요한 경우에만 정의하여 업무로직이 속성내부로 스며들지 못하도록 주의해야 한다. 파생속성을 정의한 경우라면 그 값의 정합성을 유지할 수 있도록 해야 한다. 주로 통계관련 엔터티, 배치작업 수행 관련에 사용된다. ​ 엔터티 구성방식에 따른 분류 PK(Prime Key) == 엔터티를 식별할 수 있는 고유한 속성 FK(Foreign Key) == 다른 엔터티와의 관계로, 연결된 속성 일반 속성 == 엔터티에 포함되어 있고, PK, FK가 아닌 속성 추가로 의미를 쪼갤 수 있는지에 따라 단순형, 복합형으로 분류할 수 있다. 한 속성에 한 개의 값 → 단일값(Single Value) 한 속성에 여러 개의 값 → 다중값(Multi Value) ​ 도메인(Domain) 각 속성이 가질 수 있는 값의 범위 (일종의 테이터 타입, 크기, 제약사항등을 지정하는 것) ex) ‘‘학점’‘이라는 ‘‘도메인’‘은 0 \u003c= X \u003c= 4.5 ​ 속성의 명명(Naming) 가급적 현업에서 사용하는 이름을 부여한다. 서술식 속성명은 사용하지 않는다. 약어사용은 자제한다. 전체 데이터모델에서 유일성을 확보하는 것이 좋다. ","date":"2021-03-25","objectID":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/:2:0","tags":["SQLD"],"title":"02_SQLD_제2 절 엔터티 \u0026 제3 절 속성","uri":"https://colinder.github.io/02_sqld_%EC%A0%9C2-%EC%A0%88-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%A0%9C3-%EC%A0%88-%EC%86%8D%EC%84%B1/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11445_무한 사전 for T in range(int(input())): P = input().rstrip() Q = input().rstrip() if P + \"a\" != Q: result = \"Y\" else: result = \"N\" print(f'#{T+1} {result}') # 왜 D3 인가. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11387_몬스터 사냥 for T in range(int(input())): D, L, N = map(int, input().split()) result = 0 for i in range(N): result += D * (1 + L*i/100) print(f'#{T+1} {int(result)}') ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11285_다트 게임 table = [20, 40, 60, 80, 100, 120, 140, 160, 180, 200] value = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] for T in range(int(input())): result = 0 for i in range(int(input())): x, y = map(int, input().split()) dis = (x**2 + y**2)**0.5 for i, v in zip(table, value): if dis \u003c= i: result += v break print(f'#{T+1} {result}') # (오답 : 10000개의 테스트케이스 중 4344개가 맞았습니다.) # 제한시간 초과가 발생하였습니다. ## python으론 안되나...... ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SW Expert Academy"],"content":"D3_11315_오목 판정 def check(x, y): global result # 가로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+i][y+j] if total == 5: result = \"YES\" return # 세로 검사 for i in range(5): total = 0 for j in range(5): total += arr[x+j][y+i] if total == 5: result = \"YES\" return # 좌상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+i] if total == 5: result = \"YES\" return # 우상 대각선 검사 total = 0 for i in range(5): total += arr[x+i][y+4-i] if total == 5: result = \"YES\" return for T in range(int(input())): N = int(input()) arr = [] # 돌이 있으면 1, 없으면 0 for _ in range(N): C = input() NC = [] for i in C: if i == \".\": NC.append(0) else: NC.append(1) arr.append(NC) result = \"NO\" for x in range(N-4): for y in range(N-4): check(x, y) print(f'#{T+1} {result}') # 스마트해 보이진 않는다. ​ ","date":"2021-03-24","objectID":"https://colinder.github.io/sw_21.03.24/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 11445, 11387, 11285, 11315","uri":"https://colinder.github.io/sw_21.03.24/"},{"categories":["SQLD"],"content":"​ SQLD를 준비하면서 공부한 내용을 정리. ​ # SQL 제1 장 데이터 모델링의 이해 ","date":"2021-03-21","objectID":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/:0:0","tags":["SQLD"],"title":"01_SQLD_제1 절 데이터 모델링의 이해","uri":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/"},{"categories":["SQLD"],"content":"제1 절 데이터 모델링의 이해 모델링의 이해 모델링의 정의 복잡한 “현실세계\"를 단순화(추상화)시켜 표현 사물 또는 사건에 관한 양상(Aspect)이나 관점(Perspective)을 명확하게 하는 것 특징 3가지 추상화 - 현실세계를 일정한 형식에 맞추어 표현하는 것 단순화 - 복잡한 현실세계를 약속된 규약에 의해 쉽게 이해할 수 있게 표현하는 것 명확화 - 누구나 이해할 수 있도록 명확하게 표기하는 것 모델링의 3가지 관점 데이터 관점 - 업무 \u0026 데이터, 데이터 \u0026 데이터간의 관계가 무엇인지 표기(What, Data) 프로세스 관점 - 업무가 실제하고 있는 일 또는 무엇을 해야하는지 표기(How, Process) (프로세스\u0026데이터) 상관 관점 - 업무 처리 방법에 따라 데이터가 받는 영향을 표기(Interaction) ​ 데이터 모델링의 기본개념 이해 데이터 모델링의 정의 업무상 필요한 데이터를 일정한 표기법으로 표현함으로써 필요한 정보를 용이하게 분석할 수 있고, 정리된 데이터로 개발 및 데이터관리를 용이하게 하기 위함 ∴ 데이터 모델링 자체로서 업무를 설명하고 분석하는 부분에도 매우 중요한 의미가 있음 ​ 데이터 모델링의 중요성 및 유의점 중요성 (중요한 이유) 파급효과 향상, 간결한 표현, 데이터품질 향상 유의점 중복 - 데이터 베이스가 여러 장소에 같은 정보를 저장하지 않도록 유의. 비유연성 - 데이터의 정의를 데이터 사용 프로세스와 분리. 비일관성 ( ≒ 모순) - 연관되어 있는 데이터는 같이 관리될 수 있도록 유의. ​ 데이터 모델링의 3단계 개념적 데이터 모델 - 추상화 수준이 높고, 업무 중심적이며, 포괄적인 수준의 모델링 논리적 데이터 모델 - 모델링하고자하는 업무에 대해 Key, 속성, 관계 등을 구현. (높은 재사용) 물리적 데이터 모델 - 실제 DB에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려해 진행 ​ 프로젝트 생명주기에서 데이터 모델링 이론 : 계획단계 → (분석) 개념적모델링 → (설계) 논리적 모델링 → (구현)물리적 모델링 실제 : 계획단계 → (분석) 개념 + 논리적 모델링 → (설계 \u0026 구현) 물리적 모델링 ​ 데이터 모델링에서 데이터 독립성의 이해 데이터 독립의 필요성 - 유지보수비용 절감, 데이터복잡도 하락, 중복데이터 감소 등. DB의 3단계 구조 데이터 독립성 요소 외부스키마 - 사용자 개개인이 보는(접근하는) DB를 정의 개념스키마 - 모든 사용자 관점을 통합한 조직 전체 DB를 정의. 내부스키마 - 물리적 장치에 데이터가 실제로 저장되는 구조를 정의. * 스키마: 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조 두 영역의 데이터독립성 논리적 독립성 - 개념스키마가 변경되어도 외부스키마에는 영향을 미치지 않도록. 물리적 독립성 - 내부스키마가 변경되어도 외부/개념스키마는 영향을 받지 않도록. ∴ 외부 / 개념 / 내부 스키마의 독립성을 강조하지만, 이들이 분리되어 관리된다는 의미는 아니다. 이를 사상(Mapping)이라고 말하며, “상호 독립적인 개념을 연결시켜주는 다리” 정도로 이해하면 된다. ​ 데이터 모델링의 중요한 세 가지 개념 업무가 관여하는 어떤 것(Thing) 어떤 것이 가지는 성격(Attributes) 업무가 관여하는 어떤 건 간의 관계(Relationships) ​ 데이터 모델 표기법과 ERD의 이해 데이터 모델 표기법 1976년 피터첸이 Entity-Releationship model(E-R Model)이라는 표기법을 만듦 ‘‘엔터티\"라는 것을 사각형으로 표현, 관계를 마름모, 속성을 타원형으로 표현 ERD(Entity Relationship Diagram) 모델링 작업 순서 엔터티를 그린다. → 엔터티를 적절하게 배치한다. → 엔터티간의 관계를 설정한다. → 관계명을 기술한다. → 관계의 참여도를 기술한다. → 관계의 필수여부를 기술한다. ​ 좋은 데이터 모델의 요소 완전성 - 모든 데이터가 데이터 모델에 정의 되어 있어야 한다. 중복배제(정규화) - 하나의 DB 안에 동일한 사실은 반드시 한 번만 기록되어 있어야 한다. 명확한 업무규칙 기술 및 공유 데이터 재사용성 고려 - 데이터가 어플리케이션에 대해 독립적으로 설계되어야만 재사용성↑ 의사소통 - 데이터를 분석하는 과정에서 나오는 규칙들에 대한 이해가 표현되어야 좋다. 통합성 - 중복배제(정규화)를 이루기 위해 데이터 모델들은 통합적으로 관리되어야 한다. ​ *계속 ","date":"2021-03-21","objectID":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/:1:0","tags":["SQLD"],"title":"01_SQLD_제1 절 데이터 모델링의 이해","uri":"https://colinder.github.io/01_sqld_%EC%A0%9C1-%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81%EC%9D%98-%EC%9D%B4%ED%95%B4/"},{"categories":["Python"],"content":"​ Python Library 😀 ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"Idea # 모두 '거짓'이 들어있는 리스트는 '거짓'으로 볼 수 있지 않을까? # 라고 생각해봤다. a = [False, False, False] if a == False: print(\"거짓\") else: print(\"오류\") # \u003e\u003e\u003e 오류 # 안된다. 생각을 말아라..ㅎㅎ ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"raise 예외(‘에러메시지’) # python에서는 의도적으로 오류를 일으킬 수 있는데 # 이를 해주는 것이 raise 메서드. try: x = 2 if x % 3 != 0: raise Exception('3의 배수가 아닙니다.') print(\"입력된 값\", x) except Exception as e: print('예외가 발생했습니다.', e) \u003e\u003e\u003e 예외가 발생했습니다. 3의 배수가 아닙니다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"filter() VS find() ## filter(function, iterable) # 배열의 `모든 요소`에 접근하여 조건에 맞는 `값`을 찾는다. # ex) def func(x): if x \u003e 0: return x else: return None list(filter(func, range(-5,10))) \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # ex) [ i for i in range(-5,10) if i \u003e 0 ] \u003e\u003e\u003e [1, 2, 3, 4, 5, 6, 7, 8, 9] # find(sub[, start[, end]]) # 배열을 순회하면서 찾으려 하는 값의 `index`를 반환 해준다. # ex) a = 'hello' a.find('o') # find 함수 \u003e\u003e\u003e 4 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:3","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"index() VS find() ## 공통점 # 두 함수 모두 찾으려 하는 값의 `index`를 반환 해준다. # ex) \u003e\u003e\u003e 'oxoxoxoxox'.find('x') # find 함수 1 \u003e\u003e\u003e 'oxoxoxoxox'.index('x') # index 함수 1 # 문자 'o'가 첫번째 위치한 자리를 출력 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o') # find 함수 4 \u003e\u003e\u003e a.index('o') # index 함수 4 # 또 (value, start, end) 형태로 문자를 찾는 시작점과 종료점을 지정할 수 있다. # 문자열중 2번째 위치부터 처음 'x'가 위치한 자리 \u003e\u003e\u003e 'oxoxoxoxox'.index('x', 2) 3 # a변수에서 1번째~3번째 사이에 문자 'o'가 위치한 자리 \u003e\u003e\u003e a = 'hello' \u003e\u003e\u003e a.find('o', 1, 3) -1 # find함수는 찾는 값이 없을 때 -1을 출력한다. 이게 차이점. ## 차이점 # 찾으려는 값이 없는 경우 find()는 '-1'을 반환 / index()는 'ValueError' 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:4","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"deque # deque는 기본적으로 리스트를 변형(ex. pop() ...)하며 코딩할 때 # 속도가 빠르기 때문에 사용한다. # 주로 popleft()를 사용하지만, 유용한 기능이 더 있다. ## 1. rotate from collections import deque q = deque([1,2,3,4,5,6]) q.rotate(3) print(q) # deque([4, 5, 6, 1, 2, 3]) # 주로 리스트의 끝이 붙어 있는 원순열 문제를 해결하는데 편리하다. # 다만 속도가 어떤지는 잘 모르겠다. ## 2. deque는 슬라이싱이 되지 않는다. # 굳이 해야 한다면 아래를 참고 deque_slice = collections.deque(itertools.islice(my_deque, 10, 20)) # deque는 # index()는 '사용가능'하고 find()는 '사용불가'하다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:5","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"q[len(q)-1] VS q[-1] 속도 비교 import time start = time.time() # 시작 시간 저장 ... ... print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. # 왜..? ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:6","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"isalpha(), isdigit() # 알파벳이냐?, 숫자형이냐? 를 참, 거짓 형태로 반환 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:7","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sys.setrecursionlimit(최대 재귀 깊이 설정) # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:8","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"sorted() sorted는 여러 그룹의 값이 주어진 경우 ## 순차적으로 증감을 비교해 준다. # ex) A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] A = sorted(A) print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ## 만약 주어진 두번째 인자들을 기준으로 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: L[1]) print(B) # [(1, -1), (2, 2), (1, 2), (3, 3), (0, 4)] ## 두번째 인자 우선 기준 후 첫번째 인자 기준 정렬하고 싶다면? A = [(0, 4), (2, 2), (1, 2), (1, -1), (3, 3)] B = sorted(A, key=lambda L: (L[1], L[0])) print(B) # [(1, -1), (1, 2), (2, 2), (3, 3), (0, 4)] ## set자료형을 sorted 하면 자동으로 list type으로 변환된다. a = {\"a\",\"b\",\"C\"} print(\"a의 타입: \",type(a)) # a의 타입: \u003cclass 'set'\u003e b = sorted(a) print(\"b의 타입: \", type(b)) # b의 타입: \u003cclass 'list'\u003e ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:9","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"from collections import Counter 주어지는 컨테이너(ex 리스트 자료형, string)에 동일한 값의 갯수를 파악 from collections import Counter MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() print(MoResult) #[(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() 함수 # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:10","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import sys 빠른 속도로 입력받기 위한 라이브러리 imput VS sys.stdin.readline() # python의 대표적인 입력 함수 imput() # 단, 백준에는 더 빠른 방법이 초기에 설명되어있다. import sys sys.stdin.readline() # 단 위와 같이 입력 받은 경우, 마지막에 개행 문자까지 입력되어 뒤에 # 추가 함수(rstrip())를 붙여 사용하는 것이 보통이다. ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:11","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"정규표현식 일대일 매칭되는 문자 정규표현식 안에서, 바로 다음 절에서 설명하는 메타문자를 제외한 모든 문자 하나는 일반 문자열 하나와 매칭된다. 예를 들어, a는 a와 매칭되고, 가는 ‘가’와 매칭되는 식이다. 당연히 a가 ‘b’ 또는 ‘가’와 매칭되지는 않는다. 어떤 프로그래밍 언어의 정규표현식이든 메타문자(특수한 기능을 하는 문자)라는 것이 존재한다. 파이썬 re 모듈의 메타문자는 총 12개로 다음과 같은 것들이 있다. $()*+.?[^{| 이들 메타문자는 각각의 문자 하나에 매칭되지 않는다. 예를 들어 일반 문자인 a는 문자 ‘a’에 매칭하지만, 여는 소괄호 (는 문자 ‘(‘와 매칭하지 않는다. 그럼 찾고자 하는 문자열에 소괄호가 있으면 어떻게 할까? 위의 문자들의 앞에 백슬래시 \\를 붙여 주면 일반 문자처럼 한 글자에 매칭된다. 예를 들어 \\(는 문자 ‘(‘와 매칭된다. ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:12","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"find(찾을문자, 찾기시작할위치) - 찾는 값의 인덱스를 반환 s = '가나다라 마바사아 자차마타 파하' print(s.find('마')) # s에서 첫'마'의 인덱스를 반환 print(s.find('마', 3)) # s[3:]부터 첫'마'의 인덱스를 반환 (전체 범위 기준) print(s.find('가', 2)) # s[2:]부터 첫'가'의 인덱스를 반환 (없으면 -1 반환) 5 5 -1 ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:13","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"startsWith(찾을문자, 찾기시작위치, 찾기종료위치) str = \"this is string\"; print(str.startswith('this')) # str맨앞이 'this'로시작하는지 검사 print(str.startswith('is', 2, 4)) # str[2:4]에서 맨앞이 'is'인지 검사 print(str.startswith('this', 3, 4)) # str[3:4]에서 맨앞이 'this'인지 검사 True True False ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:0:14","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"import itertools (효율적인 반복을 위한 함수) ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:0","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"permutations(자료, 만들순열길이) n개의 원소를 사용해서 순서를 정하여 r개의 배열로 나타내는 것 =\u003e 순열 공식 : nPr = n!/(n-r)! import itertools a = [1,2,3] permute = itertools.permutations(a,2) print(list(permute)) a = \"abc\" permute = itertools.permutations(a,2) print(list(permute)) [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')] ​ ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:1","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["Python"],"content":"combinations(조합) n개의 원소를 사용해서 순서의 관계없이 r개의 배열로 나타내는 것 =\u003e 조합 공식 : nCr=nPr/r! import itertools a = [1,2,3] permute = itertools.combinations(a, 2) print(list(permute)) a = \"abc\" permute = itertools.combinations(a, 2) print(list(permute)) [(1, 2), (1, 3), (2, 3)] [('a', 'b'), ('a', 'c'), ('b', 'c')] ","date":"2021-03-08","objectID":"https://colinder.github.io/python_library/:1:2","tags":["algorithm","Python"],"title":"Python_Library","uri":"https://colinder.github.io/python_library/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:0","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"2630_색종이 만들기 import sys def DFS(x, y, N): global W, B color = arr[x][y] for cx in range(x, x+N): for cy in range(y, y+N): if arr[cx][cy] != color: DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) return # 이걸 안해주면 쓸모 없는 DFS에 더 들어가게 된다. if color == 0: W += 1 return else: B += 1 return N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] W, B = 0, 0 DFS(0, 0, N) print(W) print(B) # 분할한 구역에도 동일한 규칙을 적용할 수 있는 # 알고리즘을 만드는 것이 기본 같다. ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:1","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"1992_쿼드트리 import sys def DFS(x, y, N): global result check = arr[x][y] for i in range(x, x+N): for j in range(y, y+N): if check != arr[i][j]: result += \"(\" DFS(x, y, N//2) DFS(x, N//2+y, N//2) DFS(N//2+x, y, N//2) DFS(N//2+x, N//2+y, N//2) result += \")\" return if check == 0: result += \"0\" else: result += \"1\" N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] result = \"\" DFS(0, 0, N) print(result) ​ ","date":"2021-03-02","objectID":"https://colinder.github.io/bj_21.03.02/:0:2","tags":["algorithm","분할 정복"],"title":"BEAKJOON 2630, 1992","uri":"https://colinder.github.io/bj_21.03.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"5052_전화번호 목록 import sys for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) Numbers = [] for _ in range(N): Numbers.append(sys.stdin.readline().rstrip()) Numbers.sort() result = \"YES\" for i in range(len(Numbers)-1): if Numbers[i+1].find(Numbers[i], 0, len(Numbers[i])) != -1: result = 'NO' break print(result) # 흠.. 다른 사람들은 트리로 풀었나..? # 이게 왜 트리에 있지... ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"9372_상근이의 여행 import sys from collections import deque def BFS(i): q = deque([i]) visited = [True] + [False] * N flight = -1 while q: x = q.popleft() if visited[x] == False: visited[x] = True flight += 1 for j in range(len(tree[x])): if visited[tree[x][j]] == False: q.append(tree[x][j]) return flight for T in range(int(sys.stdin.readline().rstrip())): N, M = map(int, sys.stdin.readline().split()) tree = [[] for _ in range((N+1))] for _ in range(M): a, b = map(int, sys.stdin.readline().split()) tree[a].append(b) tree[b].append(a) print(BFS(1)) ​ ","date":"2021-02-25","objectID":"https://colinder.github.io/bj_21.02.25/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 5052, 9372","uri":"https://colinder.github.io/bj_21.02.25/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:0","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1991_트리 순회 class Node: def __init__(self, data, L, R): self.data = data self.left = L self.right = R def preorder(node): # 전위 순회 print(node.data, end=\"\") if node.left != \".\": preorder(tree[node.left]) if node.right != \".\": preorder(tree[node.right]) def inorder(node): # 중위 순회 if node.left != \".\": inorder(tree[node.left]) print(node.data, end=\"\") if node.right != \".\": inorder(tree[node.right]) def postorder(node): # 후위 순회 if node.left != \".\": postorder(tree[node.left]) if node.right != \".\": postorder(tree[node.right]) print(node.data, end=\"\") N = int(input()) tree = {} for _ in range(N) : data, L, R = input().split() tree[data] = Node(data, L, R) preorder(tree['A']) print() inorder(tree['A']) print() postorder(tree['A']) # 트리 구조에 대한 이해가 부족하다. # 트리문제를 많이 풀어봐야 겠다. # 해보니 복잡?하지는 않은데 익숙하지 않은 느낌이다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:1","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"11725_트리의 부모 찾기 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N-1): S, E = map(int, sys.stdin.readline().split()) tree[S].append(E) tree[E].append(S) q = deque([1]) visited = [True, True] + [False for _ in range(N)] result = [[] for _ in range(N+1)] while len(q): parent = q.popleft() for child in tree[parent]: if not visited[child]: visited[child] = True result[child].append(parent) q.append(child) for j in range(2, len(result)): print(result[j][0]) # heap을 사용하는 건가 고민했으나, 아니었고, # 1이 root node인 것을 알고 있으니. # 각각의 node에 연결되어있는 모든 node들을 기록했다가. # 1부터 BFS로 한 단계씩 내려가면, 코딩상 pop한 것이 # 부모 node가 된다. # 채점 속도가 느려서 런타임 오류 걸릴까봐 조마조마했다. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:2","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1967_트리의 지름 import sys from collections import deque def BFS(value, step): q = deque() q.append(value) visited = [-1 for _ in range(N+1)] visited[value] = 0 while q: x = q.popleft() for c, w in tree[x]: if visited[c] == -1: visited[c] = visited[x] + w q.append(c) if step == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for i in range(N-1): P, C, V = map(int, input().split()) tree[P].append([C, V]) tree[C].append([P, V]) print(BFS(BFS(1, 1), 2)) # DFS로 지저분하게 구현했으나 말 그대로 # 너무 지저분해서 검색의 도움을 받음. # root인 1에서 가장 멀리 있는 노드를 고르고 # 그 노드에서 가장 멀리 있는 노드를 고르는 # 알고리즘으로 구현. ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:3","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["BEAKJOON"],"content":"1167_트리의 지름 import sys from collections import deque sys.setrecursionlimit(10**9) def BFS(i, mode): q = deque() q.append(i) visited = [-1 for _ in range(N+1)] visited[i] = 0 while q: x = q.popleft() for C, W in tree[x]: if visited[C] == -1: visited[C] = visited[x] + W q.append(C) if mode == 1: return visited.index(max(visited)) else: return max(visited) N = int(sys.stdin.readline().rstrip()) tree = [[] for _ in range(N+1)] for _ in range(N): info = list(map(int, sys.stdin.readline().split())) for i in range(1, len(info)-1, 2): tree[info[0]].append([info[i], info[i+1]]) print(BFS(BFS(i, 1), 2)) ​ ","date":"2021-02-18","objectID":"https://colinder.github.io/bj_21.02.18/:0:4","tags":["algorithm","heap","힙","트리"],"title":"BEAKJOON 1991, 11725, 1967, 1167","uri":"https://colinder.github.io/bj_21.02.18/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_3143_가장 빠른 문자열 타이핑 for T in range(int(input())): A, B = input().split() result = len(A) - (A.count(B)*(len(B)-1)) print(f'#{T+1} {result}') # 왜 D4 인가. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_10966_물놀이를 가자 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] for T in range(int(input())): N, M = map(int, input().split()) arr = [input() for _ in range(N)] visited = [[-1 for _ in range(M)] for _ in range(N)] q = deque([]) for i in range(N): for j in range(M): if arr[i][j] == \"W\": q.append([i,j]) visited[i][j] = 0 total = 0 while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0\u003c= cx \u003cN and 0\u003c= cy \u003cM and visited[cx][cy] == -1: visited[cx][cy] = visited[x][y] + 1 q.append([cx, cy]) total += visited[cx][cy] print(f'#{T+1} {total}') # 오랜만에 다중 시작점 BFS ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11592_크루즈 컨트롤 for T in range(int(input())): D, N = map(int, input().split()) # D: 총 거리 S = [] for _ in range(N): k, s = map(int, input().split()) # k : 위치 / s : 속도 S.append((D-k) / s) a = max(S) print(f'#{T+1} {D/a}') # D2 난이도... ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["SW Expert Academy"],"content":"D4_11545_틱택톰 def check(): # 가로 판단 for i in range(4): if '.' not in arr[i] and 'O' not in arr[i]: return 'X won' if '.' not in arr[i] and 'X' not in arr[i]: return 'O won' # 세로 판단을 위한 리스트 생성 col = [arr[j][i] for j in range(4)] if '.' not in col and 'O' not in col: return 'X won' if '.' not in col and 'X' not in col: return 'O won' # 우상단 대각선 판단 rUp = [arr[i][i] for i in range(4)] if '.' not in rUp and 'O' not in rUp: return 'X won' elif '.' not in rUp and 'X' not in rUp: return 'O won' # 좌상단 대각선 판단 lUP = [arr[i][3-i] for i in range(4)] if '.' not in lUP and 'O' not in lUP: return 'X won' elif '.' not in lUP and 'X' not in lUP: return 'O won' # 그밖의 경우. for i in range(4): for j in range(4): if arr[i][j] == '.': return 'Game has not completed' return 'Draw' N = int(input()) for T in range(N): arr = [list(input()) for _ in range(4)] if T \u003c N-1: _ = input() print(f'#{T+1} {check()}') # T의 숫자를 고려하는 것에 애먹었으나, # 문제에 T는 최대 1개로 설정. # 즉, T의 숫자를 별도로 카운트 하지 않아도 됨. ​ ","date":"2021-02-16","objectID":"https://colinder.github.io/sw_21.02.16/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 3143, 10966, 11592, 11545","uri":"https://colinder.github.io/sw_21.02.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:0","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15649_N과 M (1) N, M = map(int, input().split()) def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() visited[i] = False num_list = [i + 1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:1","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["BEAKJOON"],"content":"15650_N과 M (2) import sys def DFS(count): if count == M: print(*arr) return for i in range(N): if visited[i] == True: continue visited[i] = True arr.append(num_list[i]) DFS(count+1) arr.pop() for j in range(i+1, N): visited[j] = False N, M = map(int, sys.stdin.readline().split()) num_list = [i+1 for i in range(N)] visited = [False] * N arr = [] DFS(0) ​ ","date":"2021-02-09","objectID":"https://colinder.github.io/bj_21.02.09/:0:2","tags":["algorithm","백트래킹","되추적"],"title":"BEAKJOON 15649, 15650","uri":"https://colinder.github.io/bj_21.02.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1258_행렬찾기 def check(x, y): dx, dy = 0, 0 while x + dx \u003c N and arr[x+dx][y]: dx += 1 while y + dy \u003c N and arr[x][y+dy]: dy += 1 result.append([dx*dy, dx, dy]) for i in range(x, x+dx): for j in range(y, y+dy): arr[i][j] = 0 for T in range(int(input())): N = int(input()) arr = [list(map(int, input().split())) for _ in range(N)] result = [] for i in range(N): for j in range(N): if arr[i][j] != 0: check(i, j) aws = sorted(result, key=lambda x: [x[0], x[1]]) print(f'#{T+1} {len(aws)}', *[str(i[1]) + ' ' + str(i[2]) for i in aws]) # DFS로 구현해보려 했는데. # 내가 원하는 위치값을 반환하고 바로 종료시키는 것이 # 불가능해서. 최소한의 값인 가로 세로 이동값만을 뽑아 # 정리하였다. # 마지막에 정렬이 더 복잡했다.. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1249_보급로 from collections import deque dx = [0,1,0,-1] dy = [1,0,-1,0] for T in range(int(input())): N = int(input()) arr = [list(map(int, input())) for _ in range(N)] visited = [[float('inf') for _ in range(N)] for _ in range(N)] visited[0][0] = arr[0][0] q = deque([[0, 0]]) while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if 0 \u003c= cx \u003c N and 0 \u003c= cy \u003c N: Sum = visited[x][y] + arr[cx][cy] if visited[cx][cy] \u003e Sum: visited[cx][cy] = Sum q.append([cx, cy]) print(f'#{T+1} {visited[N-1][N-1]}') # DFS로 구현해보려 했지만, 특정 위치에 왔을 때 종료를 # 구현하는데 어려움이 있어, BFS로 바꾸어 구현. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_1238_Contact from collections import deque for T in range(10): N, S = map(int, input().split()) node = list(map(int, input().split())) arr = [[] for _ in range(N)] for i in range(0, N, 2): arr[node[i]].append(node[i+1]) visited = [0] * (N+1) visited[S] = 1 q = deque([S]) while q: v = q.popleft() step = visited[v] for i in arr[v]: if visited[i] == 0: q.append(i) visited[i] = step + 1 for j in range(N+1): if visited[j] == step: result = j print(f'#{T+1} {result}') ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["SW Expert Academy"],"content":"D4_4261_빠른 휴대전화 키패드 anycall = {'2':\"abc\", '3': \"def\", '4':\"ghi\", '5':\"jkl\", '6':\"mno\", '7':\"pqrs\", '8':\"tuv\", '9':\"wxyz\"} for T in range(int(input())): S, N = map(int, input().split()) words = list(input().split()) result = 0 for x in range(len(words)): count = 0 for i, j in enumerate(str(S)): a = words[x][i] b = anycall[j] if words[x][i] in anycall[j]: count += 1 else: break if count == len(str(S)): result += 1 else: count = 0 print(f'#{T+1} {result}') # 비교적 쉬운 문제. ​ ","date":"2021-02-02","objectID":"https://colinder.github.io/sw_21.02.02/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1258, 1249, 1238, 4261","uri":"https://colinder.github.io/sw_21.02.02/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"1021_회전하는 큐 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = deque([i for i in range(1, N+1)]) poplist = deque(list(map(int, sys.stdin.readline().split()))) count = 0 while poplist: try: if arr[0] == poplist[0]: arr.popleft() poplist.popleft() L = len(arr) a = abs(arr.index(arr[0]) - arr.index(poplist[0])) b = L - a if a \u003c b: arr.rotate(-a) count += a elif a \u003e= b: arr.rotate(b) count += b except IndexError: break print(count) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"5430_AC import sys from collections import deque for T in range(int(sys.stdin.readline().rstrip())): P = sys.stdin.readline().rstrip() N = int(sys.stdin.readline().rstrip()) ## 다양하게 input 받는 거 고민하기 좋다. arr = deque(list(sys.stdin.readline().rstrip()[1:-1].split(\",\"))) if N == 0 or len(arr) == 0: arr = deque([]) reverse = False error = False for i in P: if i == \"R\": reverse = not reverse elif i == \"D\": if len(arr) == 0: error = True break if reverse: arr.pop() else: arr.popleft() if error: print(\"error\") else: if reverse: arr.reverse() print(\"[\", end=\"\") print(\",\".join(arr), end=\"\") print(\"]\") ## reverse() 여러번 돌리면 시간초과 뜬다. # flag = True # for i in P: # if i == \"R\": # arr.reverse() # else: # if len(arr) != 0: # arr.popleft() # else: # print(\"error\") # flag = False # break # if flag: # if len(arr) != 0: # print(\"[\", end=\"\") # print(\",\".join(arr), end=\"\") # print(\"]\") # else: # print('error') ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"10866_덱 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque() for i in range(N): command = sys.stdin.readline().split() if command[0] == \"push_front\": q.appendleft(command[1]) elif command[0] == \"push_back\": q.append(command[1]) elif command[0] == \"pop_front\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"pop_back\": if q: print(q.pop()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) ​ ","date":"2021-01-31","objectID":"https://colinder.github.io/bj_21.01.31/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 1021, 5430, 10866","uri":"https://colinder.github.io/bj_21.01.31/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:0","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"18258_큐 2 import sys from collections import deque # import time N = int(sys.stdin.readline().rstrip()) # start = time.time() # 시작 시간 저장 q = deque() for _ in range(N): command = sys.stdin.readline().split() if command[0] == \"push\": q.append(command[1]) elif command[0] == \"pop\": if q: print(q.popleft()) else: print(-1) elif command[0] == \"size\": print(len(q)) elif command[0] == \"empty\": if not q: print(1) else: print(0) elif command[0] == \"front\": if q: print(q[0]) else: print(-1) elif command[0] == \"back\": if q: print(q[len(q)-1]) else: print(-1) # print(\"time :\", time.time() - start) # 현재시각 - 시작시간 = 실행 시간 # q[len(q)-1] VS q[-1] 속도 비교 # q[len(q)-1] 이 더 빠름. ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:1","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"2164_카드2 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) q = deque([i+1 for i in range(N)]) while len(q) != 1: q.popleft() q.append(q.popleft()) print(q[0]) ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:2","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"11866_요세푸스 문제 0 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) q = deque([i+1 for i in range(N)]) result = [] while q: q.rotate(-K+1) result.append(q.popleft()) print(\"\u003c\", end=\"\") for i in range(N): if i != N-1: print(result[i], end=\", \") else: print(result[i], end=\"\") print(\"\u003e\") ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:3","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"1966_프린터 큐 import sys from collections import deque for T in range(int(input())): N, M = map(int, sys.stdin.readline().split()) q = deque(map(int, sys.stdin.readline().split())) idx = deque([0 for i in range(N)]) idx[M] = 1 count = 0 while True: if q[0] == max(q): count += 1 if idx[0] == 1: print(count) break else: q.popleft() idx.popleft() else: q.append(q.popleft()) idx.append(idx.popleft()) # 큐를 사용하는 알고리즘을 고민하는데 # 아주 좋은 문제!! ​ ","date":"2021-01-28","objectID":"https://colinder.github.io/bj_21.01.28/:0:4","tags":["algorithm","큐 \u0026 덱"],"title":"BEAKJOON 18258, 2164, 11866, 1966","uri":"https://colinder.github.io/bj_21.01.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:0","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"4949_균형잡힌 세상 import sys while True: text = sys.stdin.readline().rstrip() if text == \".\": break stack =[] result = \"yes\" for i in text: if i.isalpha() or i == \" \": continue elif i == \"(\" or i == \"[\": stack.append(i) elif i == \")\": if not stack or stack[-1] != \"(\": result = \"no\" break else: stack.pop() elif i == \"]\": if not stack or stack[-1] != \"[\": result = \"no\" break else: stack.pop() if not stack: print(result) else: print('no') ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:1","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"10828_스택 import sys stack = [] commands = [] for i in range(int(sys.stdin.readline().rstrip())): commands.append(sys.stdin.readline().rstrip().split()) for command in commands: if command[0] == \"push\": stack.append(int(command[1])) elif command[0] == \"pop\": if stack: print(stack.pop()) else: print(-1) elif command[0] == \"size\": print(len(stack)) elif command[0] == \"empty\": if stack: print(0) else: print(1) elif command[0] == \"top\": if stack: print(stack[len(stack)-1]) else: print(-1) ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:2","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"1874_스택 수열 import sys N = int(sys.stdin.readline().rstrip()) Numbers = [i for i in range(1, N+1)] Sequence = [] for i in range(N): v = int(sys.stdin.readline().rstrip()) Sequence.append(v) result = \"\" stack = [] ans = [] for i in range(N): if stack and stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" elif not Numbers: while stack: ans.append(stack.pop()) break elif Numbers[0] \u003c= Sequence[i]: try: while Numbers[0] \u003c= Sequence[i]: stack.append(Numbers.pop(0)) result += \"+\" ans.append(stack.pop()) result += \"-\" except IndexError: if stack[-1] == Sequence[i]: ans.append(stack.pop()) result += \"-\" continue if ans == Sequence: for i in result: print(i) else: print(\"NO\") # 뭔가 좀 지저분해보이지만.. # 입력받은 수열의 요소 마다 검증을 하고 싶었고 # 각 요소마다 진행사항을 등록하고 싶었다. # 예를 들어) 수열의 첫 번재 '4'가 나오기 위해선. # 1,2,3,4가 스택에 들어갔다가 마지막 4가 출력되면 된다. # 이런 과정을 코딩하고 싶었다. # 인터넷에 있는 까리한 코딩과 비교해봤는데. # 다행이 내 코드가 속도면에서 우위를 점했다. # 메모리는 졌음. ㅎ ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:3","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"17298_오큰수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) NGE = [-1] * N stack = [0] i = 1 while stack and i \u003c N: while stack and arr[stack[-1]] \u003c arr[i]: NGE[stack[-1]]= arr[i] stack.pop() stack.append(i) i += 1 print(*NGE) # stack에 arr의 인덱스를 저장(비교 기준 설정) # i로 비교할 인덱스를 지정해 비교 # stack에 0 저장 # i = 1 즉, arr[1] = 5를 stack에 저장되어있는 # 인덱스값(arr[0])과 비교 NGE라면 arr[i]을 NGE에 저장 # 이게 왜 빠른건지 잘 모르겠다. ​ ","date":"2021-01-27","objectID":"https://colinder.github.io/bj_21.01.27/:0:4","tags":["algorithm","스택"],"title":"BEAKJOON 4949, 10828, 1874, 17298","uri":"https://colinder.github.io/bj_21.01.27/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:0","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1037_약수 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) Max = max(arr) Min = min(arr) print(Max*Min) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:1","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"1934_최소공배수 import sys def GCD(a, b): while b != 0: m = a % b a = b b = m return a for T in range(int(sys.stdin.readline().rstrip())): A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:2","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"2609_최대공약수와 최소공배수 import sys def GCD(a, b): #최대공약수(유클리드 호제법) while b != 0: m = a % b a = b b = m return a A, B = map(int, sys.stdin.readline().split()) gcd = GCD(A, B) a = A // gcd b = B // gcd print(gcd) print(a*b*gcd) ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:3","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"5086_배수와 약수 import sys while True: a, b = map(int, sys.stdin.readline().split()) if a == 0 and b == 0: break if b % a == 0: print(\"factor\") elif a % b == 0: print(\"multiple\") elif a % b != 0 and b % a != 0: print(\"neither\") ​ ","date":"2021-01-26","objectID":"https://colinder.github.io/bj_21.01.26/:0:4","tags":["algorithm","정수론 및 조합론"],"title":"BEAKJOON 1037, 1934, 2609, 5086","uri":"https://colinder.github.io/bj_21.01.26/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:0","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1931_회의실 배정 import sys N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] schedule = sorted(arr, key=lambda x: (x[1], x[0])) count, end = 0, 0 for s, f in schedule: if s \u003e= end: count += 1 end = f print(count) # 왠지 정렬을 잘하면 계산이 쉬울 것 같아서. # 시작시간과 종료시간을 정렬해 계산했는데 # 1. 종료시간, 2. 시작시간 순위로 정렬해야 했다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:1","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"11399_ATM import sys N = int(sys.stdin.readline().rstrip()) TT = list(map(int, sys.stdin.readline().split())) TT = sorted(TT) result = 0 for i, v in zip(range(N, -1, -1), TT): result += i*v print(result) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:2","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"1541_잃어버린 괄호 import sys text = list(sys.stdin.readline().rstrip().split('-')) Nums = [] for N in text: n = sum(list(map(int, N.split(\"+\")))) Nums.append(n) result = 0 for i in range(len(Nums)): if i != 0: result -= Nums[i] else: result += Nums[i] print(result) # 55-50+40 경우 결국 - 뒤에 +는 모두 묶어주면 된다. # 예를 들어 55-50+40-30+49 경우 # 55-(50+40)-(30+49) 가 정답이 된다. # 즉 55 / 50+40 / 30+49 로 나누고 # 첫 인자를 제외한 나머지의 합을 빼주면 된다. ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:3","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["BEAKJOON"],"content":"13305_주유소 import sys N = int(sys.stdin.readline().rstrip()) distance = list(map(int, sys.stdin.readline().split())) #d 2 3 1 price = list(map(int, sys.stdin.readline().split())) #p 5 2 4 1 total = 0 Min = sys.maxsize for i in range(N-1): if i == 0: total += price[0]*distance[0] Min = min(Min, price[0]) else: Min = min(Min, price[i]) total += Min*distance[i] print(total) ​ ","date":"2021-01-25","objectID":"https://colinder.github.io/bj_21.01.25/:0:4","tags":["algorithm","그리디 알고리즘"],"title":"BEAKJOON 1931, 11399, 1541, 13305","uri":"https://colinder.github.io/bj_21.01.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1226_미로1 dx = [0,1, 0, -1] dy = [1,0, -1, 0 ] def IsSafe(x, y): if 0\u003c= x \u003c 16 and 0 \u003c= y \u003c 16: return True def DFS(x, y): global result visited[x][y] = 1 if arr[x][y] == 3: result = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] != 1: DFS(nx, ny) def Find_Start(): for i in range(16): for j in range(16): if arr[i][j] == 2: return i, j for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(16)] visited = [[0 for _ in range(16)] for _ in range(16)] x, y = Find_Start() result = 0 DFS(x, y) print(f'#{T+1} {result}') # 재귀를 사용할 시 return은 불편한 점이 많다. # 하여 특정 조건에서의 값이 필요한 경우. # 변수를 설정해서 그 값을 바꾸는 편이 간편하다. # 다만 런타임에 조심해야 한다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1227_미로2 from collections import deque dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] def IsSafe(x, y): if 0\u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True for T in range(10): t = input() arr = [list(map(int, input())) for _ in range(100)] visited = [[0 for _ in range(100)] for _ in range(100)] result = 0 q = deque([[1, 1]]) while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): nx = x + dx[i] ny = y + dy[i] if arr[nx][ny] == 3: result = 1 break if IsSafe(nx, ny) and visited[nx][ny] == 0 and arr[nx][ny] == 0: q.append([nx, ny]) if result: break print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_1231_중위순회 def DFS(i): global result if i \u003c= N: DFS(i*2) result += words[i] DFS(i*2+1) for T in range(10): N = int(input()) words = [0] * (N+1) for i in range(N): command = input().split() words[int(command[0])] = command[1] result = \"\" DFS(1) print(f'#{T+1} {result}') ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"D4_5643_키 순서 def DFSF(x, i): for j in arrF[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSF(x, j) def DFSB(x, i): for j in arrB[i]: if arr[x][j] == 0: arr[x][j] = 1 DFSB(x, j) for T in range(int(input())): N = int(input()) M = int(input()) arrF = [[] for _ in range(N+1)] arrB = [[] for _ in range(N+1)] arr = [[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(M): a, b = map(int, input().split()) arrF[a].append(b) arrB[b].append(a) for i in range(1, N+1): x = i DFSF(x, i) DFSB(x, i) count = 0 for i in arr: if sum(i) == N-1: count += 1 print(f'#{T+1} {count}') # 화살표 방향대로의 F # 화살표 반대방향의 B # 앞으로 진행시(F방향) 알 수 있는 위치를 arr에 저장하고 # 반대로 진행시(B방향) 알 수 있는 위치를 arr에 저장했을 때 # 다른 노드의 위치를 모두 확인할 수 있는 노드만이 본인의 위치를 # 알 수 있게 된다. ​ ","date":"2021-01-21","objectID":"https://colinder.github.io/sw_21.01.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1226, 1227, 1231, 5643","uri":"https://colinder.github.io/sw_21.01.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1218_괄호 짝짓기 def Pair_bracket(): for i in range(L): if q[i] in check: ni = i - 1 while True: if q[ni] == 0: ni -= 1 else: break a = q[ni] b = check[q[i]] if a == b: q[i] = 0 q[ni] = 0 else: return 0 return 1 check = {\")\" :\"(\", \"]\":\"[\", \"}\":\"{\", \"\u003e\":\"\u003c\"} for T in range(10): L = int(input()) q = list(input()) print(f'#{T+1} {Pair_bracket()}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1219_길찾기 from collections import deque def BFS(): visited[0] = 1 while q: a = q.popleft() if a == 99: return 1 if visited[a] == 0: for i in range(len(arr[a])): q.append(arr[a][i]) visited[a] = 1 return 0 for _ in range(10): T, N = map(int, input().split()) arr = [[] for _ in range(100)] route = list(map(int, input().split())) visited = [0 for _ in range(100)] for i in range(0, N*2, 2): arr[route[i]].append(route[i+1]) q = deque() for i in range(len(arr[0])): q.append(arr[0][i]) print(f'#{T} {BFS()}') # 빈 2차원 리스트 만드는 법 # [[] * 100] 은 안됨 # [[] for _ in range(N)] 으로 생성 ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1222_계산기1 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. total = 0 for i in text: if i == \"+\": continue total += int(i) print(f'#{T+1} {total}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["SW Expert Academy"],"content":"D4_1223_계산기2 for T in range(10): L = int(input()) text = input() # 후위 표기법 알고리즘 (BEAKJOON - 1918을 먼저 풀어보세요.) operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = [] result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() # 문제 풀이. aws = [] idx = [] for i in range(L): if i in idx: continue if text[i] in \"0123456789\": aws.append(int(text[i])) elif text[i] == \"*\": aws[-1] = aws[-1]*int(text[i+1]) idx.append(i+1) print(f'#{T+1} {sum(aws)}') ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/sw_21.01.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 1218, 1219, 1222, 1223","uri":"https://colinder.github.io/sw_21.01.20/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:0","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["BEAKJOON"],"content":"1918_후위 표기식 import sys from collections import deque text = sys.stdin.readline().rstrip() # 후위 표기법 알고리즘 operator = {\"+\":1, \"-\":1, \"*\":2 , \"/\":2, \"(\":0, \")\":0} stack = deque() result = \"\" for i in text: if i not in operator: result += i elif i == \"(\": stack.append(i) elif i == \")\": while stack and stack[-1] != \"(\": result += stack.pop() stack.pop() else: while stack and operator[i] \u003c= operator[stack[-1]]: result += stack.pop() stack.append(i) while stack: result += stack.pop() print(result) ​ ","date":"2021-01-20","objectID":"https://colinder.github.io/bj_21.01.20/:0:1","tags":["algorithm"],"title":"BEAKJOON 1918, , , ","uri":"https://colinder.github.io/bj_21.01.20/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6959_이상한 나라의 덧셈게임 for T in range(int(input())): N = input() result = [\"A\", \"B\"] turn = 1 while len(N) \u003e 1: N = str(int(N[0]) + int(N[1])) + N[2:] turn += 1 print(f'#{T+1} {result[turn%2]}') # 단순 산수 ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_4613_러시아 국기 같은 깃발 for T in range(int(input())): N, M = map(int, input().split()) a = [input() for _ in range(N)] result = N * M for i in range(1, N - 1): for j in range(1, N - i): count = 0 for x in range(N): if 0 \u003c= x \u003c i: count += M - a[x].count('W') elif i \u003c= x \u003c i + j: count += M - a[x].count('B') else: count += M - a[x].count('R') if result \u003e count: result = count print(f'#{T+1} {result}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_6109_추억의 2048게임 from collections import deque def turn(): tmp = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): tmp[i][j] = arr[N-1-j][i] return tmp def push(): for y in range(N): q = deque([]) for x in range(N): if arr[x][y] != 0: q.append(arr[x][y]) arr[x][y] = 0 i = 0 while q: if len(q) \u003e= 2: a, b = q.popleft(), q.popleft() if a == b: arr[i][y] = a+b else: arr[i][y] = a q.appendleft(b) i += 1 else: arr[i][y] = q.popleft() direction = {'up': (0, 0), 'left': (1, 3), 'down': (2, 2), 'right': (3, 1)} for T in range(int(input())): N, S = input().split() N = int(N) arr = [list(map(int, input().split())) for _ in range(N)] Front, Back = direction[S] for i in range(Front): arr = turn() push() for i in range(Back): arr = turn() print(f'#{T+1}') for i in arr: print(*i) # 하... 너무 오래 걸렸다. # 방향 전환이 싫어서 U, D, R, L를 # 각각 구현해봤으나.. 실패하고. # 수정해야 할 것도 너무 많아지고.. # 방향 전환 구현하니까.. 이리 저리 돌리는 숫자 # 생각하는데 또 오래 걸리고...ㅎ ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["SW Expert Academy"],"content":"D4_1211_Ladder2 dx = [0, 0, 1] dy = [1, -1, 0] def IsSafe(x, y): if 0 \u003c= x \u003c 100 and 0 \u003c= y \u003c 100: return True def DFS(x, y): global distance if x == 99: return distance visited[x][y] = 1 for i in range(3): nx = x + dx[i] ny = y + dy[i] if IsSafe(nx, ny) and arr[nx][ny] == 1 and visited[nx][ny] == 0: distance += 1 DFS(nx, ny) return distance # 런타임 오류 방지로 재귀를 빠져나올 때 무조건 리턴. for _ in range(10): T = int(input()) arr = [list(map(int, input().split())) for _ in range(100)] Min = 10000 Midx = 0 for y in range(100): if arr[0][y] == 1: visited = [[0]* 100 for _ in range(100)] distance = 0 v = DFS(0, y) if v \u003c= Min: Min = v Midx = y print(f'#{T} {Midx}') ​ ","date":"2021-01-19","objectID":"https://colinder.github.io/sw_20.10.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D4 6959, 4613, 6109, 1211","uri":"https://colinder.github.io/sw_20.10.23/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2156_포도주 시식 N = int(input()) wine = [0 for _ in range(N)] total = [0 for _ in range(N)] for i in range(N): wine[i] = int(input()) if N == 1: total[0] = wine[0] else: total[0] = wine[0] total[1] = wine[0] + wine[1] for i in range(2, N): total[i] = max(total[i-1], total[i-2] + wine[i], total[i-3] + wine[i] + wine[i-1]) print(total[N-1]) # N == 1인 경우를 생각하지 않았을 땐 런타임 오류에 걸렸었다. # 그리고 그걸 생각하는데 오래 걸렸다. ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"2565_전깃줄 n = int(input()) line = [list(map(int, input().split())) for _ in range(n)] line.sort(key=lambda x: x[0]) # 앞 숫자 기준, 오름차순 정리 arr = [0] * 501 for s, e in line: arr[e] = max(arr[:e]) + 1 print(n - max(arr)) # dp를 활용해 e에 겹쳐지지 않은 줄의 수를 기록 # s는 오름차순으로 정렬해 검증함으로 겹쳐지는 것을 # 신경 쓰지 않아도 ok ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"10844_쉬운 계단 수 # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"9251_LCS # 진행중... ​ ","date":"2021-01-15","objectID":"https://colinder.github.io/bj_21.01.15/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 2156, 2565, 10844, 9251","uri":"https://colinder.github.io/bj_21.01.15/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"1912_연속합 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) result = [arr[0]] for i in range(N-1): result.append(max(result[i]+arr[i+1], arr[i+1])) print(max(result)) # dp 연습하기 좋은 문제 ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"9184_신나는 함수 실행 def w(a,b,c): if a \u003c= 0 or b \u003c= 0 or c \u003c= 0: return 1 if a \u003e 20 or b \u003e 20 or c \u003e 20: return w(20, 20, 20) if dp[a][b][c]: return dp[a][b][c] if a \u003c b and b \u003c c: dp[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c) return dp[a][b][c] dp[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1) return dp[a][b][c] dp = [[[0]*21 for _ in range(21)] for _ in range(21)] while True: a, b, c = map(int, input().split()) if a == -1 and b == -1 and c == -1: break print(f'w({a}, {b}, {c}) = {w(a, b, c)}') # 갑자기 난이도가 높아진듯.. # 3차원 dp까지는 어찌저찌 고안했으나 # if dp[a][b][c]: # return dp[a][b][c] # 를 어디에 넣어야 할지 고민하는데 # 시간을 소요. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11053_가장 긴 증가하는 부분 수열 n = int(input()) a = list(map(int, input().split())) dp = [0 for i in range(n)] for i in range(n): for j in range(i): if a[i] \u003e a[j] and dp[i] \u003c dp[j]: dp[i] = dp[j] dp[i] += 1 print(max(dp)) ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["BEAKJOON"],"content":"11054_가장 긴 바이토닉 부분 수열 import sys N = int(sys.stdin.readline().rstrip()) arr = list(map(int, sys.stdin.readline().split())) idp = [0 for _ in range(N)] ddp = [0 for _ in range(N)] result = [0 for _ in range(N)] for i in range(N): for j in range(i): if arr[i] \u003e arr[j] and idp[i] \u003c idp[j]: idp[i] = idp[j] idp[i] += 1 for i in range(N-1, -1, -1): for j in range(N-1, i, -1): if arr[i] \u003e arr[j] and ddp[i] \u003c ddp[j]: ddp[i] = ddp[j] ddp[i] += 1 result[i] = ddp[i] + idp[i] -1 print(max(result)) # 11053을 풀어본 뒤에 도전하면 할만하다. # range()를 거꾸로 돌리는데 살짝 애를 먹음. ​ ","date":"2021-01-14","objectID":"https://colinder.github.io/bj_21.01.14/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1912, 9184, 11053, 11054","uri":"https://colinder.github.io/bj_21.01.14/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5678_[Professional] 팰린드롬 for T in range(int(input())): S = \" \" + input() L = len(S) result = 1 for i in range(2, L): for j in range(L-i): if S[j+1:j+i+1] == S[j+i:j:-1]: result = i print(f'#{T+1} {result}') # 슬라이싱을 잘 고민 하면 쉽게 해결 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_5672_[Professional] 올해의 조련사 for T in range(int(input())): q = [] n = \"\" for N in range(int(input())): q.append(input()) S = 0 L = N while S != L: if q[S] \u003c q[L]: n += q[S] S += 1 elif q[S] \u003e q[L]: n += q[L] L -= 1 else: W = int((L-S)//2) for i in range(W): flag = True c = q[S+i+1] d = q[L-(i+1)] if c == d: continue elif c \u003c d: n += q[S] S += 1 flag = False break elif c \u003e d: n += q[L] L -= 1 flag = False break if flag: n += q[S] S += 1 n += q[L] print(f'#{T+1} {n}') # 조건은 다 쉬웠으나, 검사하는 횟수?에 착각을해 # 생각보다 시간이 많이 걸린 문제 ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7465_창용 마을 무리의 개수 def DFS(x): visited[x] = 1 for i in range(1, N+1): if arr[x][i] == 1 and visited[i] == 0: DFS(i) for T in range(int(input())): N, M = map(int, input().split()) arr = [[0 for _ in range(N+1)] for _ in range(N+1)] visited = [0 for _ in range(N+1)] for i in range(M): x, y = map(int, input().split()) arr[x][y] = 1 arr[y][x] = 1 count = 0 for i in range(1, N+1): if visited[i] == 0: DFS(i) count += 1 print(f'#{T+1} {count}') # 양방향입니다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"D4_7701_염라대왕의 이름 정렬 for T in range(int(input())): N = int(input()) S = set() for i in range(N): s = input() S.add(s) A = sorted(S, key=lambda x: (len(x), x)) print(f'#{T+1}') for j in A: print(j) # set 자료형도 sorted를 진행하면 # 자동으로 list type으로 변한다. ​ ","date":"2021-01-06","objectID":"https://colinder.github.io/sw_21.01.06/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5678, 5672, 7465, 7701","uri":"https://colinder.github.io/sw_21.01.06/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10761_신뢰 from collections import deque for T in range(int(input())): command = deque(input().split()) N = command.popleft() B = deque() O = deque() order = deque() while command: i = command.popleft() if i == \"B\": B.append(int(command.popleft())) order.append(\"B\") else: O.append(int(command.popleft())) order.append(\"O\") count = 0 b, o = 1, 1 while True: if not order: break count += 1 BP = \"안눌림\" if B: if B[0] \u003e b: b += 1 elif B[0] == b and order[0] == \"B\": B.popleft() order.popleft() BP = \"눌림\" elif B[0] \u003c b: b -= 1 if O: if O[0] \u003e o: o += 1 elif O[0] == o and order[0] == \"O\" and BP == \"안눌림\": O.popleft() order.popleft() elif O[0] \u003c o: o -= 1 print(f'#{T+1} {count}') # 주어진 순서대로 버튼을 눌러야 한다!!! # 첫번째 테스트의 경우 O에 1이 있으나, B2가 눌리기를 기다려야 한다. # order 리스트가 필요한 이유 ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10804_문자열의 거울상 for T in range(int(input())): S = input() L = len(S) result = \"\" for i in range(L-1, -1, -1): if S[i] == \"b\": result += \"d\" elif S[i] == \"d\": result += \"b\" elif S[i] == \"q\": result += \"p\" else: result += \"q\" print(f'#{T+1} {result}') ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10912_외로운 문자 from collections import Counter for T in range(int(input())): S = Counter(input()).most_common() R = \"\" for i in S: if i[1] % 2 == 1: R += i[0] result = sorted(R) if len(result) == 0: print(f'#{T+1} Good') else: result2 = \"\" for i in result: result2 += i print(f\"#{T+1} {result2}\") # Counter와 .most_common 은 유용하다. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["SW Expert Academy"],"content":"D3_10965_제곱수 만들기 P = [2] for i in range(3,3162,2): for q in P: if i % q == 0: break else: P.append(i) ans = [] for T in range(int(input())): N = int(input()) result, n = 1, N for v in P: count = 0 if n == 1 or v \u003e N: break while n % v == 0: n //= v count += 1 if count % 2 != 0: result *= v if n \u003e 1: result *= n ans.append(f'#{T+1} {result}') for i in ans: print(i) # 에라토스테네스 체를 이용해 소수를 구했고 # root(10000001**0.5) 보다 큰 소수의 경우 # 소인수 분해를 하고 나서도 n != 1 수 있다. # 하여 소인수분해를 마치고도 n \u003e 1면 # result에 곱해주었다. # 속도와 n이 root보다 큰 경우가 있다는 것을 깨닫는데 # 오랜시간이 걸렸던 문제. ​ ","date":"2021-01-04","objectID":"https://colinder.github.io/sw_21.01.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10761, 10804, 10912, 10965","uri":"https://colinder.github.io/sw_21.01.04/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:0","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"2178_미로탐색 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 1 and visited[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N, M = map(int, sys.stdin.readline().split()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0]*(M) for _ in range(N)] q = deque([[0, 0]]) BFS() print(arr[N-1][M-1]) # pop을 사용하는데 리스트형태의 자료인 경우 # x, y = [1, 2]의 모습으로도 추출이 가능 ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:1","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"7576_토마토 import sys from collections import deque def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def BFS(): while q: x, y = q.popleft() for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and arr[cx][cy] == 0: q.append([cx, cy]) arr[cx][cy] = arr[x][y] + 1 def result(): global Max for x in range(N): for y in range(M): if arr[x][y] == 0: print(-1) return if arr[x][y] \u003e Max: Max = arr[x][y] print(Max-1) return dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] M, N = map(int, sys.stdin.readline().split()) # M: 6, N: 4 arr = [list(map(int, sys.stdin.readline().split())) for _ in range(N)] q = deque() for x in range(N): for y in range(M): if arr[x][y] == 1: q.append([x, y]) BFS() Max = 0 result() # 어떻게 하면 출발점이 2개 이상일 때 # 두 지점에서 동시에 출발해 토마토가 익는 것을 # 판단할 수 있을까에 대한 고민이 1시간.. # 초기 코딩 # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() # 한 시간 후... # for x in range(N): # for y in range(M): # if arr[x][y] == 1: # q = deque([[x, y]]) # BFS() ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:2","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"1697_숨바꼭질 import sys from collections import deque N, K = map(int, sys.stdin.readline().split()) arr = [0] * 30 q = deque([N]) def BFS(): while q: v = q.popleft() if v == K: return print(arr[v]) for i in [v-1, v+1, v*2]: if 0 \u003c= i \u003c 30 and arr[i] == 0: arr[i] = arr[v] + 1 q.append(i) BFS() # 긴 방문 리스트를 만들어 놓고 # 수빈이가 기준점에서 부터 갈 수 있는 장소의 걸음수를 등록한다. # ex) # 위지 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 걸음1: 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 # 걸음2: 0 0 0 2 1 2 0 0 0 2 0 0 0 0 0 0 0 5(기준)에서 갈 수 있는 위치 # 걸음3: 0 0 3 2 1 2 0 3 0 2 0 0 0 0 0 0 0 4(기준)에서 갈 수 있는 위치 # 걸음4: 0 0 3 2 1 2 3 3 0 2 0 3 0 0 0 0 0 6(기준)에서 갈 수 있는 위치 # 걸음5: 0 0 3 2 1 2 3 3 3 2 3 0 0 0 0 0 0 ..3 10(기준)에서 갈 수 있는 위치 # 요런 식으로 진행하면 된다. ​ ","date":"2020-12-29","objectID":"https://colinder.github.io/bj_20.12.29/:0:3","tags":["algorithm","BFS"],"title":"BEAKJOON 2178, 7576, 1697","uri":"https://colinder.github.io/bj_20.12.29/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:0","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1260_DFS와 BFS import sys from collections import deque def DFS(V): print(V, end=' ') DFSv[V] = 1 for i in range(1, N+1): if DFSv[i] == 0 and tree[V][i] == 1: DFS(i) return def BFS(V): q = deque([V]) BFSv[V] = 1 while q: p = q.popleft() print(p, end=\" \") for i in range(1, N+1): if BFSv[i] == 0 and tree[p][i] == 1: q.append(i) BFSv[i] = 1 return N,M,V = map(int, sys.stdin.readline().split()) tree = [[0]*(N+1) for _ in range(N+1)] DFSv = [0 for _ in range(N+1)] BFSv = [0 for _ in range(N+1)] for _ in range(M): S, E = map(int, sys.stdin.readline().split()) tree[S][E] = 1 tree[E][S] = 1 DFS(V) print() BFS(V) # 기초가 제일 중요하다. # 혹시 DFS, BFS가 막힐 땐 이 문제를 다시 풀어보자 ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:1","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2606_바이러스 import sys C = int(sys.stdin.readline().rstrip()) No = int(sys.stdin.readline().rstrip()) arr = [[0 for _ in range(C+1)] for _ in range(C+1)] vistied = [0 for _ in range(C+1)] count = 1 for _ in range(No): S, E = map(int, sys.stdin.readline().split()) arr[S][E] = 1 arr[E][S] = 1 def DFS(V): global count vistied[V] = 1 for i in range(1, C+1): if vistied[i] == 0 and arr[V][i] == 1: vistied[i] = 1 count += 1 DFS(i) DFS(count) print(count-1) ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:2","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"2667_단지번호붙이기 import sys def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c N: return True def DFS(x, y, c): global count visited[x][y] = 1 if arr[x][y] == 1: count += 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy, c) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] N = int(sys.stdin.readline().rstrip()) arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(N)] visited = [[0 for _ in range(N)] for _ in range(N)] result = [] count = 0 # AP 단지안에 건물 숫자 for x in range(N): for y in range(N): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y, count) result.append(count) count = 0 result.sort() print(len(result)) for i in result: print(i) # DFS의 나만의 규칙 # 1. 새로운 노드에 접근하자마자 방문을 표시한다. # 2. isSafe를 만들어 범위를 확인한다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:3","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"1012_유기농 배추 import sys # 최대 재귀 깊이를 늘리려면 sys 모듈의 setrecursionlimit 함수를 사용 # (기본값이상으로 안해주면 런타임에러로 처리된다.) ※기본값:1000 sys.setrecursionlimit(50000) def isSafe(x, y): if 0 \u003c= x \u003c N and 0 \u003c= y \u003c M: return True def DFS(x, y): visited[x][y] = 1 for i in range(4): cx = x + dx[i] cy = y + dy[i] if isSafe(cx, cy) and visited[cx][cy] == 0 and arr[cx][cy] == 1: DFS(cx, cy) dx = [-1, 0, 1, 0] dy = [0, 1, 0, -1] result = [] for T in range(int(sys.stdin.readline().rstrip())): M, N, K = map(int, sys.stdin.readline().split()) # M 가로, N 세로, K 배추갯수 arr = [[0 for _ in range(M)] for _ in range(N)] visited = [[0]*(M) for _ in range(N)] for i in range(K): y, x = map(int, sys.stdin.readline().split()) arr[x][y] = 1 count = 0 for x in range(N): for y in range(M): if visited[x][y] == 0 and arr[x][y] == 1: DFS(x, y) count += 1 result.append(count) for i in result: print(i) # 초기 풀이는 런타임 에러가 발생했다. # 하여 결과값을 모았다가 출력하면 속도 증가가 가능하기에 # result = []에 답을 모았다가 출력해보았지만, # 런타임 에러 발생.. # 검색해보니 # sys.setrecursionlimit(50000) 이런 것이 있다는 것을 봤고 # 추가해주니 통과 되었다. ​ ","date":"2020-12-28","objectID":"https://colinder.github.io/bj_20.12.28/:0:4","tags":["algorithm","DFS"],"title":"BEAKJOON 1260, 2606, 2667, 1012","uri":"https://colinder.github.io/bj_20.12.28/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:0","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10989_수 정렬하기3 import sys # 시간 초과 # from collections import deque # # result = deque() # for T in range(int(sys.stdin.readline().rstrip())): # n = int(sys.stdin.readline().rstrip()) # if len(result) != 0: # for i in range(len(result)): # if result[i] \u003e n: # result.insert(i, n) # break # else: # result.append(n) # for i in result: # print(i) # 속도엔 DP지. arr = [0] * 10001 for T in range(int(sys.stdin.readline().rstrip())): n = int(sys.stdin.readline().rstrip()) arr[n] += 1 for i in range(10001): if arr[i] != 0: for j in range(arr[i]): print(i) ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:1","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"11650_좌표 정렬하기 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for _ in range(T): x, y = map(int, sys.stdin.readline().split()) L.append((x, y)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][1]}') # sorted는 여러 그룹의 값이 주어진 경우 # 순차적으로 증감을 비교해 준다. # ex) # A = [(1,2,1), (1,2,2,3), (1,1,3), (1,1,2)] # A = sorted(A) # print(A) # [(1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2, 3)] ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:2","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"2108_통계학 import sys from collections import deque, Counter result = deque() T = int(sys.stdin.readline().rstrip()) for _ in range(T): result.append(int(sys.stdin.readline().rstrip())) result = sorted(result) def Am(): return round(sum(result)/T) def Me(): return result[int(T//2)] def Mo(): MoResult = Counter(result).most_common() # MoResult = [(-2, 1), (1, 1), (2, 1), (3, 1), (8, 1)] if len(MoResult) \u003e 1: if MoResult[0][1] == MoResult[1][1]: return MoResult[1][0] else: return MoResult[0][0] else: return MoResult[0][0] def Ra(): return result[-1] - result[0] print(Am()) print(Me()) print(Mo()) print(Ra()) # Counter 함수와 더 익숙해지면 좋을 것 같다. # ex) # from collections import Counter # MoResult = Counter([7, 1, 2, 5, 1, 8, 7, 6]).most_common() # print(MoResult) # [(7, 2), (1, 2), (2, 1), (5, 1), (8, 1), (6, 1)] # .most_common() # 입력된 인자들의 '순서'를 존중하면서, '중복 count해줌'과 동시에 '중복 삭제'까지 진행. ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:3","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"10814_나이순 정렬 import sys from collections import deque T = int(sys.stdin.readline().rstrip()) L = deque() for i in range(T): age, name = sys.stdin.readline().split() L.append((int(age), i, name)) NL = sorted(L) for i in range(T): print(f'{NL[i][0]} {NL[i][2]}') ​ ","date":"2020-12-21","objectID":"https://colinder.github.io/bj_20.12.21/:0:4","tags":["algorithm","정렬"],"title":"BEAKJOON 10989, 11650, 2108, 10814","uri":"https://colinder.github.io/bj_20.12.21/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:0","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"2798_블랙잭 import sys N, M = map(int, sys.stdin.readline().split()) cards = list(map(int, sys.stdin.readline().split())) result = 0 for i in range(N): for j in range(i+1, N): for x in range(j+1, N): if cards[i] + cards[j] + cards[x] \u003c= M: result = max(result, cards[i] + cards[j] + cards[x]) print(result) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:1","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"7568_덩치 import sys from collections import deque N = int(sys.stdin.readline().rstrip()) # 내가 생각한 무식한 방법... W = deque() H = deque() for _ in range(N): x, y = sys.stdin.readline().split() W.append(x) H.append(y) for i in range(N): w = W.popleft() h = H.popleft() count = 0 for j in range(N-1): if W[j] \u003e w and H[j] \u003e h: count += 1 print(count+1, end=\" \") W.append(w) H.append(h) # 인터넷에 있던 멋진 방법 # li = deque() # for _ in range(N): # x, y = sys.stdin.readline().split() # li.append((x, y)) # for i in li: # count = 0 # for j in li: # if i[0] \u003c j [0] and i[1] \u003c j[1]: # count += 1 # print(count+1, end=\" \") # 하지만 내가 짠 코드가 더 빠르다. ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:2","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1018_체스판 다시 칠하기 import sys from collections import deque N, M = map(int, sys.stdin.readline().split()) arr = [ list(sys.stdin.readline().rstrip()) for _ in range(N) ] result = deque() for i in range(N-7): for j in range(M-7): caseW = 0 # 시작(기준)점이 W 일 때 바뀌어야 하는 수 caseB = 0 # 시작(기준)점이 B 일 때 바뀌어야 하는 수 for x in range(i, i+8): for y in range(j, j+8): if (x+y) % 2 == 0: if arr[x][y] == \"B\": caseW += 1 if arr[x][y] == \"W\": caseB += 1 else: if arr[x][y] == \"W\": caseW += 1 if arr[x][y] == \"B\": caseB += 1 result.append(caseW) result.append(caseB) print(min(result)) # 체스판에 시작점이 W로 시작했을 때 바뀌어야 하는 수 # VS 시작점이 B로 시작했을 때 바뀌어야 하는 수를 # 비교해야 한다! ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:3","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"1436_영화감독 숌 import sys N = int(sys.stdin.readline().rstrip()) X = 666 while N: if '666' in str(X): N -= 1 X += 1 print(X-1) # 666, 1666, 2666, 3666, 4666, 5666, 6661, 6662, 6663, 6664, 6665, 6667, 6668, 6669, 7666, 8666, 9666, 10666 ..... # 666이 첫 번째 수 인데 그다음 666이 들어간 수를 # 단순히 +1 하면서 찾는 것이다. # 당연히 런타임 오류일 줄 알았으나. 아니었다.(왜 아니지...) ​ ","date":"2020-12-19","objectID":"https://colinder.github.io/bj_20.12.19/:0:4","tags":["algorithm","브루트 포스","단순무식법"],"title":"BEAKJOON 2798, 7568, 1018, 1436","uri":"https://colinder.github.io/bj_20.12.19/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:0","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10872_팩토리얼 import sys N = int(sys.stdin.readline().rstrip()) def fac(n): if n \u003e 1: return n * fac(n-1) else: return 1 print(fac(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:1","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"10870_피보나치 수 5 import sys def fivo(n): if n \u003e= 2: return fivo(n-1) + fivo(n-2) else: return n N = int(sys.stdin.readline().rstrip()) print(fivo(N)) ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:2","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"2447_별 찍기 - 10 import sys n = int(sys.stdin.readline().rstrip()) def star(i, j): while(i != 0): if i % 3 == 1 and j % 3 == 1: sys.stdout.write(' ') return i //= 3 j //= 3 sys.stdout.write('*') for i in range(n): for j in range(n): star(i, j) sys.stdout.write('\\n') # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 재귀는 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:3","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"11729_하노이 탑 이동 순서 import sys N = int(sys.stdin.readline().rstrip()) def hanoi(N, s, m, e): if N == 1: print(s, e) else: hanoi(N-1, s, e, m) print(s, e) hanoi(N-1, m, s, e) Sum = 1 for i in range(N - 1): Sum = Sum * 2 + 1 print(Sum) hanoi(N, 1,2,3) # 이런 디자인은 어떻게 생각할 수 있는 건지.. # 너무 어렵다. ​ ","date":"2020-12-18","objectID":"https://colinder.github.io/bj_20.12.18/:0:4","tags":["algorithm","재귀"],"title":"BEAKJOON 10872, 10870, 2447, 11729","uri":"https://colinder.github.io/bj_20.12.18/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:0","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"4948_베르트랑 공준 import sys while True: N = int(sys.stdin.readline().rstrip()) if N == 0: break arr = [0,0] + [1] * ((2*N)-1) rootN = int((2*N)**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, 2*N+1, i): arr[j] = 0 print(sum(arr[N+1:(2*N)+1])) # 입출력에 제한이 있다가 0을 입력 받을 때 까지 # 출력을 해야 하는 조건을 달지 않는 것을 주의! ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:1","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"9020_골드바흐의 추측 import sys # 무식한 방법....(당연히 런타임 에러) # def checkSum(): # dis = 10000 # rx = 0 # ry = 0 # for x in range(N+1): # if arr[x] == 1: # for y in range(x, N+1): # if arr[y] == 1: # if x + y == N: # dif = y - x # if dis \u003e dif: # dis = dif # rx = x # ry = y # return rx, ry for T in range(int(sys.stdin.readline().rstrip())): N = int(sys.stdin.readline().rstrip()) # 소수 찾기 arr = [0, 0] + [1]*(N-1) rootN = int(N**0.5) for i in range(2, rootN+1): if arr[i] == 1: for j in range(2*i, N+1, i): arr[j] = 0 # 확인해야 하는 값을 줄이기 위해, # a는 중앙에서 부터 1 방향으로 내려가고 # b는 중앙에서 N 까지 올라가며 검증 # 16을 예로 (0, 16) (1, 15) (2, 14) ... # 정대칭된 수를 더하면 16을 만들 수 있다. # 16 만들기로 (3, 13)을 제시할 수도 있지만, # 16의 중심값을 기준으로 비교하는 것이 두 수의 차이를 # 더 줄일 수 있는 방법이었다. a = N//2 b = a while a \u003e 0: if arr[a] and arr[b]: print(a, b) break else: a -= 1 b += 1 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:2","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"3053_택시 기하학 import sys, math n = int(sys.stdin.readline().rstrip()) print(n**2*math.pi) # 유클리드 기하학 print(n**2*2) # 택시 기하학 ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:3","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"1002_터렛 for T in range(int(input())): x1, y1, r1, x2, y2, r2 = map(int, input().split()) distance = (((x1 - x2) ** 2) + ((y1 - y2) ** 2)) ** 0.5 if x1 == x2 and y1 == y2: if r1 == r2: print(-1) else: print(0) continue if r1 \u003e distance + r2 or r2 \u003e distance + r1 or distance \u003e r1 + r2: print(0) elif r1 == distance + r2 or r2 == distance + r1 or r1 + r2 == distance: print(1) else: print(2) ​ ","date":"2020-12-17","objectID":"https://colinder.github.io/bj_20.12.17/:0:4","tags":["algorithm","기본 수학 2"],"title":"BEAKJOON 4948, 9020, 3053, 1002","uri":"https://colinder.github.io/bj_20.12.17/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:0","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"10250_ACM호텔 import sys for T in range(int(sys.stdin.readline().rstrip())): H, W, N = map(int, sys.stdin.readline().split()) quo = str((N // H) + 1) rem = str(N % H) if N % H == 0: quo = str(N//H) rem = str(H) print(rem+quo.zfill(2)) # zfill? # a = \"2\" # b = \"12\" # A = a.zfill(2) # B = b.zfill(2) # print(A) // 02 # print(B) // 12 ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:1","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2775_부녀회장이 될테야 import sys for T in range(int(sys.stdin.readline().rstrip())): floor = int(sys.stdin.readline().rstrip()) ho = int(sys.stdin.readline().rstrip()) floor0 = [_ for _ in range(1,ho+1)] for i in range(floor): for j in range(1, ho): floor0[j] += floor0[j-1] print(floor0[-1]) # 놀랍게도 print(floor0[j])로 제출하면 # 런타임 에러.... 변수를 사용하는 것 보다 # 인덱스로(슬라이싱?)을 사용해 접근하는 것이 더 빠른가보다. ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:2","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"2869_달팽이는 올라가고 싶다 import sys A, B, V = map(int, sys.stdin.readline().split()) # 의식의 흐름에 따른 코딩 # day = 1 # posi = 0 # while True: # posi += A # if posi \u003e= V: # break # else: # posi -= B # day += 1 # print(day) # 의식을 차리고 난 후 코딩 print((V - B - 1) // (A - B) + 1) ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:3","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"1011_Fly me to the Alpha Centauri import sys for T in range(int(sys.stdin.readline().rstrip())): x, y = map(int, sys.stdin.readline().split()) distance = y - x if distance \u003c= 3: print(distance) else: sr = int(distance**0.5) if distance == sr**2: print(2*sr - 1) elif sr**2 \u003c distance \u003c= sr**2 + sr: print(2*sr) else: print(2*sr+1) # 일단 손으로 노가다를 해야 # 규칙이 보인다... ​ ","date":"2020-12-16","objectID":"https://colinder.github.io/bj_20.12.16/:0:4","tags":["algorithm","기본 수학 1"],"title":"BEAKJOON 10250, 2775, 2869, 1011","uri":"https://colinder.github.io/bj_20.12.16/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:0","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"10809_알파벳찾기 import sys word = sys.stdin.readline().rstrip() alphabet = list(range(97,123)) for x in alphabet : print(word.find(chr(x)), end=\" \") # find함수는 조건에 맞는 값의 index를 출력하고 # 찾지 못하는 경우 -1을 출력한다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:1","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2941_크로아티아 알파벳 import sys cro = [\"c=\", \"c-\", \"dz=\", \"d-\", \"lj\", \"nj\", \"s=\", \"z=\"] s = sys.stdin.readline().rstrip() for i in cro: s = s.replace(i, \"*\") print(len(s)) ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:2","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"2908_상수 import sys A, B = sys.stdin.readline().split() NA = int(A[::-1]) NB = int(B[::-1]) if NA \u003e NB : print(NA) else: print(NB) # 문자열 슬라이싱을 잘 활용하면 아주아주 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:3","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["BEAKJOON"],"content":"1316_그룹 단어 체커 import sys N = int(sys.stdin.readline().rstrip()) for i in range(N): sent = sys.stdin.readline().rstrip() for j in range(1, len(sent)): if sent.find(sent[j-1]) \u003e sent.find(sent[j]): N -= 1 break print(N) # find함수도 잘 알아두면 좋다. ​ ","date":"2020-12-15","objectID":"https://colinder.github.io/bj_20.12.15/:0:4","tags":["algorithm","문자열"],"title":"BEAKJOON 10809, 2941, 2908, 1316","uri":"https://colinder.github.io/bj_20.12.15/"},{"categories":["Javascript"],"content":"​ JavaScript Hoisting web 개발을 하면서 여러 레퍼런스들을 확인하고 공부하게 되는데, 문득 똑같아 보이나 왜 이건 되고? 왜 이건 안되지?하는 부분이 있었습니다. 그 차이는 Hoisting에 대한 내용이었는데요. 알아두면 쓸모있기에 정리해봅시다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:0:0","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅(Hoisting)이란? 호이스팅을 한 줄로 설명하자면, 선언문을 유효 범위의 최상단으로 끌어올리는 행위라고 할 수 있습니다. 최상단이라는 표현이 중요한데요. 인터프리터 언어인 자바스크립트가 한 줄씩 순서대로 코딩을 실행하는 것이 아니라, 임의로 특정 내용을 최상단으로 끌어 올려서 우선 실행하는 것을 호이스팅이라고 합니다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:0","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅의 특징 자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑는다. 함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다. 유효 범위: 함수 블록 {} 안에서 유효 실제 메모리에는 변화가 없다. ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:1","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"호이스팅의 대상 var 변수 선언과 함수선언식(Function Declarations)에서만 호이스팅이 일어납니다. 첨언으로 [ var 변수 / 함수 ]의 선언만 호이스팅이 동작하고, 할당(초기화)은 호이스팅이 동작하지 않습니다. ​ 🙋‍♂️ var 변수 vs let 변수 비교 // 예시 0 // 아래 코드를 전체 복사 후 붙여넣으면 결과 확인 가능 console.log(a) // undefined console.log(b) // VM85:2 Uncaught ReferenceError: b is not defined var a = \"Im a\"; // var 변수 선언 \u0026 초기화 let b = \"Im b\"; // let 변수 선언 \u0026 초기화 // var 변수 a는 호이스팅되어 오류가 아닌 undefined를 출력하고 // let 변수 b는 호이스팅되지 않아 error를 출력합니다. 만약 변수를 선언한 뒤 나중에 초기화시켜 사용한다면, 그 값은 undefined로 지정됩니다. 아래 예제로 동작 순서를 알아 봅시다. // 예시 1 console.log(\"x:\", x) // x: undefined var x = 1; // x 선언 \u0026 초기화 console.log(x + \"/\" + y); // '1/undefined' var y = 2; // y 선언 \u0026 초기화 // 아래 코드는 '예시 1'이 동작하는 순서를 정리한 것입니다. var x; // x 선언 =\u003e x: undefined var y; // y 선언 =\u003e y: undefined console.log(\"x:\", x) // x: undefined 출력 var x = 1; // x 초기화 =\u003e x: 1 console.log(x + \"/\" + y); // '1/undefined' 출력 var y = 2; // y 초기화 =\u003e y: 1 * [ let / const ] 변수 선언과 함수표현식(Function Expressions)에서는 호이스팅이 발생하지 않습니다. ​ ​ 🙋‍♂️ 함수선언식(Function Declarations) vs 함수표현식(Function Expressions) // 함수 선언식(function declaration) 예시 function 함수명() { 함수 로직 부분 } 함수명(); // 함수 사용 // 함수 표현식(function expression) 예시 var 함수명 = function () { return 'A function expression'; } 함수명(); // 함수 사용 함수선언식은 일반적인 프로그래밍 언어에서 함수 선언과 비슷한 모습니다. 다만, 함수표현식은 유연한 자바스크립트 언어의 특징을 활용한 선언 방식이라고 할 수 있습니다. ​ ​ ​ ","date":"2020-12-11","objectID":"https://colinder.github.io/js_hoisting/:1:2","tags":["Javascript","Hoisting"],"title":"JavaScript Hoisting","uri":"https://colinder.github.io/js_hoisting/"},{"categories":["Javascript"],"content":"​ JavaScript Scope란? Scope [ skoʊp ]1 (무엇을 하거나 이룰 수 있는) 기회[여지/능력] (=potential)2 (주제조직활동 등이 다루는) 범위3 샅샅이[자세히] 살피다. 스코프는 “유효 범위\"로써 번수에 매개변수가 어디까지 유효한지를 나타냅니다. 자바스크립트에선 스코프는 2가지 타입이 있습니다. 바로 Global(전역)과 Local(지역)인데요. 함수 안에서 선언된 변수(Local 변수)는 함수 블록 안에서만 접근이 가능합니다.전역 변수는 어디서든 접근이 가능합니다. // global 변수 선언 var a = 10; console.log(\"global a: \", a) // 10 // local 변수 선언 function print() { var b = 20; if (true) { var c = 30; } console.log(\"local b: \",b) // 20 console.log(\"local c: \",c) // 30 } print() console.log(\"local b: \",b) // ReferenceError: b is not defined // ✨ Point // b는 print함수 안에서 선언된 local 변수 임으로 // print함수가 동작하는 안에서는 존재하지만, // print함수 밖에서는 존재하지 않습니다. ​ ","date":"2020-12-10","objectID":"https://colinder.github.io/js_scope/:0:0","tags":["Javascript","Scope"],"title":"JavaScript Scope","uri":"https://colinder.github.io/js_scope/"},{"categories":["Javascript"],"content":"스코프는 렉시컬(Lexical)과 다이나믹(Dynamic)으로 분류. 렉시컬(Lexical) 스코프는 코드를 작성하는 시점에 스코프가 결정되어진다고 해서 정적 스코프라고도 부릅니다. Javascript는 대표적인 렉시컬 스코프입니다. var a = \"Global\" function print1() { console.log(a); } function print2() { var a = \"Local\"; print1(); } print1() // Global print2() // Global // print2에서 a를 \"Local\"로 재할당 했지만, // print1()이 시작되면서 a는 print2()를 벗어나게 되고 // a는 \"Global\"로 돌아가게된다. ​ ​ ​ ","date":"2020-12-10","objectID":"https://colinder.github.io/js_scope/:1:0","tags":["Javascript","Scope"],"title":"JavaScript Scope","uri":"https://colinder.github.io/js_scope/"},{"categories":["Javascript"],"content":"​ JavaScript Operators Javascript의 연산자를 알아 봅시다. 종류가 많이 있어 많이 사용하는 것들 중심으로 먼저 알아보겠습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:0","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"1. 할당 연산자 // 할당 연산자 let numder = 0 numder += 10 console.log(numder) // 10 numder -= 8 console.log(numder) // 2 numder *= 10 console.log(numder) // 20 numder ++ // 1을 더한다. console.log(numder) // 21 numder -- // 1을 뺀다. console.log(numder) // 20 // 종류 더 많이 존재합니다! ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:1","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"2. 비교 연산자 // 비교 연산자 3 \u003e 2 //true 3 \u003c 2 //false \"A\" \u003c \"B\" //true 'z' \u003c 'a' //false 'a'.codePointAt(0) // 97(등록된 절대값) // 동등 연산자(==) 이는 절대로 쓰지 않는다. // 메모리에 같은 객체를 가리키거나 // 같은 값을 갖도록 type 변환할 수 있다면 서로 같다고 판단. const a = 1 const b = \"1\" a == b //true console.log(8*null) // 0 console.log('5'-1) // 4 console.log('5'+1) // 51 console.log(\"five\" * 2) // NaN // 하여 일치 연산자(===)를 사용한다. type도 같아야 동일하다고 판단. const a = 1 const b = \"1\" a === b //false ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:2","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"3. 논리 연산자 // 논리연산자 // And 연산자: \u0026\u0026 true \u0026\u0026 false // false true \u0026\u0026 true // true 1 \u0026\u0026 0 // 0 0 \u0026\u0026 1 // 0 4 \u0026\u0026 7 // 7 // Or 연산자: || false || ture // true false || false // false 1 || 0 // 1 0 || 1 // 1 4 || 7 // 4 // Not 연산자 ! !true // false ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:3","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"4. 삼항(조건) 연산자 // 삼항 연산자(Ternary Operator) true ? 1 : 2 // 1 if문과 비슷. true 면 1, false 면 2 false ? 1 : 2 // 2 const result = math.PI \u003e 4 ? 'Yep' : 'Nope' console.log(result) // Nope let age = 21 let message = age \u003c 7 ? '애기입니다.' : age \u003c 20 ? '청소년입니다. ' : age \u003c 100 ? '어른입니다. ': '사람입니다.' console.log(message) // 어른입니다. ​ 더 많은 연산자들이 존재합니다. 더 알고 싶다면 MDN공식문서를 찾아 봅시다! ​ ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_operators/:0:4","tags":["Javascript","operators"],"title":"JavaScript Operators","uri":"https://colinder.github.io/js_operators/"},{"categories":["Javascript"],"content":"​ JavaScript Type은? 제 생각에 개발 언어를 공부하면서 가장 먼저 알아야 알 것은 그리고 가장 중요한 것은 형식입니다. 때마침 Javascript를 공부하고 있는데, 가장 먼저 Type에 대해 정리해보겠습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:0:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"그 전에 먼저 변수를 선언하는 방법을 알아봅시다. // 변수를 선언 하는 방법 // function scope var a = 10 // 일반적인 변수 선언 방법 // block scope {} 안에서만 존재하는 변수 let b = 20 // 재할당 가능 [최근에는 사용률이 낮아지고 있다고 합니다.] const c = 30 // 재할당 불가능 [\"재할당 불가능\"이라는 설명은 !== 값이 바뀌지 않는다.] ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:1:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"Javascript는 크게 두 가지 타입으로 구분합니다. 원시타입 VS 참조타입원시 타입은 숫자(Number), 불린(Boolean), null, undefined, 문자열(String), 심볼 총 6가지가 존재하고참조 타입은 객체(Object), 배열(Array), 함수(function)가 있습니다. ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:0","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"1. 원시 타입(Primitive Data Type) 원시 타입의 데이터는 변수에 할당이 될 때 메모리 상에 고정된 크기로 저장이 되고 해당 변수가 원시 데이터 값을 보관합니다. 원시 타입 자료형은 모두 변수 선언, 초기화, 할당 시 값이 저장된 메모리 영역에 직접적으로 접근합니다. 즉, 변수에 새로운 값이 할당이 될 경우, 변수에 할당된 메모리 블럭에 저장된 값이 바로 변경됩니다. 숫자형(Number) // Number const a = 13 const b = -5 const c = 3.14 // float const d = 2.00e8 // 2.99 * 10**8 const e = Infinity const f = -Infinity const g = NaN // Not a Number 하지만 타입은 넘버... // 변수의 타입을 알고 싶을 때 console.log(typeof(g)) typeof(g) // 개발자 도구 창에서는 typeof(g) 만 입력해도 보임. 불린형(참, 거짓)(Boolean) // Boolean (소문자로 작성) true false // false 값을 초기값으로 변수 선언 var bNoParam = new Boolean(); var bZero = new Boolean(0); var bNull = new Boolean(null); var bEmptyString = new Boolean(''); var bfalse = new Boolean(false); // true 값을 초기값으로 변수 선언 var btrue = new Boolean(true); var btrueString = new Boolean('true'); var bfalseString = new Boolean('false'); var bSuLin = new Boolean('Su Lin'); var bArrayProto = new Boolean([]); var bObjProto = new Boolean({}); 문자형(String) // String const sentence1 = 'Ask and go to the blue' const sentence2 = 'Ask and go to the red' const firstName = 'Tony' const lastName = 'Stark' const fullname = firstName + lastName console.log(fullname) // expected output: TonyStark // 줄바꿈 const word = '안녕 \\n하세요' // \\ =\u003e 달러표시 console.log(word) // ✨String = Temlates Literal✨ // `을 활용해 여러 줄에 걸처 문자를 정의 할 수도 있고 // JS의 변수를 문자열 안에 바로 연결할 수 있는 이점이 생긴다. const ssafy = '5반' const word3 = `${ssafy} 안녕들 하신가` Null \u0026 undefined (Empty Value) 타입 // Empty Value (null \u0026 undefiened) // 값이 존재하지 않음을 표현하는 값으로 null과 undefiend가 있다. // 두 개가 존재하는 이유는 단순한 설계 실수로 인함 때문이다. let firstName console.log(firstName) // 변수 값을 지정하지 않으면, undefined 출력됨. let lastName = null console.log(lastName) // null // null과 undefined의 차이 // null 또는 undefined를 검사할 때, 동등 연산자(==)와 일치 연산자(===)의 차이를 주의하세요. // 동등 연산자는 자료형 변환을 수행합니다. typeof null // \"object\" (하위호환 유지를 위해 \"null\"이 아님) typeof undefined // \"undefined\" null === undefined // false null == undefined // true null === null // true null == null // true !null // true isNaN(1 + null) // false isNaN(1 + undefined) // true 심볼형(Symbol) // 심볼 자료형은 ES6부터 추가된 원시 자료형입니다. // 다른 원시형과 다르게(유일하게) 변경 불가능한 자료형으로, // 참조형의 키(key)로도 사용이 가능합니다. // Symbol 선언 방법 const symbol = Symbol(); const hello = Symbol('Hi'); console.log(hello) //Symbol(Hi) // new 연산자를 이용한 문법은 TypeError가 발생됩니다. var sym = new Symbol(); // TypeError // 특성 console.log(Number(1) === Number(1)) // true console.log(\"심볼 비교1\", Symbol() === Symbol()) // false 👈왜? console.log(\"심볼 비교2\", Symbol('Hi') === Symbol('Hi')) // false 👈왜?? console.log(typeof(Symbol())) // symbol // 👉 심볼 비교1, 2가 왜 false일까? // Symbol을 함수로 호출하는 경우에 값을 전달할 수 있는데 ex) Symbol('Hi') // 이 값은 디버깅 오로지 용도이고, (인자로 전달한 Hi에 따른) 고유한 symbol값은 생성되지 않습니다. // 즉, Symbol()는 항상 고유한 값을 반환합니다. // =\u003e const A = Symbol('Hi'), const B = Symbol('Hi') 같이 // 동일한 Symbol('Hi') 명령어로 A와 B를 생성했어도 // 각각 고유한 값을 가집니다. // 추가 실습 const nationality = Symbol('nationality') const user = {name: 'kim'} user[nationality] = \"korean\" console.log(user) // user: { name: 'kim', [Symbol(nationality)]: 'korean' } console.log(user[nationality]) // korean ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:1","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Javascript"],"content":"2. 참조 타입(Reference Data Type) 참조 타입의 데이터는 크기가 정해져 있지 않고 변수에 할당이 될 때값이 직접 해당 변수에 저장될 수 없으며 변수에는 데이터에 대한 참조만 저장됩니다. 데이터에 대한 참조만 저장 === 변수의 값이 저장된 힙 메모리의 주소값을 저장한다. === 변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근한다. 객체 Object // Object 객체 생성(선언) new Object() // 생성(생성자 함수 사용) const ob = new Object() console.log(ob) // ▪{} =\u003e __proto__: Object // 프로퍼티 추가 ob.id = 'qqq' ob.pass = 1234 ob.gender = \"m\" console.log(ob) // {id: 'qqq', pass: 1234, gender: \"m\"} // 추가 생성법 및 프로퍼티 추가 // 방법.1 const object1 = { a: 'foo', b: 42, c: {} }; console.log(object1.a); // \"foo\" // 방법.2 const a = 'foo'; const b = 42; const c = {}; const object2 = { A: a, B: b, C: c }; console.log(object2.B); // 42 // 방법.3 (방법.2에 이어서) const object3 = { a, b, c }; console.log(object3.a); // \"foo\" // 방법.4 (객체 리터럴 방식으로 생성) var me = {id: 'JG1', pass: 1234, gender:'m'} console.log(me.id) // \"JG1\" ////////////////////////////////////////////////////////////////////////////// // 2. Object (python의 dict와 비슷한듯.) // key는 문자열 타입이고, value는 모든 타입이 될 수 있다. const me = { name:'홍길동', // key가 한 단어 일때 'phone number':'01012345678', // key가 여러 단어 일때 samsungProducts: { galaxyWatch: '2019GalaxyWatch', galaxyPhone: 'galaxy S9', galaxyBuds: 'Buds V1', }, } // 두가지 방법으로 접근이 가능 // (1) dot notation me.name // 홍길동 me.samsungProducts.galaxyBuds // \"Buds V1\" // (2) []로 호출 me['phone number'] // '01012345678' // Object.keys() - O 대문자 const fruits = {a:'apple', b:'banana'} Object.keys(fruits) // [\"a\", \"b\"] // Object.values() Object.values(fruits) // [\"apple\", \"banana\"] //Object.entries() Object.entries(fruits) // [ [\"a\", \"apple\"], [\"b\", \"banana\"] ] // Object Literal (ER6+) const books = ['Learning JS', 'Eloquent JS'] const comics = { DC : ['Aquaman', 'SHAZAM'], Marvel: ['Captain Marvel', 'Avengers'] } const megazines = null const bookStore = { books: books, comics: comics, megazines: megazines, } bookStore.books[0] // 'Learning JS' 배열(Array) // 1. Array const numbers = [1,2,3,4] numbers[0] // 1 numbers[-1] // undefined / 정확한 양의 정수만 사용 가능 numbers.length // 4 //reverse - 원본 배열의 요소들의 순서를 반대로 정렬한다. numbers.reverse // [4,3,2,1] numbers.reverse // [1,2,3,4] const strings = ['d','c','b','a'] strings.reverse // ['a','b','c','d'] // push \u0026 pop - 요소를 배열의 가장 뒤에 추가하거나 삭제한다. numbers.push('a') // [1, 2, 3, 4, \"a\"] numbers.pop() // 'a' // unshift \u0026 shift - 요소를 배열의 가장 앞에 추가하거나, 제거한다. numbers.unshift('a') // [\"a\", 1, 2, 3, 4] numbers.shift() // 'a' // includes - 배열의 특정 요소가 있는지 여부를 boolean 값으로 반환해준다. numbers.includes(1) // true numbers.includes(0) // false // indexOf // 배열의 특정 요소가 있는지 여부를 확인 후, // 가장 첫번째로 찾은 아이템의 index값을 반환한다. // 요소가 없으면 -1을 반환 numbers.push('a','a') numbers.indexOf('a') // 4 numbers.indexOf('b') // -1 함수(function) // 함수 선언은 크게 두 가지로 나누어서 생각해볼 수 있다. // 1. Function Scope - var를 사용할 때 // python의 global 선언한 def 속 변수 느낌.. function number(num) { var acc = num + 1 return acc } console.log(acc) // num이 정의 되지 않아서 error if (true) { var name = '용우와 영수' } console.log(name) // '용우와 영수' // 2. Block Scope - const, let을 사용할 때 // {} 안에서만 존재하는 변수 // python의 global 선언 안한 def 속 변수 느낌.. let age = '30' if (true) { let age = '100' console.log(age) // 100 } console.log(age) // 30 function numberTwo(num) { let accTwo = num +1 return accTwo } console.log(numberTwo(2)) // 3 ​ ​ ​ ","date":"2020-12-09","objectID":"https://colinder.github.io/js_type/:2:2","tags":["Javascript","tpye"],"title":"JavaScript Type","uri":"https://colinder.github.io/js_type/"},{"categories":["Computer Science"],"content":"​ Process VS Thread 면접 질문에서 가장 많이 들어본 이야기라고 친구들이 이야기 해줬습니다. 근데 전 아직 자신있게 설명할 정도로 알지 못하기에 알아봅시다! ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:0:0","tags":["CS","Process","Thread","computer science","면접대비"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"프로그램(Program)란 무엇인지 우선 알아봅시다. 소프트웨어의 한가지로, 어떤 문제를 해결하기 위하여 그 처리 방법과 순서(a.k.a ALGORITHM)를 기술하여 컴퓨터에 주어지는 일련의 명령문 집합체를 뜻합니다. 쉽게 말해, “어떤 작업을 위해 실행할 수 있는 파일”을 뜻합니다. 그리고 그 프로그램을 실행 시키는 주체를 인스턴스라고도 표현합니다. 예들 들어, Excel.exe, kakaotalk.exe 등과 같이 어떤 작업을 위해 실행할 수 있는 (설치 등)파일을 생각해 볼 수 있습니다. ​ ​ Process Process는 운영체제로부터 자원을 할당받는 작업의 단위 조금 간단하게는 “실행된 프로그램을 의미\"합니다. 앞서 운영체제로부터 할당을 받는다고 설명했는데 CPU의 시간 / 운영되기 위해 필요한 주소 공간 / Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역등이 대상입니다. ​ 즉, 프로그램을 실행하게 되면 CPU의 일정 용량?을 차지하면서 수행하는 주체가 Process입니다. 하여, 프로그램은 하나인데 Process는 여러 개가 동작할 수 있습니다. (==인스턴스가 여러 개) 예를 들어 엑셀을 사용하고 있는데, 새로 만들기로 엑셀창을 하나 더 열 수도 있겠죠? 여기서 엑셀 실행파일이 Program, 엑셀창이 Process입니다. 간단히 1개의 Program으로 2개의 Process를 동작시킨 것입니다. ​ 🙋‍♂️ 이제 프로세스(Process)의 특징에 대하여 좀 더 알아봅시다. 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받습니다. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있습니다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없습니다. BUT 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용하면 가능해집니다. Ex) 파이프, 파일, 소켓통신, mapped file 등을 이용한 통신 방법 이용 ex) 실제로 엑셀의 경우 A엑셀파일, B엑셀파일이 있을 때, B의 특정 셀값을 A에서 불러와 사용할 수 있습니다. 즉, 프로세스간에 통신이 가능합니다. ​ ​ Thread 프로세스(Process) 내에서 실행되는 흐름의 단위으로 프로세스 하나에 자원을 공유하면서 일련의 과정, 여러 개를 동시에 실행시킬 수 있는 것을 말합니다. 기본적으로 하나의 프로세스가 생성되면 하나의 Thread가 같이 생성됩니다. 이를 Main Thread라고 부르며, thread를 추가로 생성하지 않는 한, 모든 프로그램 코드는 Main Thread에서 실행됩니다. ​ Multi Thread 그림을 보면 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유하고 ( Stack만 스레드 별로 가지게 됩니다. ) 하나의 프로세스는 여러 개의 스레드를 가질 수 있는데, 이를 Multi Thread라고 합니다. 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있습니다. ​ 🙋‍♂️ 다른 자원들은 공유하지만 굳이 스택만 분리해서 사용하는 이유는? LIFO(Last In First Out) / 후입 선출이라는 스택의 특성과도 연관이 있습니다. 왜냐하면? Code와 Data, Heap 영역을 공유하는 것에는 큰 문제가 없지만, 스택 영역은 스택이 쌓이면 위에서부터 프로세스가 섞인 채로 순서대로 나오게 되므로 더 복잡해지기 때문에 원활한 실행 흐름을 위해 스택은 따로 독립적으로 존재하게 됩니다. ​ ​ Multi Process 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업(태스크)을 처리하도록 하는 것. 😆 장점 안정성이 좋음 - 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않습니다. 😔 단점 Context Switching(여러 프로세스를 왔다 갔다 하는 것)에서의 오버헤드 Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 됩니다. 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 사이에서 공유하는 메모리가 없어, Context Switching가 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 합니다. 프로세스 사이의 어렵고 복잡한 통신 기법(IPC) ​ *오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. ​ ​ ​ 이런 단점들을 보완하기 위해 Multi Thread가 등장하였습니다. Multi Thread 하나의 프로세스 내에서 여러 개의 thread가 동작하는 것을 말합니다. 😆 장점 시스템 효율성이 향상됩니다. 프로세스에서 자원을 할당하는 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 즉, 시스템의 자원 소모를 줄일 수 있습니다. 시스템 처리량이 증가 됩니다. 스레드 사이에 작업량이 작아 Context Switching이 빠릅니다. 결과적으로 프로그램 응답 시간이 단축됩니다. 프로세스 간 통신 방법에 비해 thread간의 통신 방법이 간단합니다. ✔ 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다. ✔ Context Switching시 스레드는 Stack 영역만 처리하기 때문 😔 단점 여러 개의 스레드를 이용하는 경우, 미묘한 시간차나 잘못된 변수를 공유함으로써 오류가 발생할 가능성이 있습니다. 하여 Thread-Safety하게 구현해야 합니다. ex) 스레드1이 공유 자원 내의 A데이터를 조작하다가, 스레드2에 제어권을 넘겨준 이후 스레드2가 A데이터를 변경한다면 스레드1이 다시 제어권을 받아 남은 작업을 계속할 때 원치 않는 결과가 나올 수 있다. 프로그램 디버깅이 어렵습니다. 단일 프로세스 시스템에서는 효과를 기대하기 어렵습니다. ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:1:0","tags":["CS","Process","Thread","computer science","면접대비"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"Thread-Safety 스레드 안전(thread 安全, 영어: thread safety)은 멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의한다. Re-entrancy(재진입성) 어떤 함수가 한 스레드에 의해 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하더라도 그 결과가 각각에게 올바로 주어져야 한다. (동기화 잘 하라.) Mutual exclusion(상호 배제) 공유 자원을 꼭 사용해야 할 경우 해당 자원의 접근을 세마포어 등의 락으로 통제한다. (역시 동기화 잘 하라.ㅎ.) Thread-local storage(스레드 지역 저장소) 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막는다. (글로벌 변수 등의 사용을 남발하지 말라.) Atomic operations(원자 연산) 공유 자원에 접근할 때 원자 연산을 이용하거나 ‘원자적’으로 정의된 접근 방법을 사용함으로써 상호 배제를 구현할 수 있다. (역시 동기화 잘 하라는 건데, python 연산자를 예로 “+=“는 한줄의 코드 임에도 “+“를 한 후에 “=” 연산을 하기 때문에 원자적이라고 할 수 없다고 봅니다.) ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:0","tags":["CS","Process","Thread","computer science","면접대비"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["Computer Science"],"content":"부록 자바에서 동기화 방법 Synchronized Volatile Atomic Class ​ ​ 👀요약 운영체제는 Process 단위로 메모리를 할당해주고, 같은 프로세스 소속의 Thread는 메모리를 공유합니다. (스레드도 각자의 스택영역을 보유하므로 완전히 공유한다고 보기는 어렵습니다.) ​ ​ ","date":"2020-12-01","objectID":"https://colinder.github.io/processvsthread/:2:1","tags":["CS","Process","Thread","computer science","면접대비"],"title":"Process VS Thread","uri":"https://colinder.github.io/processvsthread/"},{"categories":["web"],"content":"​ HTTP vs HTTPS 웹개발 프로젝트를 하면서 인터넷 주소창(URL)을 자주 보게 되었습니다. 그러던 중 HTTP와 HTTPS의 차이를 발견하였고 단순히 HTTPS가 보안이 더 뛰어나서 적용하면 좋다. 정도의 개념만을 가지고 있다, ‘한 번 차이를 깔끔히 정리하면 좋겠다.’ 싶어 정리해보겠습니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:0:0","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"뜬금없이 URL란 무엇인지 우선 알아봅시다. 우리가 ‘인터넷 주소창’이라고 흔히 말하는 URL은 Uniform Resource Locator, 자원 위치 규약? 정도로 이해하면 좋을 것 같습니다. 우리가 사는 주소를 잠시 생각해봅시다. 먼저, 대한민국안에 서울특별시에 있는 강남구를 생각해보면 대한민국이라는 국가에서 서울특별시라는 위치로 그리고 그 안에 강남구로 범위를 좁히며 구체적인 위치를 생각할 수 있습니다. 이렇듯. URL은 인터넷 상의 여러 페이지의 주소입니다. 예를 들어, https://colinder.github.io/는 https://colinder.github.io/라는 페이지를 보여주고, https://colinder.github.io/hugo_setting/은 https://colinder.github.io/안에 hugo_setting/의 페이지도 이동하는 것이죠. URL과 웹 사이트 주소를 같은 것이라고 생각할 수 도 있는데, URL은 웹 사이트 주소보다 큰 개념이고, 웹 사이트 주소 뿐만 아니라 네트워크 상에 연결된 다양한 자원까지 포함된 개념입니다. URL은 위에서 말한대로 일종의 규약인데 URL에 접속하는 경우에는 해당 URL에 맞는 *프로토콜을 알아야 합니다. *FTP은 파일 전송을 위해, HTTP는 온라인 문서와 같은 리소스를 보기위해 사용합니다. 그리고 HTTP를 편리하게 이용할 수 있게 만든 응용 소프트웨어가 ‘웹 브라우저’(ex. 크롬, 사파리, 익스플로러)입니다. ​ *프로토콜: 복수의 컴퓨터 혹은 단말기와 데이터 통신을 원활하게 하기 위해 필요한 통신 규약 *FTP: File Transfer Protocol / 파일을 전송하는 방법 혹은 그런 프로그램 ​ ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:1:0","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"HTTP (HyperText Transfer Protocol) 이제 HTTP입니다! 위에서 살짝 언급했듯이, HTTP는 인터넷에서 웹 서버와 사용자(우리) 컴퓨터에 설치된 웹 브라우저 사이에 문서(DOM)를 전송하기위한 통신규약입니다. 저는 HT의 뜻이, HTTP를 이해하는데 핵심이라고 생각합니다. HyperText: 참조(하이퍼링크)를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트. 간단히 클릭을 통해 여러 문서를 이동하며 내용을 볼 수 있는 것입니다. 즉, http://colinder.github.io는 colinder.github.io라는 주소(도메인)을 HyperText Transfer Protocol 형태로 받아와서 보여주세요! 정도로 해석할 수 있습니다. ​ ​ 그럼 HTTPS는 무엇일까요? ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:2:0","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"HTTPS (HyperText Transfer Protocol + Secure Socket) HTTP + S(Secure Socket) 즉, HTTP에서 Secure Socket이 추가된 것이 HTTPS입니다. 간단히 HTTPS을 사용하면 암호화된 Protocol을 사용한다는 뜻입니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:0","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"🤔Secure Socket은 무엇일까요? Secure Socket은 SSL(Secure Socket Layer) 프로토콜을 의미하는데, 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약입니다. SSL는 과거의 명칭이고, SSL이 표준화되면서 TLS(Transport Layer Security)로 바뀌어 사용되고 있습니다. 보안이 어떻게 진행되는지 알아보겠습니다. 공개키와 대칭키로 암호문을 주고 받는 과정을 보며, 보안의 강점이 있는 것을 알았습니다. ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:1","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"🙄 좋은 점은 보안뿐일까요? HTTPS의 장점은 보안상 우위에만 있는 것이 아닙니다. 사실 HTTPS로 전환하게 되면 검색엔진 최적화(SEO)에 있어서도 큰 혜택을 볼 수 있습니다. (구글이 HTTPS 웹사이트에 가산점을 주어 검색시 노출에 혜택을 주겠다고 공표했습니다.) 사용자들이 결국에는 가장 안전하다고 생각하는 사이트를 더 많이 방문하기 때문이기도 합니다. 또한 가속화된 모바일 페이지(AMP, Accelerated Mobile Pages)를 만들고 싶을 때도 HTTPS 프로토콜을 사용해만 합니다. 여기서 AMP란 모바일 기기에서 훨씬 빠르게 콘텐츠를 로딩 하기 위한 방법으로 구글이 만든 것입니다. AMP는 HTML에서 불필요한 부분을 없앤 것이라고 볼 수 있습니다. 구글의 SERP(검색 결과 페이지)를 보면 스마트폰과 태블릿의 사용자들이 모바일에서 사용하기 편하도록 AMP 콘텐츠들이 두드러져 보이는 것을 볼 수 있습니다 모바일 친화적인 웹사이트를 만드는 것과 모바일 검색순위 및 지역에 SEO를 증가시키는 것이 점점 더 중요해지고 있는 요즘, HTTP를 HTTPS로 전환하는 것이 강점이 있다는 것을 알 수 있습니다. ​ ​ 👀요약 http와 https의 가장 큰 차이는 보안기술이 적용되었는지 아닌지가 맞았습니다. 다만, 보안이 우수한 사이트가 노출에 이점이 있다는 점. 어떤 보안 기술이 적용되고 있는지와 어떤식으로 보안 기술이 작동하는지 알 수 있었습니다. 추가로 직접 정리한 SSL 진행 절차가 보기 어려울 수 있어서 단계별로 정리해보겠습니다. 사이트 안전성 인증 받기 사용자와 사이트 간의 인증 내용 확인 사용자와 사이트 간의 통신 ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:3:2","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"참고한 글 https://post.naver.com/viewer/postView.nhn?volumeNo=16561296\u0026memberNo=1834 https://blog.globalhost.co.kr/19 https://12bme.tistory.com/80https://constant.kr/blog/2018/08/10/ssl-%EC%9D%B4%EB%9E%80-%EA%B5%AC%EA%B8%80%EC%97%90%EC%84%9C-ssl%EC%9D%84-%EC%A4%91%EC%9A%94%ED%95%98%EA%B2%8C-%EC%97%AC%EA%B8%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0/ http://blog.wishket.com/http-vs-https-%EC%B0%A8%EC%9D%B4-%EC%95%8C%EB%A9%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%EB%A0%88%EB%B2%A8%EC%9D%B4-%EB%B3%B4%EC%9D%B8%EB%8B%A4/ ​ ​ ","date":"2020-11-24","objectID":"https://colinder.github.io/httpvshttps/:4:0","tags":["http","web","https","면접대비"],"title":"HTTP VS HTTPS","uri":"https://colinder.github.io/httpvshttps/"},{"categories":["web"],"content":"​ 도메인(domain)이란? 도메인의 뜻은 무엇일까요? 어찌저찌 설명할 순 있지만, 확신을 가지고 정확하게 답할 수 없었기에 정리해보겠습니다. ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:0:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["web"],"content":"이번에도 뜬금없이 ‘IP’ 란 무엇인지 우선 알아봅시다. IP는 Internet Protocol의 약자로 인터넷에 연결되어 있는 장치(컴퓨터, 스마트폰, 타블릿, 서버 등등)들은 각각의 장치를 식별할 수 있는 주소를 가지고 있는데 이를 ip라고 합니다. 간단히 각 장치(device)들의 주민등록번호라고 생각하면 이해하는데 도움이 됩니다. ex) 125.209.222.141, 172.217.175.238 ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:1:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["web"],"content":"도메인(domain)이란? ip는 사람이 이해하고 기억하기 어렵기 때문에 쉽게 접근할 수 있게 각 ip에 고유한 이름을 부여할 수 있게 했는데, 이것을 도메인이라고 합니다. 125.209.222.141 =\u003e naver.com 172.217.175.238 =\u003e google.com 당연하게도 125.209.222.141과 naver.com은 같은 주소를 의미하니까 URL에 125.209.222.141를 입력하면 naver 메인 페이지로 이동할 수 있습니다. ​ ​ 👀요약 간단하게 IP와 도메인이란 무엇인지 알아봤습니다. 기초적인 지식일 수록 정확하게 알고 싶어서 정리해봤습니다. 간단하쥬?ㅎ 추가로 cmd를 켜고 nslookup \u003c인터넷도메인\u003e 을 입력하면 ip주소를 확인할 수 있습니다. ​ ","date":"2020-11-23","objectID":"https://colinder.github.io/what_is_domain/:2:0","tags":["web","ip","domain"],"title":"what is Domain","uri":"https://colinder.github.io/what_is_domain/"},{"categories":["Javascript"],"content":"​ Async to Sync in JavaScript 누구나 웹개발을 하다보면 HTTP 통신을 통해 데이터를 가져오고 가공하고 사용하게됩니다. 그리고 동기, 비동기 처리 때문에 골치가 아파집니다. (만약 골치가 아프지 않다면.. 부럽습니다..) 더 이상 골치아프기 싫어서 정리해봅시다.👍 *동기, 비동기 설명은 이전 포스팅으로 갈음합니다. ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:0:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"Async(비동기) to Sync(동기) 방법 자바스크립트에서의 비동기를 동기로 동작시키는 대표적인 3가지의 방법을 알아보겠습니다. Callback Promise Async / Await ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:1:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"1. Callback 개발자들 마다 정의가 조금씩 다르겠지만, 저는 어떤 이벤트가 발생한 후, 수행될 함수로 정의해보겠습니다. 예제를 보며 이해해 봅시다. // Callback 사용 예제 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 callback이라는 함수를 받는다. const data = 'i am data' // i am data라는 값을 담은 변수 data를 생성 callback(data) // callback이라는 함수에 data라는 변수를 넘겨줌. } function b(value) { // 함수 b는 입력받은 값 value를 콘솔에 출력하는 함수. console.log('넘겨받은 값', value) } // 사용해 봅시다. a(function(value) { // 함수 a에 function을 받는데 값으로 value를 받는다. console.log('넘겨받은 값', value) // 함수 a가 실행되면 자동으로 const data를 만드는데 data에는 'i am data'라는 값이 할당. 되고 value가 된다. }) // 위를 간소화한 코드. a(b) ​ 위의 예제 코드가 눈에 들어왔다면, 먼저 비동기적 코드를 만들어 봅시다. // Callback 비동기적 코딩 // a가 동작하고 b가 동작하길 원하며 코딩 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 2초 후에 동작 setTimeout(function() { console.log('running a....') }, 2000) } function b() { // 함수 b는 1초 후에 동작 setTimeout(function() { console.log('running b....') }, 1000) } // 실행해봅시다. a() b() setTimeout이라는 javascript의 가장 대표적인 동작 지연 함수를 사용해 코딩해보았고 결과로 a → b의 순서가 아닌 함수 동작 시간에 따른 딜레이를 확인해보았습니다. ​ 어떻게 해야 내가 코딩한 순서대로 (a → b) 동기적으로 작동하게 만들 수 있을까요? // Callback 동기적 코딩 // a가 동작하고 b가 동작하길 원하며 코딩 // a와 b라는 함수를 선언 function a(callback) { // 함수 a는 2초 후에 동작 setTimeout(function() { console.log('running a....') callback() // 👈 callback함수를 추가 }, 2000) } function b() { // 함수 b는 1초 후에 동작 setTimeout(function() { console.log('running b....') }, 1000) } // 실행해봅시다. a(b) 원하는 동작 console.log(‘runing a….’)뒤에 callback함수를 넣어 console.log(‘runing b….’)를 동작했습니다. 간단해보이지만 강력하고, 막상 적용하려면 어려울 수 있습니다. 연습을 추천합니다.😊 근데 callback 함수는 대부분의 개발자들이 간단한 코딩에만 사용합니다. 단순히 1, 2개 정도의 요청이라면, callback 함수로 처리할 수 있지만, 만약 그 수가 많아진다면, 소위 callback HELL이 되기 때문입니다. 그래서 다른 방법도 알아봅시다! ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:2:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"2. Promise Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다. 간단히 비동기 작업에 사용되는 객체입니다. Promise는 ex) new Promise ( function ( resolve, reject )) 의 형태로 사용됩니다. 특징으로 Promise의 인자는 반드시 function을 받아야 합니다. (동작 성공시 실행될 resolve라는 함수와 실패시 동작할 reject / 2개의 인자를 받습니다.) Promise 는 3가지 상태가 존재합니다. 만약 인자를 받지 않거나 함수 이외의 값을 전달하면, Uncaught TypeError가 발생하고, 인자로 전달된 resolve 와 reject 중 하나라도 호출하지 않는다면, 영원히 pending 상태로 대기하게 됩니다. 또 Promise 객체들은 .then() 을 통해 이어질 수 있고 .catch() 를 통해 에러 캐치를 할 수 있습니다. 이 부분을 활용해 동기 처리를 합니다. // Promise 사용 예제 function test() { // test라는 동작(함수)을 만드는데 return new Promise(function(resolve, reject) { // Promise로 만들고 Promise는 인자로 resolve, reject를 받는다. try { // 정상처리되면(조건은 다양하게 구성) resolve( // resolve를 동작하는데 console.log('Promise resolve') // Promise resolve를 출력하고 ) } catch { // error가 발생하면 reject( // reject를 동작하는데 console.log('Promise reject') // Promise reject를 출력한다. ) } }) } test() // test를 동작(함수실행)하는데 .then((res) =\u003e // 에러가 없다면 console.log('정상 처리 완료') // '정상 처리 완료'를 출력하고 ) .catch((err) =\u003e // 에러가 발생했다면 console.log('에러 발생') // '에러 발생'을 출력한다. ) ​ 위의 예제 코드가 눈에 들어왔다면, 이제 동기적 코드를 보며 이해해봅시다. // Promise 동기적 코딩 // 1,2,3 순서대로 출력되길 원하며 코딩 function test() { // test라는 동작(함수)을 만드는데 return new Promise(function(resolve, reject) { // Promise로 만들고 Promise는 인자로 reselve, reject를 받는다. try { setTimeout(function() { // AJAX등의 처리를 기다리는 '지연 시간'을 setTimeout으로 설정 resolve( console.log('1') ) // resolve처리를 하는데 3초의 딜레이를 주고 },3000) console.log('2') // resolve } catch { reject( console.log('reject running') ) } }) } function b() { setTimeout(function() { console.log('3') }, 1000) } // 실행해봅시다. test() .then(b) // .then(function() {b()}) ////////////////////////////////////////////////////////////////////////////////////// // .then(b) === .then(function() {b()}) === .then(() =\u003e {b()}) !== .then(b()) // .then(b) / .then(function() {b()}) / .then(() =\u003e {b()})는 // \"test함수에 오류가 없다면 b함수를 return 하라\" 라는 의미기 때문에 동기적인 처리가 가능! // 반면 .then(b())는 \"test함수에 오류가 없으면 b라는 함수를 실행하라\" 라는 의미기 때문에 // 순서에 상관없이 오류가 없다면 b를 즉시 실행한다. // 비슷하게... // .then(console.log('hi'))는 \"요청들어오면 hi를 출력하라\" 라는 의미고 // .then(function() {console.log('hi')}) or .then(() =\u003e {console.log('hi')})는 // \"어떤 요청의 결과로 hi를 return하라\" 하는 의미기 때문에 동기적으로 동작한다. 위 설명에는 1,2,3 순서대로 출력되길 원하며 코딩이라고 적어놨지만, 결과 화면은 다른 것을 알 수 있습니다. 실은 2,1,3 순서대로 출력되는 것을 의도한 코딩입니다. 2의 경우 resolve에 포함되어 있지 않기 때문에 *인터프리터 언어 특징에 따라 진행되기 때문입니다. *인터프리터 언어의 특징은 다른 포스팅에 정리되어 있습니다. ​ 하지만 Promise 또한 단계?가 많아진다면 가독성 매우 떨어질 수 있습니다. 사실 callback과 Promise를 사용하는데 가독성에 문제가 있다면, 본인의 코드를 의심해봐야 될 수 있습니다.👀ㅎ. ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:3:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"3. Async / Await Async(비동기) / Await(기다려!)는 비동기 처리를 하는 방법 중 하나입니다. Promise 나 Callback 보다 가독성이 좋은 코드를 짤 수 있다고 생각합니다. 위에 Promise를 살펴본 이유가 있습니다. Async/await의 기반이 Promise이기 때문입니다. 우리가 쓰는 모든 async 함수는 Promise를 리턴하고, 모든 await 함수는 일반적으로 Promise가 됩니다. Async/await는 ex) async function functionName() { await promiseFunction } 의 형태로 사용됩니다. sync function은 내부에 await 문법을 사용하기 위해 선언합니다. async function은 AsyncFunction 객체를 반환하며 ‘async function’ 표현식으로만 생성됩니다. async function은 인자를 받을 수 있으며, 실행 후 반환 값은 Promise 입니다. await 연산자는 async function 내부에서만 사용할 수 있습니다. (외부에서 사용하면 SyntaxError가 발생.) await는 반환된 Promise의 resolve의 상태까지 대기하며, await의 값은 Promise의 resolve값이 반환됩니다. 만약 중간에 reject를 만나면 해당 async function스코프의 작업을 중단되며, 이후 스코프 작업이 진행됩니다. // Async/Await 사용 예제 function promise() { return new Promise(function(resolve, reject) { resolve(10) }) } async function foo() { const num = await promise() console.log(num) } // 돌려봅시다! foo() // 10 ​ 위의 코드가 이해 되셨다면 동기적 사용에 대한 코드를 보며 이해해 봅시다. // Async/Await 동기적 코딩 function promise() { console.log('AsyncAwait running...') return new Promise(function(resolve, reject) { setTimeout(function() { resolve(10) }, 5000) }) } async function foo() { console.log('foo running...') const num = await promise() console.log('num:', num) } // 돌려봅시다! foo() 가독성이 훨씬 뛰어나다고 생각합니다. Promise를 선언하고 이를 await 걸어, 순서를 정리하는 방법으로 코딩을 하다보니 가독성은 좋지만, Promise의 사용법도 익혀야 한다는 단점이 있습니다. ​ 👀요약 공부한 3가지 방법 모두 유용하고 강력한 기능이라는 생각입니다. 모두를 익히면 좋고 선택적으로 익혀야 한다면 본인에게 잘 맞는 방법으로 익혀 사용하면 좋을 것 같습니다. ​ ​ 🤷‍♂️삽질 Async/Await 관련해서 혼자 이런 저런 테스트를 해보니 위에 설명한 것과 같이 new Promise()로 선언한 것들만 동기적으로 작동했고 일반 function으로 선언한 것들은 원하는 대로 동작하지 않았습니다. 또 주의할 점에 // 여러 test 중 하나. function promise() { console.log('AsyncAwait running...') return new Promise(function(resolve, reject) { setTimeout(function() { resolve(10) }, 5000) }) } function test2Promise() { console.log('test2Promise 시작') return new Promise(function(resolve, reject) { setTimeout(()=\u003e { console.log('test2Promise running...') // 👈 Promise의 resolve가 없습니다. },3000) }) } async function foo() { console.log('foo running...') const num = await promise() // await test1() await test2Promise() console.log('num:', num) } // 돌려봅시다! foo() test2Promise의 resolve를 등록하지 않으면 이전 Promise()인 promise()도 resolve가 정상적으로 진행되 않는 것을 볼 수 있습니다. 위에서 설명한 만약 인자를 받지 않거나 함수 이외의 값을 전달하면, Uncaught TypeError가 발생하고, 인자로 전달된 resolve 와 reject 중 하나라도 호출하지 않는다면, 영원히 pending 상태로 대기하게 됩니다. 가 발생한 것입니다. ​ 공부를 하던 중 .then()에 대한 흥미로운 내용을 확인했습니다. .then()은 요청의 결과가 성공했을 때 사용하는 것으로만 생각했는데 인자를 2개 받는 다는 것을 알았습니다. 확인해보니 .then() 에 넘겨지는 인자는 선택적(optional)이었습니다. 그리고 catch(failureCallback) 는 then(null, failureCallback) 의 축약었습니다. ​ ​ ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:4:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Javascript"],"content":"참고 했던 글 https://medium.com/@olaf.go/javascript-async-to-sync-157c57208598 https://victorydntmd.tistory.com/48 https://medium.com/@pks2974/javascript-%EC%99%80-promise-a6db8ca424ed https://joshua1988.github.io/web-development/javascript/js-async-await/ https://medium.com/@pks2974/javascript-%EC%99%80-async-await-111fdad3c20d https://mber.tistory.com/8 https://medium.com/@kiwanjung/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4 https://joshua1988.github.io/web-development/javascript/promise-for-beginners/#promise%EA%B0%80-%EB%AD%94%EA%B0%80%EC%9A%94 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise ​ ​ Special Thanks to kmpak.sfy✨. ","date":"2020-11-20","objectID":"https://colinder.github.io/asynctosyncinjavascript/:5:0","tags":["Async","Sync","Javascript"],"title":"Async To Sync in Javascript","uri":"https://colinder.github.io/asynctosyncinjavascript/"},{"categories":["Interpreter","Compiler"],"content":"​ Interpreter VS Compiler_Language web 개발을 하다보면 javascript를 공부하게 되고, javascript를 공부하다보면, 어려워지죠ㅎ. 더 어려워 지기 전에 기초적인 지식?인 인터프리터 언어와 컴파일 언어의 특징과 차이에 대하여 알아봅시다! ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:0:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"뜬금없이 프로그래밍 언어란 무엇인지 우선 알아봅시다. 컴퓨터는 이진수만 이해할 수 있습니다. 즉 컴퓨터는 우리가 사용하는 언어가 아닌 ‘0’, ‘1’만 이해합니다. 근데 이게 프로그래밍 언어랑 무슨 상관일까요? 상관이 아주 많습니다…ㅎ.. 프로그래밍 언어로 프로그램을 만들고 실행 할 때 우리는 ‘0’, ‘1’ 같은 명령어로 코딩을 하지 않습니다. 도대체 우리가 영어로 작성한(C, java, python 등등) 코딩을 어떻게 컴퓨터가 이해하고 실행하는 것일까요? 모든 프로그래밍언어는 그 프로그래밍 언어를 기계어 명령어로 번역해 줄 번역기가 존재합니다. 그리고 그 번역기가 영문으로 된 프로그래밍 언어(사람이 이해하기 쉬운 언어를 고급 언어라고 부릅니다.)를 ‘0’, ‘1’로(기계어 명령어) 번역해줍니다. 추가로 누구나, 프로그래밍 언어를 배울 때 환경 설정을 하게 됩니다. 예를 들어 자바라면 JDK를 설치하고, 파이썬이라면 파이썬을 설치하고, C라면 gcc와 같은 프로그램을 설치합니다. 여러분이 프로그래밍 언어를 배우기 위해 환경 설정 할 때 설치했던 바로 그 개발환경설정 툴 중에 이 번역기가 반드시 포함되어 있습니다. *근데 번역기는 번역 시기에 따라 크게 인터프리터 언어와 컴파일러 언어로 구분합니다. ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:1:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"Interpreter_Language(인터프리터 언어) 고급 언어로 작성된 소스코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 언어. javascript, HTML, SQL, python, R, ruby 등 고급 언어를 한 줄씩 중간 코드(intermediate code)로 변환하고 이를 각 행마다 실행합니다. 100줄의 명령어(==소스파일)가 있으면, 100번 실행합니다. 즉, Runtime상황에서는 한 줄씩 실시간으로 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느립니다. But 실행속도는 느리지만 코드 변경시 빌드 과정없이 바로 실행이 가능하다는 장점이 있습니다. javascript를 사용해보면 소스코드를 고치고 서버를 다시 시작하지 않아도 변경사항이 반영된 상태로 테스트를 진행할 수 있습니다. 또한 명령어을 잘못 입력해도 바로바로 수정할 수 있습니다. 또한 실행중에 발생한 에러가 각 행(row)별로 전달되는데, 에러 이후 작성된 코드는 확인하지 않습니다. 이는 보안적인 관점에서 도움이 됩니다. ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:2:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["Interpreter","Compiler"],"content":"Compiler_Language(컴파일러 언어) 고급 언어로 작성된 소스코드 명령어들을 모두 모아 기계어로 번역(build) 하고 이를 실행하는 언어. build ? build는 소스파일을 실행파일로 생성하는 과정입니다. 즉, 고급언어 =\u003e (변환) =\u003e 저급언어(기계어) 과정을 거쳐서 실행파일로 생성해 구동합니다. C, C++. C# 등. 소스코드를 기계어로 번역하는 빌드 과정에서는 인터프리터 언어에 비해 시간이 소요됩니다. 하지만 Runtime상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 빠르게 실행할 수 있습니다. 메모리도 많이 차지합니다. ​ ​ ","date":"2020-11-18","objectID":"https://colinder.github.io/interpretervscompiler_language/:3:0","tags":["Web"],"title":"Interpreter VS Compiler_Language","uri":"https://colinder.github.io/interpretervscompiler_language/"},{"categories":["react-native"],"content":"​ React-Native google login 서비스를 개발하다보면 로그인 기능이 새삼 대단해보입니다. 신경쓸 것도 많고, 하지만 이런 수고를 sns로그인 기능으로 대신한다면 편의성이 많이 높아집니다. 하여 해보겠습니다. *google login을 하기 위해 firebase(모바일 및 웹 애플리케이션 개발 플랫폼)을 사용합니다. 개발환경 npm으로 진행 react-native_cli (✨expo로 진행하지 않습니다.) android 기준 함수형 컴포넌트로 진행 (✨ 클래스 컴포넌트로 진행하지 않습니다.) RN 버전 0.60이상에서 진행 react-native-cli: 2.0.1 react-native: 0.63.3 ​ googleSignin 프로젝트 생성 후 googleSignin.js 생성 ​ index.js 에서 시작앱 변경 # index.js /** * @format */ import {AppRegistry} from 'react-native'; import App from './googleSignin'; // 변경 import {name as appName} from './app.json'; AppRegistry.registerComponent(appName, () =\u003e App); ​ googleSignin.js 틀 잡기 # googleSignin.js import React from 'react' import { View, Text } from 'react-native' const googleSignin = () =\u003e { return ( \u003cView\u003e \u003cText\u003egoogle Sign in\u003c/Text\u003e \u003c/View\u003e ) } export default googleSignin ​ react native google login github 이동 후 root폴더 에서 google-signin 설치 npm install --save @react-native-community/google-signin ​ Andriod guide로 이동 google-services.json 파일을 generate해야 한다고 합니다. 이걸 위해 firebase에 등록하러 갑시다. ​ firebase 이동 프로젝트 추가 (+) Android 패키지 이름 추출 *root/android/app/src/main/AndroidManifest.xml 에서 확인 sha1 추출 # root/android/app으로 이동 # terminal keytool -list -v -keystore debug.keystore -alias androiddebugkey -storepass android -keypass android 다시 firebase에서 안드로이드 설정 선택 앱 등록 진행 하다보면 google-services.json다운이 가능 *혹시 에러 뜨면 pakage name변경 진행 # In: android/app/src/main/java/MY/APP/NEW_ID/MainActivity.java: package 새로운 패키지 이름 등록; # In: android/app/src/main/java/MY/APP/NEW_ID/MainApplication.java: package 새로운 패키지 이름 등록; # In: android/app/src/main/AndroidManifest.xml: package=\"새로운 패키지 이름 등록\" # And in android/app/build.gradle: applicationId \"새로운 패키지 이름 등록\" # In: android/app/BUCK: android_build_config( package=\"새로운 패키지 이름 등록\" ) android_resource( package=\"새로운 패키지 이름 등록\" ) # Gradle' cleaning in the end (in /android folder): ./gradlew clean google-services.json다운 후 root/android/app안에 넣기 ​ 다시 Andriod guide로 돌아와서 2. Installation 진행 link the native module (난 RN \u003e= 0.60니까 pass) Update android/build.gradle with buildscript { ext { buildToolsVersion = \"27.0.3\" minSdkVersion = 16 compileSdkVersion = 27 targetSdkVersion = 26 supportLibVersion = \"27.1.1\" googlePlayServicesAuthVersion = \"16.0.1\" // \u003c--- use this version or newer 👈(추가) } ... dependencies { classpath 'com.android.tools.build:gradle:3.1.2' // \u003c--- use this version or newer 👈(default로 입력되어 있었음) classpath 'com.google.gms:google-services:4.1.0' // \u003c--- use this version or newer 👈(추가) } ... allprojects { repositories { mavenLocal() google() // \u003c--- make sure this is included 👈(default로 입력되어 있었음) jcenter() maven { // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url \"$rootDir/../node_modules/react-native/android\" } } } Update android/app/build.gradle with ... dependencies { implementation fileTree(dir: \"libs\", include: [\"*.jar\"]) implementation \"com.android.support:appcompat-v7:23.0.1\" implementation \"com.facebook.react:react-native:+\" implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.0.0' // \u003c-- add this; newer versions should work too 👈(default로 입력되어 있었음) } ... ... apply plugin: 'com.google.gms.google-services' // \u003c--- 👈 this should be the last line 이후 내용은 link관련인데. 난 RN \u003e= 0.60니까 pass ​ 다시 react native google login github을 참고하며 진행 GoogleSignin # googleSignin.js import { GoogleSignin, GoogleSigninButton, statusCodes } from '@react-native-community/google-signin'; # googleSignin.js const googleSignin = () =\u003e { useEffect(() =\u003e { GoogleSignin.configure({ scopes: ['https://www.googleapis.com/auth/drive.readonly'], // what API you want to access on behalf of the user, default is email and profile webClientId: '\u003c요기는 firebase를 참고해서 입력합니다.\u003e', // client ID of type WEB for your server (needed to verify user ID and offline access) offlineAccess: true, // if you want to access Google API on behalf of the user FROM YOUR SERVER // hostedDomain: '', // specifies a hosted domain restriction // loginHint: '', // [iOS] The user","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_googlelogin/:0:0","tags":["react-native","web"],"title":"React-Native_google login","uri":"https://colinder.github.io/react-native_googlelogin/"},{"categories":["react-native"],"content":"참고 했던 글 https://www.youtube.com/watch?v=A1Ai4sKk0jM https://medium.com/humanscape-tech/hooks-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-usestate-useeffect-811636d1035e 패키지 이름 변경: https://stackoverflow.com/questions/37389905/change-package-name-for-android-in-react-native ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_googlelogin/:1:0","tags":["react-native","web"],"title":"React-Native_google login","uri":"https://colinder.github.io/react-native_googlelogin/"},{"categories":["react-native"],"content":"​ React-Native navigation vue는 router를 사용해 화면을 이동합니다. 그렇다면, react-native는 어떻게 화면을 이동할까요? 바로 react-native navigation을 사용합니다. 어떻게 사용하는건지 기록합시다. 공식홈페이지의 Getting started로 알아봅시다. ​ *새로운 프로젝트를 만들고 root폴더에서 진행. 개발환경 npm으로 진행 react-native_cli (✨expo로 진행하지 않습니다.) android 기준 함수형 컴포넌트로 진행 (✨ 클래스 컴포넌트로 진행하지 않습니다.) RN 버전 0.60이상에서 진행 react-native-cli: 2.0.1 react-native: 0.63.3 ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:0:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"React-Native navigation 개발환경세팅 Getting started의 npm설치 npm install @react-navigation/native ​ 화면을 조금 내려서 dependency도 설치 npm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view ​ entry file파일에 import 등록 제가 개발하는 당시 기준 index.js를 보면 9번 줄에 App에서 시작이 된다고 명시되어 있음으로 App.js (a.k.a entry file) 최상단에 import를 등록합니다. import 'react-native-gesture-handler'; *기본적인 사용환경 설정은 완료되었습니다. 다만, stack이라는 기술을 사용할 예정이라 추가로 진행할 것이 있습니다. ​ 공식문서의 stack navigator library로 이동 후 설치 npm install @react-navigation/stack *이제 정말 개발 환경 설정이 완료되었습니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:1:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"React-Native navigation 사용해보자 페이지를 이동하는 것과 페이지를 이동할 때 params(인자)를 같이 넘겨주는 방법을 기록합니다. 먼저, root폴더에 src라는 폴더를 만들고 / home.js와 user.js 파일을 만듭니다. (함수형으로 개발하니 rnfe + tab을 입력해 양식을 빠르게 불러올 수 있습니다.) 틀을 잡고 시작합니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:0","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"페이지 이동(RN navigation) import → entry file 코딩→ components 코딩 순서로 진행합니다. 설치한 navigation과 stack을 import 해줍니다. # App.js import 'react-native-gesture-handler'; import React from 'react' import { NavigationContainer} from '@react-navigation/native' //👈 import { createStackNavigator} from '@react-navigation/stack' //👈 ... const Stack = createStackNavigator(); //👈 추가로 stack을 사용하기 위해 변수 선언 ​ Usage # App.js import 'react-native-gesture-handler'; import React from 'react' import { NavigationContainer} from '@react-navigation/native' import { createStackNavigator} from '@react-navigation/stack' import HomeScreen from './src/home' import UserScreen from './src/user' const Stack = createStackNavigator(); const App = () =\u003e { return ( \u003cNavigationContainer\u003e \u003cStack.Navigator initialRouteName='Home'\u003e \u003cStack.Screen name='Home' component={HomeScreen}/\u003e \u003cStack.Screen name='User' component={UserScreen}/\u003e \u003c/Stack.Navigator\u003e \u003c/NavigationContainer\u003e ) } export default App # NavigationContainer (Fragments같은 겁니다.) # initialRouteName: 초기 화면을 Home으로 설정했습니다. ​ home.js와 user.js도 코딩합니다 # home.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { //👈 navigation을 등록 return ( \u003cView\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ //👈 onPress: 버튼이 눌리면 실행 navigation.navigate('User') //👈 이런 문법으로 사용 }} /\u003e \u003c/View\u003e ) } export default HomeScreen # user.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { // navigation을 등록 return ( \u003cView\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ navigation.navigate('Home') // 이런 문법으로 사용 }} /\u003e \u003c/View\u003e ) } export default UserScreen 이 상태에서 시뮬레이터를 돌려보면 화면 전환이 되는 것을 볼 수 있습니다. But 할 것이 남았습니다. 이제 params도 전달 해봅시다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:1","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["react-native"],"content":"페이지 이동 with params navigation.navigate(A, B)는 두개의 인자를 받습니다. A는 이동할 컴포넌트의 ‘이름’, B가 ‘params‘입니다. (아래는 home.js → user.js로 params를 보내는 예제입니다.) ​ home.js에서 전달할 params를 구성합니다. # home.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const HomeScreen = ({ navigation }) =\u003e { return ( \u003cView style={{ // 화면에 보기 좋게 간단한 스타일 설정 flex: 1, alignItems: 'center', justifyContent: 'center' }}\u003e \u003cText\u003eHome Screen\u003c/Text\u003e \u003cButton title=\"To User Screen\" onPress={()=\u003e{ navigation.navigate('User', { // 두번째 인자 입력 userIdx: 100, userName: 'jong', userLastName: null, }) }} /\u003e \u003c/View\u003e ) } export default HomeScreen ​ user.js에서 parmas를 받습니다. # user.js import 'react-native-gesture-handler'; import React from 'react' import { Text, View, Button } from 'react-native' const UserScreen = ({ route, navigation }) =\u003e { // route를 인자로 받음. const { userIdx, userName, userLastName } = route.params; // 전달받은 값(route) return ( \u003cView\u003e \u003cText\u003eUser Screen\u003c/Text\u003e \u003cButton title=\"To Home Screen\" onPress={() =\u003e { navigation.navigate('Home') }} /\u003e \u003cText\u003eUser Idx: {JSON.stringify(userIdx)}\u003c/Text\u003e {/* JSON의 string으로 받습니다. */} \u003cText\u003eUser Name: {JSON.stringify(userName)}\u003c/Text\u003e { route.params.userLastName \u0026\u0026 \u003cText\u003eUser LastName: {JSON.stringify(userLastName)}\u003c/Text\u003e} {/* 조건을 줘봤습니다. {인자가 있을 때만 \u003cText\u003e로 값을 표시} */} \u003c/View\u003e ) } export default UserScreen ​ *결과 화면 home.js user.js ​ ​ 👀요약 지금까지 components간의 이동과 params, 간단한 스타일의 적용을 알아봤습니다. 해보면 어렵지 않으나, 모르면 다른 세상 이야기같습니다. 다음은 react-native에 google login을 심어보겠습니다. ​ ","date":"2020-10-29","objectID":"https://colinder.github.io/react-native_navigation/:2:2","tags":["react-native","web"],"title":"React-Native_navigation","uri":"https://colinder.github.io/react-native_navigation/"},{"categories":["web"],"content":"​ 개발을 하다보면, 유저의 로그인 기능을 고민하는 경우가 많습니다. 근데. 로그인 기능을 개발하다보면 꼭 마주치는 두 가지… cookie와 session에 대하여 알아보겠습니다. 다만 그전에 cookie와 session이 생기게 된 배경에 대하여 같이 알아 보겠습니다. ​ HTTP 프로토콜의 특징 HTTP는 Connectionless(비연결성)하고, Stateless하다고 합니다. Connectionless란, 클라이언트가 행위를 통해 서비스를 제공받기 위해 서버에 request(요청)를 하면 서버는 클라이언트의 요청값에 따라 클라이언트에게 response(응답)하게 됩니다. 이렇게 한번의 request — response의 결과로 클라이언트는 어플리케이션이 제공하는 서비스를 받게되면서, 서로의 접속을 끊게 된다는 특성입니다. Stateless란, 접속을 끊는 순간 서버와 클라이언트간의 통신이 끊키고 상태정보를 유지하지 않는다는 특성입니다. 이 두가지 특성은 장점이자 단점이 되는데, 접속을 유지함에 따르는 리소스를 줄일 수 있는 장점과 통신을 할때마다 클라이언트 인증을 해야한다는 단점이 있습니다. 그리고 이러한 단점을 보완하기 위해 쿠키, 세션이 생기게 되었습니다. ​ 쿠키(cookie)란? 웹 서버가 브라우저에게 지시하여 사용자의 로컬 컴퓨터에 파일 또는 메모리에 사용자 식별 정보를 저장하는 작은 테이터 파일입니다. 어떤 말인지 모르겠죠? ㅎ.. 📃 쿠키는 주로 아래의 세 가지 목적을 위해 사용됩니다. 세션 관리(Session Management) 로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장합니다. 개인화(Personalization) 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있습니다. 트래킹(Tracking) 사용자의 행동과 패턴을 분석하고 기록합니다. ​ 흐름을 보며 더 구체적으로 알아봅시다! 클라이언트(사용자)가 브라우저(사용자PC)를 통해 방문한 적 없는 페이지에 접속하면, 서버는 “세션 식별자(session identifier)” 정보를 담아 쿠키를 설정하여 제공(응답)한다. 제공받은 cookie는 클라이언트의 사용자PC(로컬 하드)에 저장된다. A FEW TIMES LATER.... 나중에 클라이언트가 재접속시 사용자PC(로컬 하드)에 있던 Set-cookie값을 서버측으로 전송한다. 서버측에서는 쿠키로 사용자를 인식하고 서비스 로직에 따라 클라이언트의 cookie값을 update 하게 된다. *새로운 페이지에 접근하기전에는 클라이언트(사용자)에게 쿠키가 없습니다. *서버는 쿠키를 보낼때 이 쿠키를 사용할 Domain과 Path정보까지 함께 브라우저로 전송합니다. 즉, Domain과 Path는 쿠키를 어느 도메인의 어느 패스에서 인증하는데 사용할지 브라우저에게 알려주고 브라우저는 Domain과 Path가 일치할 때만 쿠키를 서버로 전송해서 사용자를 인증 받습니다. 일단 그렇게 알고 봅시다ㅎㅎ. ​ 근데 쿠키에는 “세션 식별자(session identifier) 정보”가 담겨 있다고 했는데 쿠키는 어떻게 구성되어 있을까요? 또 어떻게 접근해서 정보를 보는 걸까요? 알아봅시다! ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:0:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 문법 // 쿠키는 \"이름=값\" 페어로 시작됩니다. Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Expires=\u003cdate\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Max-Age=\u003cnon-zero-digit\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Domain=\u003cdomain-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Path=\u003cpath-value\u003e Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Secure Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; HttpOnly Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; SameSite=Strict Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; SameSite=Lax // Multiple directives are also possible, for example: Set-Cookie: \u003ccookie-name\u003e=\u003ccookie-value\u003e; Domain=\u003cdomain-value\u003e; Secure; HttpOnly ​ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:1:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 읽기 document.cookie 프로퍼티를 이용하면 브라우저에서도 쿠키를 확인할 수 있습니다. // ex) alert( document.cookie ); // cookie1=value1; cookie2=value2;... // 모든 쿠키를 알림창으로 확인하겠다.는 명령어 // 어디든 사이트에 들어가서 개발자 도구창을 열고 console.log(document.cookie) 를 입력해 보세요! document.cookie는 name=value쌍으로 구성되어있고, 각 쌍은 ;로 구분합니다. (ex. document.cookie = “cookiename=value; path=/; expires=0; domain=.tistory.com”) 이때, 쌍 하나는 하나의 독립된 쿠키를 나타냅니다. 정규 표현식이나 배열 관련 함수를 함께 사용해 ;을 기준으로 document.cookie의 값을 분리하면 원하는 쿠키를 찾을 수 있습니다. ​ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:2:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"쿠키 구성요소 쿠키는 다음의 요소들로 구성됩니다. name (쿠키의 이름) 필수 value (쿠키에 저장된 값) 필수 domain (쿠키를 발급해준 서버의 도메인(사이트) 주소) domain=site.com 쿠키에 접근 가능한 domain(도메인)을 지정합니다. 다만, 몇 가지 제약이 있어서 아무 도메인이나 지정할 수 없습니다. domain 옵션에 아무 값도 넣지 않았다면, 쿠키를 발급받은 사이트(도메인)에서만 쿠키에 접근할 수 있습니다. site.com에서 생성한 쿠키를 other.com에선 절대 전송받을 수 없습니다. 이 외에 까다로운 제약사항이 하나 더 있습니다. 서브 도메인(subdomain) (ex. forum.site.com)에서도 쿠키 정보를 얻을 수 없다는 점입니다. // ex) site.com에서 user가 colinder라는 쿠키를 설정함 document.cookie = \"user=colinder\" // site.com의 서브도메인인 forum.site.com에서 쿠키에 접근하려 함 alert(document.cookie); // 찾을 수 없음 이런 제약사항은 안정성을 높이기 위해 만들어졌습니다. 민감한 데이터가 저장된 쿠키는 관련 페이지에서만 볼 수 있도록 하기 위함입니다. 하지만, forum.site.com과 같은 서브 도메인에서 site.com에서 생성한 쿠키 정보를 얻을 방법이 있습니다. site.com에서 쿠키를 설정할 때 domain 옵션에 루트 도메인인 domain=site.com을 명시적으로 설정해 주면 됩니다. // site.com에서 // 서브 도메인(*.site.com) 어디서든 쿠키에 접속하게 설정할 수 있습니다. document.cookie = \"user=colinder; domain=site.com\" // 이렇게 설정하면 // forum.site.com와 같은 서브도메인에서도 쿠키 정보를 얻을 수 있습니다. alert(document.cookie); // user=colinder 쿠키를 확인할 수 있습니다. 하위 호환성 유지를 위해 (site.com 앞에 점을 붙인) domain=.site.com도 domain=site.com과 동일하게 작동합니다. 오래된 표기법이긴 하지만 구식 브라우저를 지원하려면 이 표기법을 사용하는 것이 좋습니다. 이렇게 domain 옵션값을 적절히 사용하면 서브 도메인에서도 쿠키에 접근할 수 있습니다. path (쿠키로 사용자를 인증받을 수 있는 경로 설정) path=/ 서버 이름 뒤에 오는 경로(ex. site.com/login, site.com/main 등)에 따라 쿠키 사용여부가 결정됩니다. 위와 같이 슬래쉬( / )로 설정하면 모든 path에서 쿠키를 사용할 수 있습니다. (미 지정시) 기본값은 현재 경로입니다. path=/admin 옵션을 사용하여 설정한 쿠키는 /admin과 /admin/something에선 볼 수 있지만, /home 이나 /adminpage에선 볼 수 없습니다. 특별한 경우가 아니라면, path 옵션을 path=/같이 루트로 설정해 웹사이트의 모든 페이지에서 쿠키에 접근할 수 있도록 합니다. expires (쿠키의 만료시간) 쿠키가 언제 삭제되는지 결정합니다. 쿠키는 지속 쿠키(Persistent Cookie)와 세션 쿠키(Session Cookie)로 나눌 수 있습니다. 지속 쿠키(Persistent Cookie) 만료 날짜/시간(expires 나 max-age )을 지정하지 않은 쿠키 파일로 저장되므로 브라우저가 종료되어도 쿠키는 남아있습니다. 세션 쿠키(Session Cookie) 만료 날짜/시간(expires 나 max-age )을 지정한 쿠키 브라우저 메모리에 저장되므로 브라우저가 종료되면 쿠키는 사라지게 됩니다. expires와 max-age expires ex) expires=Tue, 19 Jan 2038 03:14:07 GMT 브라우저는 설정된 유효 일자까지 쿠키를 유지하다가, 해당 일자가 도달하면 쿠키를 자동으로 삭제합니다. (옵션값을 과거로 지정하면 쿠키는 삭제됩니다.) 쿠키의 유효 일자는 반드시 GMT(Greenwich Mean Time) 포맷으로 설정해야 합니다. date.toUTCString을 사용하면 해당 포맷으로 쉽게 변경할 수 있습니다. 아래는 유효 기간이 하루인 쿠키를 만드는 예시입니다. // 지금으로부터 하루 후 let date = new Date(Date.now() + 86400e3); date = date.toUTCString(); document.cookie = \"user=colinder; expires=\" + date; max-age ex) max-age=3600 max-age는 expires 옵션의 대안으로, 쿠키 만료 기간을 설정할 수 있게 해줍니다. 현재부터 설정하고자 하는 만료일시까지의 시간을 초로 환산한 값을 설정합니다. (0이나 음수값을 설정하면 쿠키는 바로 삭제됩니다.) // 1시간 뒤에 쿠키가 삭제됩니다. document.cookie = \"user=colinder; max-age=3600\"; // 만료 기간을 0으로 지정하여 쿠키를 바로 삭제함 document.cookie = \"user=colinder; max-age=0\"; 다른 브라우저들은 둘 다(Expires 와 Max-Age) 지정되었을 때 Max-Age 값을 더 우선시합니다. secure (쿠키 보안 설정) 이 옵션을 설정하면 HTTPS로 통신하는 경우에만 쿠키가 전송됩니다. secure 옵션이 설정된 경우, https://site.com에서 설정한 쿠키는 http://site.com에서 접근할 수 없습니다. 쿠키에 민감한 내용이 저장되어 있어 암호화되지 않은 HTTP 연결을 통해 전달되는 걸 원치 않는다면 이 옵션을 사용하면 됩니다. secure 옵션을 설정하지 않으면 http://site.com에서 설정(생성)한 쿠키를 https://site.com에서 읽을 수 있고, https://site.com**에서 설정(생성)한 쿠키도 **http://site.com에서 읽을 수 있습니다. 쿠키는 기본적으로 도메인만 확인하지 프로토콜을 따지진 않기 때문입니다. // (https:// 로 통신하고 있다고 가정 중) // 설정한 쿠키는 HTTPS 통신시에만 접근할 수 있음 document.cookie = \"user=John; secure\"; samesite (쿠키 보안 설정) 또 다른 보안 속성인 samesite 옵션은 크로스 사이트 요청 위조(cross-site request forgery, XSRF)공격을 막기 위해 만들어진 옵션입니다. 이 옵션엔 두 가지 값을 설정할 수 있습니다. samesite=strict(값을 설정하지 않고 그냥 samesite 옵션만 써줘도 동일하게 동작함) 사용자가 사이트 외부에서 요청을 보낼 때, samesite=strict 옵션이 있는 쿠키는 절대로 전송되지 않습니다. 메일에 있는 링크를 따라 접속하거나 evil.com과 같은 사이트에서 폼을 전송하는 경우 등과 같이 제3의 도메인에서 요청이 이뤄질 땐 쿠키가 전송되지 않죠. 인증 쿠키에 samesite 옵션이 있는 경우, XSRF 공격은 절대로 성공하지 못합니다. evil.com에서 전송하는 요청엔 쿠키가 없을 것이고, bank.com은 미인식 사용자에게 지급을 허용하지 않을 것이기 때문입니다. 이 보호장치는 꽤 믿을 만합니다. bank.com에서 수행하는 모든 작업은 samesite 쿠키를 함께 전송하기 때문이죠. 하지만 약간의 불편함도 감수해야 합니다. 만약 사용자가 메모장 등에 bank.com에 요청을 보낼 수 있는 링크를 기록해 놓았다가 이 링크를 클릭해 접속하면 bank.com이 사용자를 인식하지 못하는 상황이 발생하기 때문입니다. 실제로 이런 경우 samesite=strict 옵션이 설정된 쿠키는 전송되지 않습니다. 이런 문제는 쿠키 두 개를 함께 사용해 해결할 수 있습니다. “Hello, John\"과 같은 환영 메시지를 출력해주는 “일반 인증(general recognition)“용 쿠키, 데이터 교환 시 사용하는 samesite=strict 옵션이 있는 쿠키를 따로 둬서 말이죠. 이렇게 하면 외부 사이트를 통해 접근한 사용자도 ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:3:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["web"],"content":"참고 했던 글 https://thoughtbot.com/blog/lucky-cookies https://www.joinc.co.kr/w/man/12/cookie https://ko.javascript.info/cookie#ref-201 https://ko.javascript.info/cookie https://genesis8.tistory.com/220 https://medium.com/@ddinggu/cookie%EB%9E%80-a650c6d2803e https://jeong-pro.tistory.com/80 https://im-first-rate.tistory.com/33 https://noritersand.github.io/javascript/javascript-document-cookie-%EC%BF%A0%ED%82%A4-%EC%BB%A8%ED%8A%B8%EB%A1%A4/ ","date":"2020-10-19","objectID":"https://colinder.github.io/what_is_cookie/:4:0","tags":["web","cookie"],"title":"what is Cookie?","uri":"https://colinder.github.io/what_is_cookie/"},{"categories":["Vue"],"content":"​ Vue_LifeCycle 솔직히 처음 라이프사이클이란 것을 공부했을 때는 이게 무슨 말인지? 삶의 주기를 왜 알아야 하는지 전혀 몰랐습니다. 이런 저에게 Vue 공식문서에는 말했습니다. 지금 당장 모든 것을 완전히 이해할 필요는 없지만 다이어그램은 앞으로 도움이 될 것입니다. 그리고, LifeCycle을 공부 하기 전 DOM에 대한 개념이 부족하다면 what is DOM?을 꼭 보고 오길 추천합니다. ​ Vue.js의 라이프 사이클은 크게 Creation, Mounting, Updating, Destruction으로 나눌 수 있습니다. 이는 생성(create)되고, DOM에 부착(mount)되고, 업데이트(update)되며, 없어지는(destroy) 4가지 과정을 말합니다. 각각의 단계에서, Vue를 사용하는 사람들을 위해 훅(Hook)을 할 수 있도록 API를 제공합니다. 일반적으로 많이 사용하는 종류로는 beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed가 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:0:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"1. Creation (컴포넌트 초기화 단계) Creation 단계에서 실행되는 훅(hook)들이 라이프사이클 중에서 가장 처음 실행됩니다. 이 단계는 컴포넌트가 DOM에 추가되기 전이기 때문에 DOM에 접근하거나 this.$el를 사용할 수 없고, 서버 사이드 렌더링(SSR)에서는 지원되는 훅입니다. 따라서 클라이언트 단과 서버단 렌더링, 모두에서 처리해야할 일이 있다면 이 단계에서 하면됩니다. Creation단계에서 호출되는 라이프 사이클 훅은 [beforeCreate]과 [create]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:1:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeCreate() 이름처럼 가장 먼저 실행되는 beforeCreate훅입니다. Vue 인스턴스가 초기화 된 직후에 발생됩니다. 컴포넌트가 DOM에 추가되기도 전이어서 this.$el에 접근할 수 없습니다. 또한 data, methods, watch, computed, events(vm.$on, vm.$once, vm.$off, vm.$emit)등이 설정되기 전이라 접근할 수 없습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:2:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"created() data를 반응형으로 추적할 수 있게 되며 , methods, watch, computed, events등이 활성화되어 접근이 가능하게 됩니다. 하지만 아직까지 DOM에는 추가되지 않은 상태입니다. 하여 this.$el에는 접근할 수 없습니다. 컴포넌트 초기에 외부에서 받아온 값들로 data를 세팅해야 하거나 이벤트 리스너(ex. EventBus 등..)를 선언해야 한다면 이 단계에서 하는 것이 가장 적절합니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:3:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"2. Mounting (DOM 삽입 단계) Mounting단계는 초기 렌더링 직전에 컴포넌트에 직접 접근할 수 있습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) 초기 랜더링 직전에 돔을 변경하고자 한다면 이 단계를 활용할 수 있습니다. 그러나 컴포넌트 초기에 세팅되어야할 데이터 fetch는 created() 단계에 주로 사용하게 될 겁니다! Mounting단계에서 호출되는 라이프 사이클 훅은 [beforeMount]과 [mount]가 있습니다. *fetch: api를 불러오고, 정보를 내보내 주기도 하는 함수 ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:4:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeMount() DOM에 부착하기 직전에 호출되는 beforeMount훅입니다. 가상 DOM은 생성되어 있으나 실제 DOM에 부착되지는 않은 상태입니다. 하여 아직도 this.$el에는 접근할 수 없습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:5:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"mounted() 드디어! mounted 훅에서는 컴포넌트, 템플릿, 렌더링된 DOM에 접근할 수 있습니다. this.$el을 비롯한 data, computed, methods, watch 등 모든 요소에 접근이 가능합니다. 하지만 모든 하위 컴포넌트가 마운트된 상태를 보장하지는 않습니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) mount에는 약간의 이슈가 있습니다. 위의 설명에 “하지만 모든 하위 component가 mount된 상태를 보장하지는 않습니다.” == 여러 component가 중첩되어 사용되는 경우 부모, 자식 component의 로딩에 순서가 있다. 순서: 부모 created =\u003e 자식 created =\u003e 자식 mounted =\u003e 부모 mounted *이때는 this.$nextTick을 이용한다면, 모든 화면이 렌더링 된 이후에 실행되므로 마운트 상태를 보장할 수 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:6:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"3. Updating (Diff 및 재 렌더링 단계) 컴포넌트에서 사용되는 반응형 속성들이 변경되거나 어떤 이유로 재 렌더링이 발생되면 실행됩니다. 디버깅이나 프로파일링 등을 위해 컴포넌트 재 렌더링 시점을 알고 싶을때 사용하면 되죠. 조심스럽지만, 꽤 유용하게 활용될 수 있는 훅입니다. (서버 사이드 렌더링(SSR)시에 호출되지 않습니다.) Updating단계에서 호출되는 라이프 사이클 훅은 [beforeUpdate]과 [updated]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:7:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeUpdate() 이 훅은 컴포넌트의 데이터가 변하여 업데이트 사이클이 시작될 때 실행됩니다. 정확히는 DOM이 재 렌더링되고 패치되기 직전에 실행됩니다. 컴포넌트 초기에 data가 세팅되어야 한다면 created 훅을, 렌더링 되고 DOM을 변경해야 한다면 mounted 훅을 사용하면 되기 때문에, 거의 사용하지 않는 라이프 사이클 훅입니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:8:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"updated() 이 훅은 DOM이 재 렌더링 된 후 호출되는 라이프 사이클 훅입니다. DOM이 업데이트 완료된 상태이므로 DOM의 종속적인 연산을 할 수 있습니다. 예를 들어 변경된 data가 DOM에도 적용된 후에 호출되는 훅입니다. (updated훅에서 data를 수정하게 되면 update훅이 호출 되기 때문에 무한 루프에 빠질 수 있으니 되도록이면 안쓰는 것이 좋습니다…) 또 위의 mounted와 비슷한 이유로 모든 자식 컴포넌트의 재 렌더링 상태를 보장하지는 않으며, this.$nextTick()을 이용해, 모든 화면이 업데이트 된 이후의 상태를 보장할 수 있습니다. ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:9:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"4. Destruction (해체 단계) 컴포넌트가 제거 될 때 실행되는 라이프 사이클 훅입니다. (서버 사이드 렌더링(SSR)시에도 호출되지 않습니다.) Destruction단계에서 호출되는 라이프 사이클 훅은 [beforeDestroy]과 [destroyed]가 있습니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:10:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"beforeDestroy() 컴포넌트가 제거 되기 직전에 호출되는 라이프 사이클 훅입니다. 이 훅에서 컴포넌트는 본래의 기능들을 가지고 있는 온전한 상태이기 때문에 모든 속성에 접근이 가능합니다. 하여 이 훅에서 이벤트 리스너를 해제하거나 컴포넌트에서 동작으로 할당 받은 자원들은 해제해야 할 때 사용하기 적합한 훅입니다. ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:11:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"destroyed() 컴포넌트가 제거 된 후 호출되는 라이프 사이클 훅입니다. 컴포넌트의 모든 이벤트 리스너(@click, @change 등..)와 디렉티브(v-model, v-show 등..)의 바인딩이 해제 되고, 하위 컴포넌트도 모두 제거됩니다. ​ ​ 👀요약 LifeCycle을 모르고 개발한다는게 운 좋으면 되고 운 나쁘면 안되고, 하는 막무가내 개발과 비슷하다고 느꼈습니다. 간단하게라도 흐름을 숙지하면 많은 도움이 될 것이고, 아무리 바쁘더라도 created와 mouted 정도는 알고 개발하면 확실히 도움이 됩니다. ​ ​ ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:12:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Vue"],"content":"참고 했던 글. https://vuejs.org/v2/api/#Options-Lifecycle-Hooks https://beomy.tistory.com/47 https://medium.com/witinweb/vue-js-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-7780cdd97dd4 https://wormwlrm.github.io/2018/12/29/Understanding-Vue-Lifecycle-hooks.html https://junsday.tistory.com/44 ","date":"2020-10-15","objectID":"https://colinder.github.io/06_vue_lifecycle/:13:0","tags":["Vue"],"title":"06_Vue_LifeCycle","uri":"https://colinder.github.io/06_vue_lifecycle/"},{"categories":["Web"],"content":"​ Web을 공부하다보면 반드시 듣게 되는 단어. “DOM” 근데 이게 뭔지 감이 잘 안왔고 그래서 WIT블로그를 필사하며 공부한 내용을 추가해 정리했습니다. ​ DOM이란? DOM(Document Object Model)은 웹 페이지에 대한 인터페이스입니다. 기본적으로 페이지의 콘텐츠 및 구조, 그리고 스타일을 읽고 조작할 수 있도록 API를 제공합니다. 먼저 DOM을 이해하기 전에 웹 페이지가 어떻게 빌드 되는지 알아보면 이해하는데 도움이 됩니다. 하여 알아봅시다! *인터페이스(interface): 서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면이다. 즉, 사용자가 기기를 쉽게 동작시키는데 도움을 주는 시스템. ​ ​ 웹 페이지는 어떻게 만들어질까? 웹 브라우저가 원본 HTML 문서를 읽어들인 후, 스타일을 입히고 대화형 페이지로 만들어 뷰 포트에 표시하기까지의 과정을 “CRP(Critical Rendering Path)”이라고 합니다. Understanding the Critical Rendering Path을 참고해보면 6단계로 웹 페이지가 생성되는 것을 알 수 있습니다. 하지만 어렵죠. 조금 더 간추려 보자면 이 단계들은 2개로 나누어 생각해볼 수 있습니다. 첫 번째 단계에서 브라우저는 읽어들인 문서를 파싱하여 어떤 내용을 페이지에 렌더링할지 확인하고 랜더트리를 생성합니다. 그리고 두 번째 단계에서 브라우저는 해당 렌더링을 수행합니다. *DOM(Document Object Model) – HTML 요소들의 구조화된 표현 *CSSOM(Cascading Style Sheets Object Model) – 요소들과 연관된 스타일 정보의 구조화된 표현 ​ ​ 설명과 그림을 보면 DOM은 웹페이지 생성에 첫번째로 수행되는 기능입니다. 그리고 HTML 요소들의 구조화된 표현 이죠. 그렇다면 HTML은 뭘까요? HTML(Hyper Text Markup Language)은 웹 페이지를 위한 언어로, 특정 영역이 어떤 성질을 갖는지 미리 정해진 규칙에 따라 구조화된 요소들로 이루어진 마크업 언어입니다. 마크업 언어는 태그(\u003c\u003e)를 이용하여 데이터 구조를 명명하는 언어이므로(ex. \u003cbody\u003e), 태그 안에 담기는 요소들에 따라 영역의 성질이 달라지게 되고 각 영역들이 모여 구조화된 문서를 만듭니다. 또한 HTML은 인간이 이해하고 구분할 수 있는 언어로 만들어져 있고, 기계는 이렇게 규약된 언어를 해석할 수 없기 때문에, 파싱이라는 작업을 거쳐 브라우저가 해석할 수 있는 언어와 구조로 변환하는 작업이 필요합니다. (각 브라우저마다 파서가 다르기 때문에 같은 HTML문서라도 다른 파싱 결과값을 가질 수 있다.) 즉, 브라우저에서 HTML을 가공?(parsing)하여 Object 객체로 다시 만들어 기계가 해석할 수 있는 모습으로 변형한 것을 DOM이라고 합니다. ​ ​ DOM은 어떻게 만들어지는 걸까? DOM은 HTML 요소들이 가공(구조화)된 표현입니다. 둘은 서로 비슷하지만, DOM이 갖고 있는 특징은 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용될 수 있다는 점입니다. DOM의 개체 구조는 노드 트리로 표현됩니다. 이 HTML 구조는 이와 같은 노드 트리의 DOM으로 구성됩니다. ​ ​ 그럼 DOM과 HTML은 같은건가? 답은 ‘아니다.’ 라고 말 할 수 있습니다. DOM은 HTML 문서로부터 생성되지만 항상 동일하지 않습니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:0","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"1. DOM은 HTML이 아닙니다. DOM은 HTML 문서로부터 생성되지만 항상 동일하지 않습니다. DOM이 원본 HTML 소스와 다를 수 있는 두 가지 케이스가 있습니다. 작성된 HTML 문서에 오류가 있을 때 DOM은 유효한 HTML 문서의 인터페이스입니다. DOM을 생성하는 동안, 브라우저는 유효하지 않은 HTML 코드를 올바르게 교정합니다. 위에 html코드에는 필수 요소인 \u003chead\u003e와 \u003cbody\u003e가 빠져 있습니다. 하지만 DOM에는 올바르게 교정되어 있는 모습을 볼 수 있습니다. ​ 자바스크립트에 의해 DOM이 수정될 때 DOM은 HTML 문서의 내용을 볼 수 있는 인터페이스 역할을 하는 동시에 동적 자원이 되어 수정될 수 있습니다. 예를 들어, 자바스크립트를 사용해 DOM에 새로운 노드를 추가할 수 있습니다. 이 코드는 DOM을 업데이트합니다. 하지만 HTML 문서의 내용을 변경하진 않습니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:1","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"2. DOM은 브라우저에서 보이는 것이 아닙니다. 위의 그림에서 보면 DOM은 아직 CSSOM(CSS)가 적용되지 않은 상태입니다. 렌더 트리는 오직 스크린에 그려지는 것으로 구성되어 있어 DOM과 다릅니다. 달리 말하면, 렌더링 되는 요소만이 관련 있기 때문에 시각적으로 보이지 않는 요소는 제외됩니다. 예를 들어, 아래 html코드에는 p태그가 display: none 스타일 속성을 가지고 있는 요소입니다. 렌더 트리에 해당하는 뷰 포트에 표시되는 내용은 \u003cp\u003e 요소를 포함하지 않습니다. DOM은 \u003cp\u003e 요소를 포함시킵니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:2","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"3. DOM은 개발도구에서 보이는 것이 아닙니다. 개발도구의 요소 검사기는 DOM과 가장 가까운 근사치를 제공합니다. 그러나 개발도구의 요소 검사기는 DOM에 없는 추가적인 정보를 포함합니다. 가장 좋은 예는 CSS의 가상 요소입니다. ::before 과 ::after 선택자를 사용하여 생성된 가상 요소는 CSSOM과 렌더 트리의 일부를 구성합니다. 하지만, 기술적으로 DOM의 일부는 아닙니다. DOM은 오직 원본 HTML 문서로부터 빌드 되고, 요소에 적용되는 스타일을 포함하지 않기 때문입니다. 가상 요소가 DOM의 일부가 아님에도 불구하고, 요소 검사기에서는 아래와 같이 확인됩니다. 이러한 이유로 가상 요소는 DOM의 일부가 아니기 때문에 자바스크립트에 의해 수정될 수 없습니다. ​ *해당 포스팅은 WIT블로그를 필사하며 공부한 내용을 기록해 놓은 것입니다. ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:0:3","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["Web"],"content":"더 공부하기 ::before와 ::after는 가상요소입니다. https://green-webdesigner.tistory.com/20 ​ ​ ","date":"2020-10-13","objectID":"https://colinder.github.io/what_is_dom/:1:0","tags":["Vue","Web","DOM"],"title":"what is DOM?","uri":"https://colinder.github.io/what_is_dom/"},{"categories":["web"],"content":"​ 동기(Synchronous)란? 어떤 작업을 실행했을 때, 그 작업이 끝나고 결과를 응답받은 뒤에 다음 함수를 실행하는 방식. 만약 응답값이 없다면, 무한정 기다려요. 즉, 응답을 받아야! 다음 실행이 되는 방식입니다. ex) A실행 👉 A의 결과값 return 확인 👉 B실행 ​ 비동기(Asynchronous)란? 어떤 작업을 실행한 후 결과값을 기다리지 않고, 바로 다음 함수를 실행합니다. ex) A실행 👉 B실행 👉 … ​ CallBack함수란? 비동기 처리결과로 반환되는 Callback함수 Callback함수는 특정함수에 매개변수로 전달된 함수를 의미합니다. ex) DB에서 데이터를 가져오라는 요청 👉 데이터가 오는 중인데 👉 출력해버리면 결과값이 나오지 않는다. But, Callback 함수로 처리결과를 받은 후에 출력을 하게 로직을 짜면 문제없이 출력된다. 상황에 따라 어떤 작업이 끝났다는 것을 사용자에게 알려주거나, 코드 내부에서 Callback함수를 받았을 경우에만 처리하는 로직등을 짜서 가시적인 개발에 도움이 됩니다. ​ ​ # 개인적으로 동기는 '순차'라는 단어로 변환해 생각하면서 이해했습니다. 동기적 👉 '순차'적 👉 지정된 순서대로 시작 비동기적 👉 비'순차'적 👉 순서에 상관없이 시작 ","date":"2020-10-11","objectID":"https://colinder.github.io/sync_async_callback/:0:0","tags":["vue","web","면접대비"],"title":"동기 \u0026 비동기 \u0026 CallBack함수","uri":"https://colinder.github.io/sync_async_callback/"},{"categories":["git"],"content":"​ Fork fork는 다른 사람(프로젝트)의 github repository에서 내가 어떤 부분을 수정하거나, 기능을 추가 하고 싶을 때 해당 repository를 그대로 복제하는 기능. fork한 저장소는 원본 repository와 연결되어 있습니다. 여기서 연결되어 있다는 의미는, 원본 repository에 어떤 변화가 생기면 이는 forked된 나의 repository에도 반영될 수 있다는 것입니다. (단, fetch나 rebase의 과정이 필요합니다. fetch나 rebase를 하지 않았다면, 단순히 원본 repository를 복사해서 가져온 상태라고 할 수 있습니다.) fork는 보통 2가지 목적을 위해 사용합니다. 오픈소스 기여를 위해 기존 오픈 소스의 사본을 만들어서 새로운 버전을 만들어나가기 위해 (예를 들어 장고 오리지널이 망했는데 누군가 이 프로젝트를 fork해서 새로운 버전으로 이어나가는 거죠) *fetch: Git에서 어떤 브랜치의 코드를 받아오는 방법 중 하나. (또 다른 하나는 pull) *rebase: Git에서 한 브랜치에서 다른 브랜치로 합치는 방법 중 하나. (또 다른 하나는 merge) ​ 🤔만약? 내가 손본(개발한) 내용을 push 하면 나의 repository에만 변경사항이 저장되고 원본 repository에는 영향을 주지 못합니다. 다만, 원본 repository에도 나의 변경사항을 반영하고 싶다면, 원본 repository에 pull request를 보내고 원본 repository 관리자가 수락하면 원본 repository에도 반영이 됩니다. == 타인 코드에 기여한다. ​ Clone clone은 특정 repository를 내 local machine(ex. 내 노트북)에 복사하여 새로운 저장소를 만드는 기능. clone하면 서버에 있는 프로젝트 히스토리를 포함한 거의 모든 데이터를 복사합니다. (거의 모든이라고 기록한 이유는 세부 명령어에 따라 clone되는 내용이 달라지기 때문입니다.) 또한 clone한 원본 repository의 remote가 origin으로 자동 설정됩니다. 만약 권한이 없다면 original repository의 로그를 보지 못하며, 해당 저장소로 push 하지도 못합니다. ​ 하지만! 로그까지도 모두 clone하는 등의 몇 가지 명령어가 존재합니다. 그중 많이 쓰이는 bare와 mirror에 대하여 정리해봤습니다. –bare 공식문서의 설명은 아래와 같음. Make a bare Git repository. That is, instead of creating \u003cdirectory\u003e and placing the administrative files in \u003cdirectory\u003e/.git, make the \u003cdirectory\u003e itself the $GIT_DIR. This obviously implies the --no-checkout because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/. When this option is used, neither remote-tracking branches nor the related configuration variables are created. 간단히 bare옵션은 HEAD의 refs 정보가 clone됩니다. *HEAD: 현재 작업중인 브랜치 *refs: 알아보기 쉬운 이름으로 설정된 commit 이름을 “References” 또는 “Refs” 라고 부른다. ​ –mirror 공식문서의 설명은 아래와 같음. Set up a mirror of the source repository. This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository. 간단히 mirror옵션은 모든 브랜치의 refs 정보가 clone됩니다. ​ ​ ​ ✨Point # fork와 clone의 차이 원본 저장소와 연결이 되어 있냐(fork) 아니냐(clone)? ​ *Push Option –mirror Instead of naming each ref to push, specifies that all refs under refs/ (which includes but is not limited to refs/heads/, refs/remotes/, and refs/tags/) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option remote.\u003cremote\u003e.mirror is set. ​ ​ Special Thanks to Eric✨. ","date":"2020-10-11","objectID":"https://colinder.github.io/git_fork_vs_clone/:0:0","tags":["git","fork","clone"],"title":"Git_fork vs clone","uri":"https://colinder.github.io/git_fork_vs_clone/"},{"categories":["Web"],"content":"​ AJAX 세상에는 다양한 web서버가 있다. 그리고 모든 web은 “요청”과 “응답”으로 통신한다. 예를 들어.. 요청: “이미지를 보여줘” 응답: “오키” or “싫어” 그렇다면, 이 web서버들과 통신 하려면 어떻게 해야 할까? 대표적인 통신 방법을 AJAX라 한다. 이는 JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자며, 자체가 하나의 특정한 기술을 말하는 것이 아니며, 함께 사용하는 기술의 묶음을 지칭하는 용어이다. 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법 이며 Ajax를 한마디로 정의하자면 JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이라고 할 수 있겠습니다. ​ ​ Ajax 중 하나인 axios에 대하여 정리. ​ ​ ​ ","date":"2020-10-11","objectID":"https://colinder.github.io/what_is_ajaxaxios_00/:0:0","tags":["Vue","Web","AJAX","axios","면접대비"],"title":"what is AJAX(axios)?","uri":"https://colinder.github.io/what_is_ajaxaxios_00/"},{"categories":["git"],"content":"​ Git_Mirroring 기존에 사용하고 있던 A_Repo에서 B_Repo로 커밋히스토리 그대로 복사가 필요할 때가 있습니다. 여기서 A_Repo를 그대로 가져온다는 의미는 단지 파일을 새롭게 만드는 것이 아니라 A_Repo에서 작업하던 commit 이력 모두를 그대로 이전하는 의미를 뜻합니다. ​ 터미널을 엽니다. 복사하고자 하는 저장소(A_Repo)의 bare clone을 생성합니다. git clone --bare https://github.com/user/old-repository.git 새로운 저장소(B_Repo)를 만들고 mirror-push를 진행합니다. cd old-repository.git 👈 위에서 클론(bare)한 폴더로 이동 git push --mirror https://github.com/user/new-repository.git 2번 과정에서 클론된 저장소를 지웁니다.(선택사항) ​ 대부분의 경우 위의 방법으로 미러링이 가능하지만, github 정책상 크기가 100MB를 넘어가는 파일이 단 한번이라도 commit되었다면, 오류가 발생하는 이슈가 있을 수도 있음. ​ ","date":"2020-10-08","objectID":"https://colinder.github.io/git_mirroring/:0:0","tags":["git","Mirroring"],"title":"Git_Mirroring","uri":"https://colinder.github.io/git_mirroring/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D3_3975_승률 비교하기 result = [] for T in range(int(input())): A, B, C, D = map(int, input().split()) if B/A \u003e D/C: result.append(\"BOB\") elif B/A \u003c D/C: result.append(\"ALICE\") else: result.append(\"DRAW\") for t in range(T+1): print(f\"#{t+1} {result[t]}\") # 아니 이게 D3라고? 완전 난이도 설정 실수네. 했다가 런타임 오류 보고 # 왜 그런건지 알았다. # python은 결과를 모았다가 출력하는 게 더 빠르다. ​ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["SW Expert Academy"],"content":"D2_5176_이진탐색 def makeTree(n): global count #Tree 범위 제한 if n \u003c= N: #1부터 시작한다고 가정했을 때 왼쪽노드는 현재 인덱스의 2배 makeTree(n*2) #더이상 못가면 값넣기 tree[n] = count #값 넣었으면 증가시키기 count += 1 #우측 노드는 인덱스 2배 + 1 makeTree(n*2 + 1) for T in range(int(input())): N = int(input()) tree = [0 for i in range(N+1)] count = 1 makeTree(1) print(f'#{T+1} {tree[1]} {tree[N//2]}') # 2020하반기 네이버 코테를 풀고 tree에 대하여 깊이있게 공부해봐야겠다고 생각하며 # 다시 처음부터 공부하는데, 미쳤다.ㅎ ","date":"2020-09-26","objectID":"https://colinder.github.io/sw_20.09.26/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3975, 5176, , ","uri":"https://colinder.github.io/sw_20.09.26/"},{"categories":["web"],"content":"​ REST API Reference [TOC] ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:0:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.사용자 API Members Descriptions POST /accounts/signup 회원가입 POST /accounts/login 회원 로그인 POST /accounts/userDetail 회원정보 PUT /accounts/update 회원정보 수정 DELETE /accounts/dropUser 회원탈퇴 GET /accounts/emailAuth 이메일 인증 GET /accounts/emailCheck 이메일 중복 확인 GET /accounts/nicknameCheck 닉네임 중복 확인 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.1 회원 로그인 POST /accounts/login ​ 회원 로그인 API 입니다. ​ Request parameters Parameter Type Description email String 이메일 password String 비밀번호 ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.2 회원가입 POST /accounts/signup ​ 회원가입 API 입니다. ​ Request parameters Field Type Description password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail 1.2.1 이메일 중복확인 GET /accounts/emailCheck 회원가입시 이메일 중복확인하는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description result.data String 아이디사용가능 ​ Response (Fail) Field Type Description result.data String 아이디중복 1.2.2닉네임 중복확인 GET /accounts/nicknameCheck 회원가입시 닉네임중복확인하는 API 입니다. ​ Request parameters Field Type Description nickname String 닉네임 ​ Response(Success) Field Type Description result.data String 닉네임사용가능 ​ Response (Fail) Field Type Description result.data String 닉네임중복 1.2.3이메일 인증 GET /accounts/emailAuth 이메일 중복 확인시 이메일을 인증메일을 보내는 API 입니다. ​ Request parameters Field Type Description email String 이메일 ​ Response(Success) Field Type Description dice int 이메일 인증 코드 ​ Response (Fail) Field Type Description data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.3 회원 정보 수정 PUT /accounts/update 회원정보 수정 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 nickname String 닉네임 content String 자기소개 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.4 회원 정보 POST /accounts/userDetail 회원정보를 조회하는 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response (Success) Field Type Description uid String DB에서 관리하는 id password String 회원 비밀번호 passwordConfirm String 회원 비밀번호 확인 email String 이메일 nickname String 닉네임 content String 자기소개 createDate LocalDateTime 회원가입일 likedpost String 좋아요한 글 목록 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"1.5 회원탈퇴 DELETE /accounts/dropUser 회원 탈퇴 API 입니다. ​ Request parameters Field Type Description uid String DB에서 관리하는 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:1:5","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.게시물 API Members Descriptions POST /articles/register 글 작성 GET /articles/showArticle 글 상세 조회 PUT /articles/modify 글 수정 DELETE /articles/dropArticle 글 삭제 POST /articles/like 글 좋아요 POST /articles/likedList 좋아요 게시물 리스트 GET /articles/searchArticle 글 검색 POST /articles/getRecommentList 음식점 추천 리스트 GET/articles/list 전체 글 리스트 POST /articles/postedList 사용자가 작성한 글 리스트 GET/articles/postedListByLikes 좋아요순 글 리스트 GET/articles/postedListByHits 조회순 글 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.1 글 작성 POST /articles/registe 글 작성 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.2 글 상세 조회 GET /articles/showArticle 글 상세조회하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String 조회 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.3 글 수정 PUT /articles/modify 글 수정하는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id title String 글 제목 lat String 위도 lon String 경도 content String 글 내용 hashtag String 글 해시태그 address String 주소 likes int 글 좋아요수 createDate String 글 작성일 nickname String 글 작성자의 닉네임 hits int 조회수 url String 상세보기 url starpoint String 크롤링 별점 placename String 장소 이름 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.4 글 삭제 DELETE /articles/dropArticle 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 삭제 성공 ​ Response (Fail) Field Type Description result.data String 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.5 글 좋아요 POST /articles/like 글 좋아요 올리거나 내리는 API 입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:5","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.6 좋아요 게시물 리스트 POST /articles/likedList 좋아요 누른 게시물을 리턴해주는 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result.data List Post객체의 리스트 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:6","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.7 글 검색 GET /articles/searchArticle 글 검색 API 입니다. ​ Request parameters Field Type Description keyword(path) String 검색어 ​ Response(Success) Field Type Description result.data HashMap 해쉬맵으로 검색결과를 리턴 ​ Response (Fail) Field Type Description result.data null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:7","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.8 음식점 추천 리스트 POST /articles/getRecommentList 음식점 추천 API입니다. ​ Request parameters Field Type Description food String 관련 태그를 ,로 연결하여 보내기 isCafe String 카페도 추천하면 추가 isDrink String 술집도 추천하면 추가 like String 피드백에서 좋아요수가 부족할때 watch String 피드백에서 조회수가 부족할때 star String 피드백에서 별점이 부족할때 ​ Response(Success) Field Type Description 음식 Post 추천하는 음식점 카페 Post 추천하는 카페 술집 Post 추천하느 술집 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:8","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.9 전체 글 리스트 GET /articles/list 전체 글을 받는 API입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:9","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.10 사용자가 작성한 글 리스트 POST /articles/postedList 사용자가 작성한 글의 리스트를 리턴해주는 API 입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id ​ Response(Success) Field Type Description result List 전체 글의 리스트 ​ Response (Fail) Field Type Description result null ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:10","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.11좋아요순 글 리스트 GET /articles/postedListByLikes 좋아요 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:11","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.12 조회순 글 리스트 GET /articles/postedListByHits 조회 순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:12","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"2.13 좋아요순 글 리스트 GET /articles/postedListByStarpoint 별점순으로 글의 리스트를 리턴해주는 API 입니다. ​ Response(Success) Field Type Description result.comment List 댓글수의 리스트 result.list List 전체 글의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:2:13","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.글 임시저장 API Members Descriptions POST /subarticles/register 임시 글 작성 GET /subarticles/detail/{postid} 임시저장 글 상세 조회 GET /subarticles/list/{userid} 유저별 임시 글 리스트 DELETE /subarticles/dropSubarticle 임시 글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.1 임시 글 작성 POST /subarticles/register 임시 글 작성 API입니다. ​ Request parameters Field Type Description userid int 글 작성자의 id nickname String 글 작성자의 닉네임 title String 글 제목 content String 글 내용 hashtag String 글 해시태그 address String 주소 placename String 장소 이름 url String 상세보기 daum url lat String 위도 lon String 경도 ​ Response(Success) Field Type Description result.data String 글작성 성공 ​ Response (Fail) Field Type Description result.data String 글작성 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.2 임시저장 글 상세 조회 GET /subarticles/detail/{postid} 임시 글 상세조회 API입니다. ​ Request parameters Field Type Description postid int DB에서 관리하는 post id ​ Response(Success) Field Type Description result Post 유저별 임시저장 글 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.3 유저별 임시 글 리스트 GET /subarticles/list/{userid} 유저별 임시 글 리스트 API입니다. ​ Request parameters Field Type Description userid int DB에서 관리하는 user id ​ Response(Success) Field Type Description result List 유저별 임시저장 글의 리스트 ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"3.4 임시 글 삭제 DELETE /subarticles/dropSubarticle 임시 글 삭제 API입니다. 글 삭제하는 API입니다. ​ Request parameters Field Type Description postId int DB에서 관리하는 post id ​ Response(Success) Field Type Description result.data String 임시저장 글 삭제 성공 ​ Response (Fail) Field Type Description result.data String 임시저장 글 삭제 실패 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:3:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.댓글 API Members Descriptions GET /comments/list/{postid} 해당글의 댓글 전체 리스트 POST /comments/register 댓글 작성 PUT /comments/modify 댓글 수정 DELETE /comments/dropComment 댓글 삭제 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:0","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.1 해당 글의 전체 댓글 GET /comments/list/{postid} 해당 글의 전체 댓글을 받아오는 API입니다. ​ Request parameters Field Type Description postid(path) int 해당 글 id ​ Response(Success) Field Type Description result.data List Comment객체의 리스트 ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:1","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.2 댓글 작성 POST /comments/register 댓글 작성하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:2","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.3 댓글 수정 PUT /comments/modify 댓글 수정하는 API 입니다. ​ Request parameters Field Type Description postid int 댓글을 쓰는 글의 id content String 댓글 내용 userid int 글 작성하 사용자의 DB userid nickname String 글 작성하는 사용자의 닉네임 ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:3","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["web"],"content":"4.4 댓글 삭제 DELETE /comments/dropComment 댓글 삭제하는 API입니다. ​ Request parameters Field Type Description commentId int 댓글의 id ​ Response(Success) Field Type Description result.data String success ​ Response (Fail) Field Type Description result.data String fail ","date":"2020-09-24","objectID":"https://colinder.github.io/rest-api-reference/:4:4","tags":["web"],"title":"REST API Reference","uri":"https://colinder.github.io/rest-api-reference/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3307_최장 증가 부분 수열(LIS) for T in range(int(input())): N = int(input()) arr = list(map(int, input().split())) dp= [1] * N for i in range(1, N): for j in range(i): if arr[j] \u003c arr[i]: dp[i]= max(dp[i], dp[j] + 1) print(f'#{T+1} {max(dp)}') # dp는 쉬운듯 어렵고 어려운듯 쉽다... # LIS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_3304_최장 공통 부분 수열(LCS) for T in range(int(input())): A, B = input().split() dp = [[0 for i in range(len(A)+1)] for j in range(len(B)+1)] for i in range(1, len(B)+1): for j in range(1, len(A)+1): if B[i-1] == A[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i][j-1], dp[i-1][j]) print(f'#{T+1} {dp[-1][-1]}') # 아니다. DP는 그냥 겁나 어렵다.. # 각각의 문자 위치를 숫자로 바꾸고 이를 2차원 배열로 만들어서 # 일치하는 문자가 나왔을 때의 숫자를 dp에 기록해서 진행하는데 # 난 A, B의 검사 순서를 B -\u003e A 로 해야 한다는 것을 아주 느리게 깨달았다. # LCS로 검색하면 도움이 되는 글이 많다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 for T in range(int(input())): N = int(input()) days = [] for _ in range(N): days.append(int(input())-1) days = days[1:] dp = [1]*(N-1) count = 0 while any(dp): # 👈 dp가 모두 0일 때까지 while을 돌린다. i = dp.index(1) for j in range(i,N-1): if days[j] % days[i] == 0: dp[j] = 0 count += 1 print(f\"#{T+1} {count}\") # 2주기로 정박하는 배가 있다고 할 때, 이 배는 2일 4일 8일 12일에 정박할 수 있다. # 중간에 비어있는 일자가 있더라도 1배가 정박한 것으로 본다. # any() 함수를 써봤는데 좋았다. 푸는데 2시간... 걸렸다...ㅎ. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"D3_10726_이진수 표현 def check2(M): for i in range(N): if M % 2 != 1: return \"OFF\" else: M = M // 2 return \"ON\" for T in range(int(input())): N, M = map(int, input().split()) print(f'#{T+1} {check2(M)}') # 특정 조건에서 더 이상 검색할 필요가 없다면, def를 선언해 사용하는 것이 아주 유용하다. # 처음에는 bin함수를 사용해 slicing을 해서 뭐..뭐.. 어떻게 해보려 했지만 # run time error가 났다. 조금 생각해보니, 굳이 bin을 사용할 것도 없어보였고, # 간단하게 시도했더니 풀렸다. ​ ","date":"2020-09-21","objectID":"https://colinder.github.io/sw_20.09.21/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3307, 3304, 4371, 10726","uri":"https://colinder.github.io/sw_20.09.21/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3131_100만 이하의 모든 소수 a = [0, 0] + [1] * 1000000 for i in range(2, 1000000): if a[i] == 1: for j in range(2*i, 1000001, i): a[j] = 0 for i in range(2, 1000000): if a[i] == 1: print(i, end=\" \") # 에라토스테네스의 체 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_3233_정삼각형 분할 놀이 for T in range(int(input())): A, B = map(int, input().split()) result = 0 for i in range(int(A//B)): result += 2*(i+1) - 1 print(f'#{T+1} {result}') # A를 B의 길이로 나눈 정삼각형은 맨 위층 부터 2n-1개의 삼각형이 나온다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_1860_진기의 최고급 붕어빵 def check(): global bread for i in range(max(people)+1): if i == 0: pass else: if i % M == 0: bread += K if i in people: if bread \u003c= 0: return 'Impossible' else: bread -= 1 return 'Possible' for T in range(int(input())): N, M, K = map(int, input().split()) people = list(map(int, input().split())) bread = 0 print(f'#{T+1} {check()}') # 특정 조건인 경우 더 이상 확인할 필요가 없기 때문에 즉시 종료가 가능한 def 함수를 # 선언해서 구현했고, 조건중 0초일때 붕어빵 판매가 가능한지 생각 후 해결되었다. ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["SW Expert Academy"],"content":"D3_4047_영준이의 카드 카운팅 for T in range(int(input())): counts = {'S': 13, 'D': 13, 'H': 13, 'C' : 13} arr = input() new_arr = [] for i in range(0, len(arr), 3): new_arr.append(arr[i:i+3]) if len(set(new_arr)) != len(new_arr): print(f\"#{T+1} ERROR\") else: for i in new_arr: counts[i[0]] -= 1 print(f\"#{T+1} \", end='') print(*counts.values()) # 엄청 좋은 문제라고 생각한다. 막 어렵진 않으나 다양한 스킬들을 사용해서 # 풀어볼 수 있는 좋은 문제라고 생각한다. # 1. set{}의 활용 / 2. for문 slicing / 3. print안에 end 활용 / 4. set자료 접근 등 ​ ","date":"2020-09-19","objectID":"https://colinder.github.io/sw_20.09.15/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 3131, 3233, 1860, 4047","uri":"https://colinder.github.io/sw_20.09.15/"},{"categories":["block_chain"],"content":"​ 🧔프라이빗 블록체인 VS 👨🏻‍🤝‍👨🏻퍼블릭 블록체인 VS 🔒프라이빗 네트워크 VS 🔐퍼블릭 네트워크 Why 이런 질문을? 블록체인 관련 정보를 구글링하다보면, 프라이빗 네트워크, 퍼블릭 네트워크, 프라이빗 블록체인, 퍼블릭 블록체인. 이 4가지의 말을 혼용해서 사용하고 있는 것을 쉽게 볼 수 있다. 여기서 프라이빗 네트워크와 프라이빗 블록체인과 같이 네트워크와 블록체인을 같은 의미로 많이 사용하는데. 과연 이 둘이 같은 것을 의미하는지 알아보았다. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"결론 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:1","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 블록체인=\u003e 사용자의 접근조건을 기준으로 프라이빗과 퍼블릭을 나눔 ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:2","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"- 네트워크=\u003e 서비스 운용형태를 기준으로 프라이빗과 퍼블릭을 나눔 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:0:3","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🧔프라이빗 블록체인 선택된 참여자만 블록체인에 접근이 가능하며, 선택된 참여자만 블록을 만들 수 있음. 특징 네트워크 구성할 때 인증과 검증 과정을 통해 선택적으로 참여자가 노드를 구성 네트워크를 구성하는 참가자인 노드가 되기 위해서는 운영 주체의 허가가 필요 참여자가 제한되기 때문에 빠른 거래나 처리속도가 필요한 경우와 네트워크 내에서만 정보가 공개되어야 하는 경우에 적합한 형태 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:1:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"👨🏻‍🤝‍👨🏻퍼블릭 블록체인 누구든 블록체인에 접근이 가능하며, 누구나 블록을 만들 수 있음. ex) 비트코인(1세대 블록체인), 이더리움(2세대 블록체인) 특징 모든 참여자에게 거래 내용이 공유 자유롭게 읽고 쓸 수 있지만, 정보를 위변조하는 것이 불가능 거래 처리 용량 제한으로 인한 확장성 부족이나 채굴에 들어가는 전력의 큰 비용 등 문제 ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:2:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔒프라이빗 네트워크 운영자의 허가를 받은 인원만 거래 내용을 확인할 수 있음. ​ ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:3:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["block_chain"],"content":"🔐퍼블릭 네트워크 누구나 거래내역을 확인할 수 있음. ​ ex) 블록체인 자체에 모두가 접근할 수 있는가? -\u003e 퍼블릭 블록체인이다. 실제 운용하는 형태가 퍼블릭한가? -\u003e 퍼블릭 네트워크이다. 하이퍼렛저 패브릭은 블록체인 자체가 모두가 접근하도록 설계가 되어 있지 않네? -\u003e 프라이빗 블록체인 실제 운용도 프라이빗 하구나! -\u003e 프라이빗 네트워크 이더리움은 최초에 모두가 쓸 수 있게 만들어졌군 -\u003e 퍼블릭 블록체인이네 그렇지만 일단 우리 팀원들끼리만 써야지 -\u003e 프라이빗 네트워크 ​ 내용을 정리하면서 발생했던 의문들. 노드를 생성한다는 것은 어떤 의미인가? 노드? 네트워크를 구성하는 참가자 == 노드 블록을 생성해 네트워크를 구성한다. 한개의 노드만 있더라도 네트워크는 구성되었고, 노드끼리 연결되는 순간에 서로 다른 체인데이터를 가지고 있다면, 합의로직에 따라서 합의가 진행된 후 체인 데이터가 같아진다. 프라이빗 네트워크는 어떻게 구성하는가? 개념적으로는 잘못되었을 수 있지만, 단순히 회원가입시 노드를 만들고 지갑까지 생성해 해쉬(#)값을 추출해 DB에 저장하고, 이후 서비스 사용시 해쉬값이 일치하는 사용자에게만 특정 내용을 보여준다면 프라이빗한 네트워크로 서비스를 제공할 수 있겠다. 블록체인을 생성하는 것이랑 네트워크에 참여하는 것은 별개의 일이 아닌가? 위에 설명한 노드를 만들면 나의 첫 블록인 genesis.json 파일을 만들고 네트워크에 참여하게 된다. 네트워크에 참여 후 addpeer를 통해 네트워크 사용자를 확장해나간다. 즉, 별개의 일이다. ","date":"2020-09-17","objectID":"https://colinder.github.io/private-vs-public-blockchain-vs-network/:4:0","tags":["block_chain"],"title":"block_chain private Vs public / blockchain Vs network","uri":"https://colinder.github.io/private-vs-public-blockchain-vs-network/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 for T in range(int(input())): D, A, B = map(int, input().split()) D = str(D) arr = [0, 0] + [1] * (B - 1) # 에라토스테네스의 체를 활용할껀데 어떤 수까지 검증하면 될까? # 검증해보니 모든 수는 자신의 int(root)까지만 확인하면 배수값인지 확인이 가능했다. rootB = int(B**0.5) #👈 이 아이디어를 얻기까지 오랜시간이 걸렸다. for i in range(2, rootB+1): #👈 if arr[i] == 1: #👈 for j in range(2*i, B+1, i): #👈 에라토스테네스의 체 를 활용 arr[j] = 0 #👈 result = [] for i in range(A, B+1): if arr[i] == 1 and D in str(i): result.append(i) print(f'#{T+1} {len(result)}') ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_1493_수의 새로운 연산 new_number = [(0, 0)] count = 1 while count \u003c= 300: count += 1 for x in range(1, count): y = count - x new_number.append((x, y)) for T in range(int(input())): p, q = map(int, input().split()) x = new_number[p][0] + new_number[q][0] y = new_number[p][1] + new_number[q][1] result = new_number.index((x, y)) print(f'#{T+1} {result}') # 별다른 아이디어는 없었다. 그냥 인덱스별 좌표를 미리 만들어 두고 # 그걸 불러오는 방법을 생각했다. (런타임이 겁났지만, Pass 했다.) ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_10570_제곱 팰린드룸 수 for T in range(int(input())): N = [0]*1001 A, B = map(int, input().split()) for i in range(A, B+1): if str(i) == str(i)[::-1]: if i**0.5 % 1 == 0: if str(int(i**0.5)) == str(int(i**0.5))[::-1]: N[i] = 1 print(f'#{T+1} {N.count(1)}') #그냥 문제에 주어지는 대로 풀었다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"D3_3032_홍준이의 숫자 놀이 def exeu(a, b): global x, y r = [a, b] s = [1, 0] t = [0, 1] while r[-1] != 0: q = int(r[-2] / r[-1]) r.append(r[-2] - q * r[-1]) s.append(s[-2] - q * s[-1]) t.append(t[-2] - q * t[-1]) x = s[-2] y = t[-2] for T in range(int(input())): A, B = map(int, input().split()) exeu(A, B) print(f'#{T+1} {x} {y}') # 확장된 유클리드 알고리즘을 공부하면 된다. # 근데 쉽지 않으니 시간을 가지고 봐야 한다. # 실은 난 아직 이해하지 못했다. ​ ","date":"2020-09-08","objectID":"https://colinder.github.io/sw_20.09.09/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4698, 1493, 10570, 3032","uri":"https://colinder.github.io/sw_20.09.09/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_2817_부분 수열의 합 import itertools for T in range(int(input())): N, K = map(int, input().split()) # N: 갯수, K: 목표 합 Nums = list(map(int, input().split())) count = 0 for i in range(1, N+1): boxs = itertools.combinations(Nums, i) for box in boxs: if sum(box) == K: count += 1 print(count) # 하... 라이브러리 쓰자.. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1491_원재의 벽 꾸미기 for T in range(int(input())): N, A, B = map(int, input().split()) result = [] for R in range(1, N+1): for C in range(1, R+1): if R * C \u003e N: break elif R * C \u003c= N: result.append(A * abs(R-C) + B * (N - R*C)) print(f\"#{T+1} {min(result)}\") # A X lR – Cl + B X (N - R X C)에서 # A X lR – Cl =\u003e 양수, B X (N - R X C) =\u003e 양수 만 가능하다. # 또 직사각형 인테리어라고해서 R != C 라고 생각했으나,, # R = C인 경우도 넣어줘야 답이 나왔다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_1229_암호문2 for T in range(10): N = int(input()) passwords = list(map(int, input().split())) order = int(input()) cmd = list(input().split()) for i in range(len(cmd)): if cmd[i] == 'I': for j in range(int(cmd[i+2])): passwords.insert(int(cmd[i+1])+j, int(cmd[i+3+j])) elif cmd[i] == 'D': for j in range(int(cmd[i+2])): passwords.pop(int(cmd[i+1])) print('#{}'.format(T+1), end=' ') print(*passwords[0:10]) # 조건 자체는 어렵지 않은데, 다뤄야하는 숫자들이 많아서 결과를 확인하기 어려웠다. ​ ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"D3_5515_2016년 요일 맞추기 days= [31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366] day = 4 for T in range(int(input())): m, d = map(int, input().split()) if m != 1: add_month = days[m-2] elif m == 2: add_month = days[1] else: add_month = 0 result = (day + add_month + (d-1)) % 7 print(f'#{T+1} {result}') # 이건 그냥 했다. ","date":"2020-09-05","objectID":"https://colinder.github.io/sw_20.09.05/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 2817, 1491, 1229, 5515","uri":"https://colinder.github.io/sw_20.09.05/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10505_소득 불균형 for T in range(int(input())): N = int(input()) dp = [0] * 100001 Max = 0 for i in list(map(int, input().split())): dp[i] += 1 Max += i print(f'#{T+1} {sum(dp[:int(Max/N)+1])}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_10200_구독자 전쟁 for T in range(int(input())): N, A, B = map(int, input().split()) # 최소값 구하기 if A+B \u003e= N: Min = (A+B)-N if A \u003e= B: Max = B else: Max = A else: Min = 0 if A \u003e= B: Max = B else: Max = A print(f'#{T+1} {Max} {Min}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_3376_파도반 수열 for T in range(int(input())): Padovan = [1, 1, 1, 2] N = int(input()) for i in range(N-4): Padovan.append(Padovan[i+2]+Padovan[i+1]) print(f'#{T+1} {Padovan[N-1]}') ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["SW Expert Academy"],"content":"D3_5642_합 T = int(input()) for T in range(T): N = int(input()) Nums = list(map(int, input().split())) result = 0 Sum = 0 flag = 0 for i in range(N): Sum = Sum + Nums[i] if Sum \u003c 0: Sum = 0 elif Sum \u003e result: result = Sum if Nums[i] \u003c 0: flag += 1 if flag == N: result = max(Nums) print(f'#{T+1} {result}') # 모두 음수인 경우를 생각해야 한다... 이거 생각하는데 40분 걸렸따... ​ ","date":"2020-09-04","objectID":"https://colinder.github.io/sw_20.09.04/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 10505, 10200, 3376, 5642","uri":"https://colinder.github.io/sw_20.09.04/"},{"categories":["block_chain"],"content":"​ 🎈가상환경에서 블록체인 채굴 및 기본 시스템 정리 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:0:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"1. geth(Go-ethereum) 설치 블록체인 기술은 중앙집중화된 데이터베이스에 반기를 들고 나온 개념이기 때문에 중앙 서버 이런게 없다. 즉 누구라도 해당 블록체인 네트워크에 참여하고 싶다면 언제라도 블록체인 데이터베이스를 싱크해주는 로컬 프로그램을 다운 받아 실행하면 데이터를 받을 수 있다. 그렇다면 블록체인 네트워크에 참여하고 싶다면 어떻게 해야 할까? 앞서 말한 로컬 프로그램을 다운 받으면 참여가 가능하다. 이 프로그램들 중 하나인 GO 로 짜여진 Go Ethereum(줄여서, geth)을 설치해본다. 작성당시 가장 최신 버전인 1.9.20 for windows로 다운을 받는다. 다운 받고 실행하면 경고창이 뜨는데 추가정보누르고 실행누르고 진행한다. devolop 뭐시기는 선택하지 않았고, next를 누루고 진행한다. 설치가 깔끔히 마무리 되지 않고 경고창이 떴는데, 환경변수 설정해주었다. 검색 → 시스템 환경 변수 편집 → 고급 → 환경 변수 → Path더블클릭 → 새로만들기 → C:\\Program Files\\Geth 추가 cmd 창을 열어(관리자: 명령 프롬프트) geth를 입력해 실행되는지 확인한다._______끝 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:1:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"2. Web3 설치 모든 자료와 정보가 분산화, 분권화된 차세대 네트워크 구조로서, 서버가 없는 혁신적인 인터넷 분산형 웹. web3.js는 JavaScript 기반으로 Dapp 이나 서비스를 구현할 때 매우 유용. (출처: 위키) ​ 이미 Vue_CLI 프로젝트를 구성해 놓은 것이 있어서 Terminal 에서 npm install web3 입력해서 web3를 설치한다. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:2:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"3. VirtualBox 설치 VirtualBox: 하드웨어를 소프트웨어적으로 구현해서 그 위에서 운영체제가 작동하도록하는 기술 Windows hosts 와 All supported platforms 두개를 다운 받는다. Windows hosts: 그냥 next연타하여 설치 All supported platforms을 더블클릭하여 설치를 진행하는데 👍전체 설치는 이 블로그의 설치 동영상을 참고하여 설치를 진행 ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:3:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"4. Vagrant 설치 Vagrant는 가상머신을 편리하게 사용할 수 있도록 도와주는 프로그램입니다. 이미 누군가가 Vagrant로 설정해 놓은 가상머신 Box를 간단한 명령어로 손쉽게 설치 할 수 있으며 가상 머신과 호스트 머신과의 환경설정도 쉽게 할 수 있습니다. 다운로드는 여기서 진행. ​ ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:4:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"5. Remix IDE 설정 이더리움 스마트 컨트랙트 프레임워크 여기서 진행! ​ 🎈본격적인 블록체인 관련 가상환경 세팅 및 채굴 진행 20.09.01 한 일.. ⛏ 광산에서 일하는 것을 예시로! VirtualBox(🏞): 블록체인 생성 및 채굴을 위한 가상환경을 세팅 (내가 채굴할 산을 고르는 것) Vagrant(🏟): 가상환경에서 노드를 생성하는 등, 블록체인 관련 프레임워크 (광구를 생성하는 것) geth(📜👷‍♂️): 블록체인 노드의 관련 프로그램 (광구에 어떤 사람이 들어오고 어떤 사람을 파견할지 등등) ​ 블록체인 관련 작업을 할 디렉토리 생성 후 Terminal을 열어 vagrant 관련 명령어 실행(이미 설치는 완료) \u003e vagrant version #설치 여부 및 버전 확인 =\u003e 버전 넘버가 보이면 ok \u003e vagrant plugin install vagrant-scp # 호스트 \u0026 가상머신 간 연동 프로그램 설치 \u003e vagrant init # 블록체인 채굴을 위한 기초 세팅 시작 # 해당 명령어를 입력하면 작업하는 디렉토리에 Vagrantfile이 생긴다. vagrant init 후 생기는 Vagrantfile을 수정해 최초의 블록(genesis.json)을 생성해야 한다. # Vagrantfile =\u003e 내용을 수정한다. # -*- mode: ruby -*- # vi: set ft=ruby : # All Vagrant configuration is done below. The \"2\" in Vagrant.configure # configures the configuration version (we support older styles for # backwards compatibility). Please don't change it unless you know what # you're doing. VAGRANT_API_VERSION = \"2\" vms = { 'eth0' =\u003e \"10\", 'eth1' =\u003e \"11\" } Vagrant.configure(VAGRANT_API_VERSION) do |config| config.vm.box = \"ubuntu/bionic64\" vms.each do |key, value| config.vm.define \"#{key}\" do |node| node.vm.network \"private_network\", ip: \"192.168.50.#{value}\" if \"#{key}\" == \"eth0\" node.vm.network \"forwarded_port\", guest: 8545, host: 8545 end node.vm.hostname = \"#{key}\" node.vm.provider \"virtualbox\" do |nodev| nodev.memory = 2048 end end end end # 내가 이해?한 바로는 eth0과 eth1이라는 2개의 노드(광구)를 설정했다. 정도 \u003e vagrant up # 방금 설정한 eth0과 eth1 노드(광구)를 오픈(실행) \u003e vagrant status # 설정되어 있는 두 노드(광구)의 상태를 확인 runing이면 오픈한 상태 ​ 여기 가지 작업을 했다면 vitualbox에 두개의 노드(광구)가 등록되어있는 것을 확인 할 수 있다. ​ 등록된 노두(광구) 중에서 eth0을 먼저 설정해보자 지금까지 진행한 폴더에서 Terminal을 열고 vagrant 명령어로 노드(광구)를 설정해준다. 기본적은 vagrant 명령어 명령어 설명 vagrant up 상태확인할가상머신이름 가상머신 기동 vagrant status 상태확인할가상머신이름 가상머신 상태 확인 vagrant ssh 접속할가상머신이름 가상머신에 접속 vagrant halt 멈출가상머신이름 가상머신 정지 vagrant suspend 가상머신 휴면 vagrant resume 가상머신 휴면에서 복원 vagrant reload 가상머신 재시동 vagrant destroy 가상머신 제거 *모든 명령어가 vagrant up 상태확인할가상머신이름 과 같이 사용 가능하다. ​ 이제 노드(광구)를 열었으니 접속해보자 =\u003e vagrant ssh 접속할가상머신이름 ​ geth를 설치해준다. *Geth 설치 (Go-ethereum client) # vagrant@eth0:~$ 가상머신에서 수행 \u003e sudo apt-get update \u003e sudo apt-get install software-properties-common \u003e sudo add-apt-repository -y ppa:ethereum/ethereum \u003e sudo apt-get install ethereum #여기까지 순서대로 설치하면 geth설치는 완료. # 프라이빗 이더리움를 관리할 폴더 생성 \u003e mkdir -p dev/eth_localdata #-p는 mkdir 옵션사항 =\u003e 중간경로도 다 만들어라 \u003e mkdir database \u003e cd database # 프라이빗 이더리움을 위한 genesis.json블록파일(블록들을 연결하기 위한 최초의 블럭) 생성 \u003e vi genesis.json # genesis.json를 만들겠다. # genesis.json의 내용 등록 (예시) i → 입력 활성화 → 아래 내용입력 후 → esc → ZZ(저장하고 종료) { \"config\": { \"chainId\": 5245, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0xdeadbeefdeadbeef\", \"difficulty\": \"0x40\", \"gasLimit\": \"9999999\", \"alloc\": {}, \"extraData\": \"\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\": \"0x00\" } # genesis.json 저장 후 \u003e cd .. 다시 root폴더로 이동한다. ​ 나의 최초의 블록(genesis.json)을 만들었다면 등록(초기화)해줘야 한다. =\u003e ✨geth를 사용하여 진행 \u003e geth init #이 명령어로 등록(초기화)을 할 수 있는데... # 위의 --datadir을 참고하여 \u003e geth --datadir ~/dev/eth_localdata init ~/database/genesis.json # ~/database 위치에 있는 genesis.json을 등록(초기화)하고 등록 후 생기는 관련 자료는 ~/dev/eth_localdata에 모아놓겠다는 뜻 ​ 이제 노드(광구)를 관리할 계정(🙋‍♂️사람)도 등록해준다. \u003e geth account new # 이 명령어를 입력하면 아이디는 자동으로 생성되고 비밀번호만 설정할 수 있게 진행된다. # 계정이 잘 만들어 진 것인지 확인하기 위해서는 \u003e geth account list ​ 이제 노드(광구)에 어떤 사람들이 들어올 수 있는지와 입장하는 명령어들을 살펴보자. 어떤식으로 입력(설정)하는 지는 여기를 참고하여 진행하였다. # eth0의 노드(광구) 입장 명령어 \u003e geth console # 다만 보통의 경우 아래와 같이 노드(eth0)에 다양한 주소 및 설정을 붙이고 진행한다. \u003e geth --networkid 5245 --port 30303 --maxpeers 2 --datadir ~/dev/eth_localdata --rpcaddr 0.0.0.0 --nodiscover --nousb console \u003e\u003e ~/eth0.log # 일단 이걸로 채굴 성공 geth --datadir ~/dev/eth_localdata --nodiscover --nousb --networkid 5245 console # 맨 마지막에 2\u003e\u003e ~/eth0.log를 붙이면, 진행기록을 root주소에 eth0.log를 만들어 저장한다.란 뜻. # 진행 도중 ERROR 모음 Failed to enumerate USB devices =\u003e --nousb 추가해주면 사라짐. ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:0","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["block_chain"],"content":"Transaction eth0 안에 account[0] 이랑 account[1] 이 있고 coinbase는 accounts[0] 인 상황에서 account[0]에서 채굴한걸 account[1]로 보낼 것이다. =\u003e 이를 트랜잭션(Transaction) 한다고 한다. 트랜잭션을 위해서는 먼저 계정들의 잠금 해제가 필요하다. EOS계정을 만들면 기본적으로 잠금 상태인데, # 잠금해제 command 로 해제가 가능하다. (이더를 보내는 EOS계정만 잠금을 풀어주면 된다.) personal.unlockAccount(eth.accounts[0]) #기본적인 세팅, 입력 후 비밀번호 입력 계정 잠금 해제(잠금 해제 유효시간 기본 - 300초) personal.unlockAccount(eth.accounts[0], \"inputpassword\") #비밀번호가 입력되어 계정 잠금 해제(비밀번호 입력 필요X) personal.unlockAccount(eth.accounts[0], \"inputpassword\", 0) #계정 잠금 해제(0 - Geth 프로세스 종료되기 전까지 해제) ​ 이제 트랜잭션이 있는지 확인해보자. (eth.pendingTransactions =\u003e 트랜잭션 확인) 입력한 transaction이 없으니 비어있다. ​ 이제 송금(Transaction) 해보자. eth.sendTransaction({from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(10, \"ether\")}) # eth.accounts[0]에서 eth.accounts[1]로 web3단위로 10이더를 보내겠다.는 뜻. 색이 이쁘니 성공적으로 명령을 처리 한 것 같다. 하지만 accounts[1]계정에 돈이 들어오지 않았다. ​ 트랜잭션은 등록된게 확인된다. 왜 진행은 안됬을까…. 하지만 accounts[1]계정에 돈이 들어오지 않았다. *blockNumber: null로 accounts[0]에서 보낸 트랜잭션이 accounts[1]의 블록에 포함되지 않음을 알 수 있다. ​ 송금 확인(sendTransaction으로 트랜잭션을 발행해도 처리안됨 =\u003e 블록체인에서는 블록 안에 그 트랜잭션이 포함될 때 트랜잭션 내용이 실행) ✨ 간단히 트랜잭션을 등록하고 miner.start() command로 채굴을 시작하는 경우(블록 활성화?)에 트랜잭션이 반영된다! \u003e miner.start(1) # 이걸로 잠시 채굴을 켰다가. \u003e miner.stop() # 으로 채굴을 꺼주고 \u003e eth.pendingTransactions # 으로 트랜잭션 내용을 다시 확인해주면 비어있는 것을 볼 수 있다. ​ 그리고 # EOS계정(accounts[1])의 잔액을 확인해보면 \u003e eth.getBalance(eth.accounts[1]) \u003e web3.fromWei(eth.getBalance(eth.accounts[1]), \"ether\") #둘다 확인 가능하며 송금이 잘 진행된 것을 볼 수 있다. 여기까지 진행하면서, 두 블로그를 매우 많이 참고했고, 도움이 되었어서 소개한다. Mr.Latte - [Go Ethereum 사용 법] Allg - [Geth 설치 및 테스트 네트워크에서 송금하기] ","date":"2020-09-03","objectID":"https://colinder.github.io/block_chain/:5:1","tags":["block_chain"],"title":"Block_Chain setting \u0026 basic","uri":"https://colinder.github.io/block_chain/"},{"categories":["Vue"],"content":"​ Vuex 핵심컨셉(getters, mutations, actions, modules) ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:0:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"1. Getters 만약? A.vue와 B.vue에서 각각 store의 state에 등록된 second의 2를 3으로 변형해 사용하고 싶다면 어떻게 해야 할까? 저장소에 등록되어 있는 상태(state)를 변경하고 싶다면? 아마 귀찮겠지만, 각각의 파일에서 // A.vue computed: { change() { return this.$store.state.second + 1 } } // B.vue computed: { change() { return this.$store.state.second + 1 } } 이와 같이 동일한 코드를 작성해서 사용해야 할 것이다. ​ 이러한 코드의 중복을 막고 state에 등록된 data를 변경해 사용하고 싶을 때 getters를 사용한다. ​ 🙋‍♂️실습해보자! (Step. 1, 2로 구성) Step. 1 //지난시간에 등록한 내용을 활용해서 //store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { 👈 addOne(state) { 👈 return state.second + 1 👈 } 👈 } 👈 }) ​ Step. 2 // A.vue, B.vue 동일하게 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e 👈 \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { 👈 그냥 store에서 return this.$store.state.second 👈 불러온 자료를 }, 👈 노출하기 위한 등록 useGetters() { 👈 store에 addOne이라는 return this.$store.getters.addOne 👈 ✨ getters를 불러오기 } 👈 위해 작성한 코드 } 👈 입니다. } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:1:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"2. Mutations 공식문서에 Mutations는 “Vuex 저장소에서 실제로 상태를 변경하는 유일한 방법은 변이하는 것\"이라는 설명이 있다. 하지만 나는 Mutations는 store.state 값을 변경하는 로직들을 의미한다고 정리하고 싶다. Getters 와 차이점을 알아두면 좋은데, 인자를 받을 수 있다. ____ex) addOneMutations(state, 인자) computed가 아닌 methods에 등록해 사용한다. computed는 계산된값이기에 등록하면 바로 노출이 가능하지만 Methods는 함수지 등록된 값이 아니다. mutations에 등록된 로직은 작동시 state의 값을 변경시킨다.___(단, 새로고침시 state을 원복) mutations은 commit()으로 호출해 사용한다. ​ 역시 🙋‍♂️실습해보자! (Step. 1, 2로 구성) Step. 1 // store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] }, getters: { addOne(state) { return state.second + 1 } }, mutations: { 👈 addOneMutations(state) { 👈 return state.second++ 👈 or 2씩 증가: return state.second += 2 } 👈 } }) ​ Step. 2 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003estate그냥 불러온 값: {{change1}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eGetters 사용한 값: {{useGetters}}\u003c/h1\u003e \u003cbr\u003e \u003ch1\u003eMutations 사용한 값: {{$store.state.second}}\u003c/h1\u003e 👈 \u003cbutton @click=\"useMutations\"\u003e+\u003c/button\u003e 👈 \u003chr\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'B', computed: { change1() { return this.$store.state.second }, useGetters() { return this.$store.getters.addOne } }, methods: { 👈 useMutations() { 👈 return this.$store.commit(\"addOneMutations\") 👈 }, 👈 } 👈 } \u003c/script\u003e \u003cstyle\u003e \u003c/style\u003e ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:2:0","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["Vue"],"content":"✨실습해보면서 알게된 포인트를 정리하며 마친다. 1️⃣ Getters로 가져온 값은 새로고침(F5)을 하여도 사라지지 않는다. 애초에 store에서 변형한 값을 가져오니까. 2️⃣ Mutations로 등록된 methods는 원본데이터(store.state)의 값을 변화 시킨다. 단, 새로고침(F5)시 원본데이터 값이 회복된다. 3️⃣ Mutations은 동기(순차)적으로 작동되며 commit으로 불러와 사용한다. 원본데이터(state)의 값을 변경시키기 때문에 순서가 중요하다! ​ ","date":"2020-08-16","objectID":"https://colinder.github.io/07_vue_vuex-concept/:2:1","tags":["Vue"],"title":"07_Vue_Vuex Concept","uri":"https://colinder.github.io/07_vue_vuex-concept/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1149_RGB거리 N = int(input()) RGB = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(RGB)): RGB[i][0] = RGB[i][0] + min(RGB[i-1][1], RGB[i-1][2]) RGB[i][1] = RGB[i][1] + min(RGB[i-1][0], RGB[i-1][2]) RGB[i][2] = RGB[i][2] + min(RGB[i-1][0], RGB[i-1][1]) print(min(RGB[i][0], RGB[i][1], RGB[i][2])) # 2시간이 넘게 고민한 결과... # 문제 속 조건3 \"\"i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.\"\"을 이해하는데 시간이 걸렸다. # 조건3에 따르면 N=3인 경우, i = 2가 되고, 결국 1번, 3번 집의 색과 2번 집의 색이 다르면 된다. # 난 이걸.. 1번집과 3번집의 색이 달라야 한다고 잘못 이해해서 시간을 버렸다.ㅎ ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1932_정수삼각형 N = int(input()) tree = [list(map(int, input().split())) for _ in range(N)] for i in range(1, len(tree)): f = len(tree[i]) for j in range(f): if j == 0: tree[i][j] = tree[i][j] + tree[i-1][j] elif j == f-1: tree[i][j] = tree[i][j] + tree[i-1][j-1] else: tree[i][j] = tree[i][j] + max(tree[i-1][j-1], tree[i-1][j]) print(max(tree[i])) # 이전 문제를 풀고선 그리 어렵지않게 풀었다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"2579_계단오르기 # 1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다. # 2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다. # 3. 마지막 도착 계단은 반드시 밟아야 한다. N = int(input()) # stairs = [int(input()) for _ in range(N)] # 이렇게 정보를 받으면 느리다.... stairs = [0 for _ in range(301)] for i in range(N): stairs[i] = int(input()) total = [0 for _ in range(301)] total[0] = stairs[0] total[1] = stairs[0] + stairs[1] total[2] = max(stairs[1] + stairs[2], stairs[0] + stairs[2]) # 마지막 계단을 반드시 밟아야 하니까. \u003c0: 안밟음, 1: 밟음\u003e for i in range(3, N): total[i] = max( total[i-3]+stairs[i-1]+stairs[i], # 1 0 1 1(마지막계단)의 경우 total[i-2]+stairs[i] # 1 0 1(마지막계단)의 경우 ) print(total[N-1]) ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"1463_1로 만들기 x = int(input()) x_map = [0 for i in range(x+1)] visited = [0 for i in range(10**6)] x_map[x] = 1 count = 0 while x_map[1] == 0: count += 1 for i in range(1, x+1): if x_map[i] == count: if i % 3 == 0 and visited[i//3] == 0: x_map[i//3] = count+1 visited[i//3] = 1 if i % 2 == 0 and visited[i//2] == 0: x_map[i//2] = count+1 visited[i//2] = 1 if x_map[i-1] == 0 and visited[i-1] == 0: x_map[i-1] = count+1 visited[i-1] = 1 print(x_map[1]-1) # 코딩하면서는 너무 바보 같은 방법인가.. 했지만, 통과됬으니 뭐.. 만족한다. ​ ","date":"2020-08-05","objectID":"https://colinder.github.io/bj_20.08.06/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1149, 1932, 2579, 1463","uri":"https://colinder.github.io/bj_20.08.06/"},{"categories":["BEAKJOON"],"content":"​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:0","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1003_피보나치 함수 def Fibonacci(N): if N \u003c 3: print(zero[N], one[N]) else: f = 1 s = 2 for i in range(N-2): zero.append(zero[f] + zero[s]) one.append(one[f] + one[s]) f += 1 s += 1 print(zero[N], one[N]) for T in range(int(input())): N = int(input()) zero = [1, 0, 1] one = [0, 1, 1] Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:1","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"1904_01타일 def Fibonacci(N): result: 0 f = 0 s = 1 for i in range(1, N+3): if i == 1: result = f elif i == 2: result = s else: result = f+s f = s % 15746 s = result % 15746 print(result % 15746) Fibonacci(int(input())) # 문제를 먼저 손으로 플어보니 결국 피보나치 수열이 답이었는데 # 15746의 나머지가 답이어서 그런지 '시간 초과'가 발생했다. # 때문에 '왜맞틀?'로 고민하다 검색해보니 결과값을 15746의 나머지로 더한다는 # 방법을 보고 이를 참고했다. (솔직이 아직 이게 왜 더 빠른지 잘 모르겠다.) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:2","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"2748_피보나치의 수2 def Fibonacci(N): Fibo = [0, 1] f = 0 s = 1 for i in range(3, N+2): Fibo.append(Fibo[f] + Fibo[s]) f += 1 s += 1 print(Fibo[N]) N = int(input()) Fibonacci(N) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:3","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["BEAKJOON"],"content":"9461_파도반 수열 for T in range(int(input())): N = int(input()) Padovan = [1, 1, 1] f = 0 s = 1 for i in range(N-3): Padovan.append(Padovan[f] + Padovan[s]) f += 1 s += 1 print(Padovan[N-1]) ​ ","date":"2020-08-04","objectID":"https://colinder.github.io/bj_20.08.04/:0:4","tags":["algorithm","동적계획법1"],"title":"BEAKJOON 1103, 1904, 2748, 9461","uri":"https://colinder.github.io/bj_20.08.04/"},{"categories":["web"],"content":"​ Naming Convention 정해진 규정은 없으나, 많은 개발자들이 암묵적으로 지키고 있는 이름짓는 방법. ​ snake_case 🐍 # _ == snake some_var = 5 my_awesome = 3 ​ camelCase 🐪 # 낙타등이 솟아 있는 모습 someVar = 5 pyAwesome = 3 ​ UpperCamelCase 🐪🐪 # 낙타얼굴과 등이 중간에 솟아 있는 모습 (파스칼식(Pascal case)이라고도 불린다.) SomeVar = 5 PyAwesome = 3 ​ Kebab-Case 🥙 # 케밥이 꼬챙이에 꽂힌 모습에서 생긴 방법(이라는데 난 생김새는 잘 모르겠다.ㅎ) main-login = 5 feed-content = 1 ​ ","date":"2020-08-02","objectID":"https://colinder.github.io/namingconvention/:0:0","tags":["web"],"title":"Naming Convention","uri":"https://colinder.github.io/namingconvention/"},{"categories":["Vue"],"content":"​ What is Vuex? (공식문서) Vuex는 Vue.js 애플리케이션에 대한 상태 관리 패턴 + 라이브러리 입니다. 애플리케이션의 모든 컴포넌트에 대한 중앙 집중식 저장소 역할을 하며 예측 가능한 방식으로 상태를 변경할 수 있습니다. 또한 Vue의 공식 devtools 확장 프로그램과 통합되어 설정 시간이 필요 없는 디버깅 및 상태 스냅 샷 내보내기/가져오기와 같은 고급 기능을 제공합니다. (공식문서 설명) ​ # 설치 명령어 npm i vuex or npm install vuex # 이후 src폴더안에 vuex폴더를 만들고 store.js라는 파일을 생성. (파일생성위치는 자유롭게 설정가능) ​ 그렇다면? 상태관리패턴이란 무엇인가? ​ 🤔이를 알아보기 전에 간단히 지난 시간에 알아본 props와 emit의 문제점을 생각해보자! 많은 components를 통과해야 하는 prop의 경우 테이터 이동을 위한 코드가 장황해질 수 있다. 형제 components는 부모를 거쳐 데이터를 이동해야 하는 불편함이 발생한다. 형제 components = 같은 가로층의 components\r심지어 손자 components 끼리 데이터를 이동하려면 엄청나게 많은 props와 emit이 작성되어야 하는데, 이런 불편함을 해소하기 위해 데이터 저장소(STORE)를 생성하는 것을 고민해볼 수 있다. ​ 이 때문에 대규모 애플리케이션의 상태를 관리할 수 있는 상태 관리 패턴이 필요해진다. 예를 들면 이런 모습으로\r이를 단일 상태 트리(single state tree) 로 데이터를 관리한다고 표현한다. 공식문서에 이에 대한 설명이 있는데 내가 생각하는 핵심은 아래와 같다. 각 애플리케이션마다 하나의 (데이터)저장소만 갖게 한다. 데이터를 저장하고 이를 불러오기만하면 되니 간편한 코딩이 가능해진다. ROW 데이터를 저장하는 곳을 지정해 관리하는 곳이 생긴다. 이를 구현해보자. ​ 아까 만든 store.js에 기본적인 세팅을 진행해보자. (해당 과정은 총 3 Step으로 구성) ​ Step. 1 store.js에 데이터를 등록(저장)한다. ## store.js import Vue from \"vue\" import Vuex from \"vuex\" Vue.use(Vuex) export default new Vuex.Store({ // 여기에 state(상태) 정보를 등록해서 사용. // ex) 여러형태의 데이터를 구현해보자. state: { first: '첫번째 데이터입니다.', second: 2, listData: [ {name: \"john\"}, {name: \"poul\"}, {name: \"kim\"} ] } }) ## ✨Point: store에 state라는 곳에 데이터를 저장했다는 것을 기억하고 다음으로 넘어가자. ​ Step. 2 저장소(STORE)에 데이터가 입력되었으니 이를 최상위 .js 파일(main.js)에 등록해 모든 영역에서 사용가능**(전역으로 등록)**하게 하자. ## main.js import Vue from 'vue' import App from './App.vue' import router from './router' (이전에 설명한 router도 설치되었음을 알 수 있다.) import store from '../src/vuex/store.js' 👈(추가) Vue.config.productionTip = false new Vue({ router, (이전에 설명한 router도 설치되었음을 알 수 있다.22) store, 👈(추가) render: h =\u003e h(App) }).$mount('#app') ​ Step. 3 store에 저장된 데이터를 불러와 사용한다. (난 Vue_CLI를 사용해, 디폴트 파일인 About.vue에 출력한다.) ","date":"2020-08-02","objectID":"https://colinder.github.io/05_vue_what-is-vuex/:0:0","tags":["Vue"],"title":"05_Vue_What is Vuex?","uri":"https://colinder.github.io/05_vue_what-is-vuex/"},{"categories":["Vue"],"content":"✋ 여기서 잠깐! Q. store에 저장된 데이터를 불러오는 방법은 무엇인가요? A. 여러방법이 있으나 가장 Basic한 방법으로 1. computed를 사용해 불러오는 방법과 2. data를 선언해 사용하는 방법을 알아보자. (이 두 방법을 추천하는 이유는 LifeCycle에서 정리되어 있다.) ## About.vue 방법.1 (computed를 사용하는 방법) \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e{{result}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'About', //Step 1. computed: { result() { return this.$store.state } } } \u003c/script\u003e ## About.vue 방법.2 (data 선언 후 store를 저장해 사용하는 방법) \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- Step. 3 --\u003e \u003ch1\u003e{{result}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'About', //Step. 1 data() { return { result: \"\", } }, //Step. 2 created() { this.result = this.$store.state } } \u003c/script\u003e ​ 방법에 차이가 있을 뿐 노출되는 화면은 동일하다.\r방법.1의 경우 폴더구조\r방법.2의 경우 폴더구조\rThanks to ‘이서영’💑 ","date":"2020-08-02","objectID":"https://colinder.github.io/05_vue_what-is-vuex/:0:1","tags":["Vue"],"title":"05_Vue_What is Vuex?","uri":"https://colinder.github.io/05_vue_what-is-vuex/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4466_최대 성적표 만들기 for T in range(int(input())): N, K = map(int, input().split()) score = list(map(int, input().split())) score.sort(reverse=True) result = 0 for i in range(K): result += score[i] print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4406_모음이 보이지 않는 사람 for T in range(int(input())): sent = input() result = '' for i in sent: if i not in 'aeiou': result += i print('#{} {}'.format(T+1, result)) ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4371_항구에 들어오는 배 ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["SW Expert Academy"],"content":"D3_4299_태혁이의 사랑은 타이밍 for T in range(int(input())): D, H, M = map(int, input().split()) result = D*1440 + H*60 + M if result \u003e= 16511: print(f'#{T+1} {result-16511}') else: print(f'#{T+1} -1') ​ ","date":"2020-07-29","objectID":"https://colinder.github.io/sw_20.07.29/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4466, 4406, 4371, 4299","uri":"https://colinder.github.io/sw_20.07.29/"},{"categories":["Vue"],"content":"​ 1. Vue CLI 란? (공식문서) 간단히 vue-cli 는 기본 vue 개발 환경을 설정해주는 도구입니다. 여기서 CLI 란 ? 명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. (위키백과) ​ 2. Vue router 프로젝트 생성 후 보통의 경우 편의를 위해 terminal에 vue add router를 입력해 router설치를 진행합니다. router를 설치하고 나면 기존의 vue 프로젝트의 tree구조에서 약간의 변화가 생기게 됩니다. router 설치 전: App.vue - components router 설치 후: App.vue - views - components ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/03_vue_cli/:0:0","tags":["Vue"],"title":"03_Vue_cli \u0026 router \u0026 histoyMode","uri":"https://colinder.github.io/03_vue_cli/"},{"categories":["Vue"],"content":"views 폴더 속 .vue 파일의 특징 1. views 폴더안의 .vue 파일들은 App.vue에 직접 연결되며, components들을 품을 수도 있다. 2. props(부모 → 자식으로 데이터 이동)와 emit(자식 → 부모으로 데이터 이동)을 이용해 데이터를 활용한다. 더 많은 특징 및 활용방법이 있을 것이나 상기 내용은 가장 기초이자 핵심입니다. ​ ✋ 여기서 잠깐! Q. A파일에 B파일을 적용(등록) 혹은 불러와서 사용하고 싶다면? A. 1. import / 2. components에 등록 / 3. template에 사용 (이중 하나라도 빼먹으면 오류발생!) ​ 🤷‍♂️ 1번 내용부터 실습해보자 부모(views)에 자식(components)를 품는 상황을 가정하고 코딩 (Step 1~3 으로 구성) Step 1. // App.vue \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e //Component에 등록한 name 사용법 (위 아래가 동일) \u003crouter-link :to=\"{ name: 'Parent' }\"\u003eParnet\u003c/router-link\u003e | //디폴트 사용법 \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e // 연결된 router의 내용을 보여주는 곳 \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e Step 2. // components/Child.vue (직접 생성) \u003ctemplate\u003e \u003cdiv class=\"child\"\u003e \u003ch2\u003e자식 컴포넌트\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'Child', } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .child { border: 3px solid blue; margin: 3px; padding: 3px; } \u003c/style\u003e Step 3. // views/Parent.vue (직접 생성) // views에 components 등록 ✨ Point! 1. views에서 components를 등록(Parent가 Child를 품고 싶다면)하고 싶다면, 1) components의 \u003cscript\u003e\u003c/script\u003e에 import 진행 2) \u003cscript\u003e\u003c/script\u003e안에 components: {Child}의 문법으로 등록 3) \u003ctemplate\u003e\u003c/template\u003e안에 components이름으로 탭을 만들면 해당 위치에 components 표현 가능 \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003ch1\u003e부모 컴포넌트\u003c/h1\u003e \u003c!-- step 3. 사용 (feat. 나중에 자식에게서도 데이터를 받음. this.$emit('hungry' 여기 값을 반영)) --\u003e \u003cChild/\u003e \u003ch2\u003e최하단입니다.\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e // step 1. import import Child from '../components/Child.vue' export default { name: 'Parent', // step 2. 등록 }, components: { // 'Child': Child, 키 벨류가 같으면 아래와 같이 사용가능 Child, } } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .parent { border: 3px solid red; margin: 3px; padding: 3px; } \u003c/style\u003e ​ ※ Vue 프로젝트를 생성해 components를 등록하고, 화면을 구성하다보면 각각의 components에서 작성 또는 변경된 데이터를 이리저리 보낼 수 있다면 더 다양한 것을 할 수 있어진다. 이를 위한 것이 props(부모에서 자식에게 데이터 이동)와 emit(자식에서 부모에게 데이터 이동)이다. ​ 🤷‍♀️ 2번 내용도 실습해보자 부모 views에서 자식 component간의 용돈을 주고 받는 상황을 가정하고 코딩해보자 (Step 1~4) Step 1. ## App.vue \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv id=\"nav\"\u003e \u003c!-- Component에 등록한 name 사용법 (위 아래가 동일) --\u003e \u003crouter-link :to=\"{ name: 'Parent' }\"\u003eParnet\u003c/router-link\u003e | \u003c!-- 기존 사용법 --\u003e \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e \u003c!-- 연결된 router의 내용을 보여주는 곳 --\u003e \u003crouter-view/\u003e \u003c/div\u003e \u003c/template\u003e \u003cstyle\u003e... Step 2. ## views/Parent.vue (직접 생성) ## 부모에서 자식에게 데이터 전달 (views → components) ✨ Point! 1. views에서 components를 등록(Parent가 Child를 품고 싶다면)하고 싶다면, 1) components의 \u003cscript\u003e\u003c/script\u003e에 import 진행 2) \u003cscript\u003e\u003c/script\u003e안에 components: {Child}의 문법으로 등록 3) \u003ctemplate\u003e\u003c/template\u003e안에 components이름으로 탭을 만들면 해당 위치에 components 표현 가능 2. views에서 components에 데이터를 넘길때에는, 1) \u003ctemplate\u003e\u003c/template\u003e안에 components탭에 :내리고 싶은 데이터=\"데이터명\" `:propFromParentMsg=\"parentMsg\"`의 문법으로 전달 \u003ctemplate\u003e \u003cdiv class=\"parent\"\u003e \u003ch1\u003e부모 컴포넌트\u003c/h1\u003e \u003c!-- step 3. 사용 --\u003e \u003cChild :propFromParentMsg=\"parentMsg\"/\u003e \u003ch2\u003e최하단입니다.\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e // step 1. import import Child from '../components/Child.vue' export default { name: 'Parent', // step 2. 등록 data () { return { parentMsg: '용돈 필요하니(부모가 전달한 메세지)' } }, components: { // 'Child': Child, 키 벨류가 같으면 아래와 같이 사용가능 Child, } } \u003c/script\u003e \u003c!-- views에서 components를 담을 때 모습이 어떻게 담기는기 보기 위해 경계선을 구현 --\u003e \u003cstyle\u003e .parent { border: 3px solid red; margin: 3px; padding: 3px; } \u003c/style\u003e Step 3. ## components/Child.vue (직접 생성) ## 1. views에서 components에 받은 데이터 노출 (부모에게서 받은 데이터 노출) ## 2. components에서 views에 데이터 전달 (자식에서 부모에게 데이터 전달) ✨ Point! 1. views에서 받은 데이터를 노출하고 싶다면, 1) \u003cscript\u003e\u003c/script\u003e에 전달받은 데이터의 자료형을 선언해주며 등록 ex) props: {propFromParentMsg: String,} 2) 보간법('{{}}')을 사용하여 노출. ex) {{ propFromParentMsg }} 2. components에서 views에 데이터를 넘길때에는 이벤트를 생성해 전달하는데, 1) 부모에게 전달한 메서드 만든다. methods: { moneySignal () {this.$emit('needMoney')} } : 📌 this.$emit() : 부모에게 전달하는 이벤트 이름 📌 2) 메서드를 작동시킬 이벤트를 만든다. ex) \u003cbutton @click=\"moneySignal\"\u003e용돈 필요해요!!!\u003c/button\u003e → 클릭시 moneySignal이라는 메서드 실행 \u003ctemplate\u003e \u003cdiv class=\"child\"\u003e \u003ch2\u003e자식 컴포넌트\u003c/h2\u003e \u003c!-- 부모에게서 받은 데이터 노출 --\u003e {{ p","date":"2020-07-17","objectID":"https://colinder.github.io/03_vue_cli/:1:0","tags":["Vue"],"title":"03_Vue_cli \u0026 router \u0026 histoyMode","uri":"https://colinder.github.io/03_vue_cli/"},{"categories":["Vue"],"content":"​ ","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:0:0","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"Vue의 기본 문법 및 동작 방법을 계속 알아보자 08_methods ✨Point 1. method는 methods: {}의 문법으로 구성한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eMethods\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e {{ message }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' }, methods: { alertWarning: function() { alert('WARNING') }, alertWarning () { // Syntactic Sugar : 위와 완전히 동일 alert(this.message) }, changeMessage() { this.message = 'CHANGED MESSAGE' } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 09_v-on 위에서 선언한 methods를 이제 실행한다. ✨Point (아주아주 중요) 1. 난, v-on은 이벤트(methods 등)를 실행시켜주는 트리거라고 이해했다. 2. 트리거를 발동시키는 내용은 여러가지가 있으니 이는 별도로 공부해야 한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-on\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003ch1\u003e{{ message }}\u003c/h1\u003e \u003cbutton v-on:click=\"alertWarning\"\u003eAlert warning\u003c/button\u003e \u003cbutton v-on:click=\"alertMessage\"\u003eAlert Message\u003c/button\u003e \u003cbutton v-on:click=\"changeMessage\"\u003eChange Message\u003c/button\u003e \u003c!-- v-on: 는 @ 로 축약해서 사용할 수 있다. --\u003e \u003cbutton @click=\"changeMessage\"\u003eChange Message\u003c/button\u003e \u003chr\u003e \u003cinput v-on:keyup.enter=\"onInputChange\" type=\"text\"\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' }, methods: { alertWarning: function() { alert('WARNING') }, alertMessage () { // Syntactic Sugar : 위와 완전히 동일 alert(this.message) }, changeMessage() { this.message = 'CHANGED MESSAGE' }, onInputChange(event) { // console.log(\"!!\") // if (event.key === 'Enter') { this.message = event.target.value // } }, } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 👍 v-on 이벤트 종류는 여기에 모두 있다. ​ 10_v-model ✨Point 1. data값과 input값을 실시간으로 연동(양방향 바인딩)해주는 디렉티브 2. v-on(@)과 value를 동시에 걸어주면 양방향 바인딩이 가능함. 3. v-model은 input, select, textarea에만 사용이 가능함. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-model\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003e{{ message }}\u003c/h1\u003e \u003ch4\u003e단반향 binding (input =\u003e data)\u003c/h4\u003e 1way \u003cinput @keyup.enter=\"onInputChange\" type=\"text\"\u003e \u003chr\u003e \u003ch4\u003e양방향 binding\u003c/h4\u003e 2way \u003cinput @keyup.enter=\"onInputChange\" type=\"text\" :value=\"message\"\u003e \u003chr\u003e \u003c!-- 단뱡향과 양방향을 구분하기 귀찮아서 model을 개발 --\u003e \u003ch4\u003ev-model 양방향 binding\u003c/h4\u003e v-model/2way \u003cinput v-model=\"message\" type=\"text\"\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el:'#app', data: { message: 'hi' }, methods: { onInputChange(event) { this.message = event.target.value } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 11_v-show ✨Point 1. v-if와 거의 유사하나 개발자 도구로 찍어보면 v-if는 조건에 따라 렌더링이 있다 없다 하지만, v-show의 요소는 항상 렌더링 되고 DOM에 남아있다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ev-show\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003c!-- v-if와 거의 유사!--\u003e \u003cbutton @click='changeF'\u003echangeF\u003c/button\u003e \u003cp v-if=\"t\"\u003eTrue\u003c/p\u003e \u003cp v-if=\"f\"\u003efalse\u003c/p\u003e \u003cp v-show=\"t\"\u003eshow True\u003c/p\u003e \u003cp v-show=\"f\"\u003eshow false\u003c/p\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: \"#app\", data: { t: true, f: false, }, methods: { changeF() { this.f = !this.f } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 12_computed ✨Point 1. computed는 페이지 시작시 별다른 선언없이도 자동으로 실행된다. 2. script태그 안에 computed: {} 와 같이 선언해 사용 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003ch1\u003eBankrruped\u003c/h1\u003e {{ getBankrrupedPeople }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { accounts: [ { name: 'neo', balance: 500, isBankrruped: tr","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:1:0","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"종합 실습(로또 번호 추천) \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003elotto\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cbutton @click=\"getLuckySix\"\u003egetLuckySix\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"number in myNumbers\"\u003e {{ number }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c!-- 수학적 커멘드는 lodash 활용 --\u003e \u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: \"#app\", data: { allNumbers: _.range(1, 46), myNumbers: [] }, methods: { getLuckySix() { this.myNumbers = _.sampleSize(this.allNumbers, 6) // vue는 str로 자료를 보는데 이를 정수로 바꾸기 위한 코드는 아래와 같다. // vue에서 str과 str을 빼는 건 int로 값이 나오기 때문에 this.myNumbers.sort((a, b) =\u003e a - b) } }, }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2020-07-17","objectID":"https://colinder.github.io/02_vue_basic/:1:1","tags":["Vue"],"title":"02_Vue_basic (Vue 문법2)","uri":"https://colinder.github.io/02_vue_basic/"},{"categories":["Vue"],"content":"​ Vue Vue.js는 웹 애플리케이션의 사용자 인터페이스를 만들기 위해 사용하는 오픈 소스 프로그레시브 자바스크립트 프레임워크 간단히, 온라인 홈페이지를 만드는 프로그램입니다. 아래 정리할 내용들이 당장 크게 와닿지 않을 수 있습니다. 하지만 필요할 때 보면, 도움이 될 것입니다! ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:0:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"Vue의 이론적 구성 및 설명을 알아보자 1. Vue는 MVVM 패턴을 따른다. MVVM(Model-View-ViewModel) 패턴? 모델과 뷰 사이에 뷰모델이 위치하는 구조 ​ 2. Vue는 SPA (Single-Page Application) 서버로부터 완전한 새로운 페이지를 불러오지 않고 현재의 페이지를 동적으로 다시 작성함으로써 사용자와 소통하는 웹 애플리케이션을 말한다. 내가 이해한 방식: 변경사항이 발생했을 때 새로고침을하며 매번 페이지를 새롭게 구성하는 것이 아니라, 서버를 돌릴 때 이미 모든 페이지가 제작되어 있고 이를 사용자의 선택에 따라 보여주는 것. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:1:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"Vue의 기본 문법 및 동작 방법을 알아보자 01_data 선언 ✨Point 1. data는 함수로 선언하여 등록하고 사용한다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c/div\u003e \u003c!-- Vue를 사용하겠다는 CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', // component별로 data(변수등록)는 함수로 선언하여 사용한다. data: { message: 'Hello Vue' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 02_interpolation(보간법) ✨Point 1. 보간법: 두 점을 연결하는 방법 2. 난, `data(변수)는 script태그에 함수 형태로 선언하며, {{}} 2개의 중괄호 안에 변수명을 적어 사용한다.` 정도로 이해했다. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e {{ message }} \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: 'Hello Vue' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 03_v-text ✨Point 1. data에 선언된 변수를 그대로 가져와서 노출 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c!-- Vanilla JS. domElenment.innText --\u003e \u003c!-- v- 로 시작하는 것들은 모두 디렉티브(명령하는 것)라고 부른다. --\u003e \u003cp v-text='message'\u003e\u003c/p\u003e \u003cp\u003e{{ message }}\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { message: '완전히 같아요' } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 04_v-if ✨Point 1. 태그 안 v-if가 true일 때만, 값이 노출된다. 2. vue에선 빈 리스트는 True값 반환 3. 이외에 false, 빈스트링(\"\"), 0은 False값 반환 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eVue-if\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cp v-if='bool1'\u003etrue는 참이니 노출\u003c/p\u003e \u003c!--bool1이 참이니까. true가 보인다.--\u003e \u003cp v-if='bool2'\u003efalse\u003c/p\u003e \u003c!--bool2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='str1'\u003e비어있지 않은 문자열은 True\u003c/p\u003e \u003c!--str1이 참이니까. true가 보인다.--\u003e \u003cp v-if='str2'\u003e비어있으면 false고 노출 안됨\u003c/p\u003e \u003c!--str2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='num1'\u003e1은 True\u003c/p\u003e \u003c!--num1이 참이니까. true가 보인다.--\u003e \u003cp v-if='num2'\u003e0은 false\u003c/p\u003e \u003c!--num2이 거짓이니까. false가 안보인다.--\u003e \u003cp v-if='arr'\u003e빈 리스트는 arr_True!!!\u003c/p\u003e \u003c!-- vue는 빈배열이 true 평가 --\u003e \u003cp v-if='arr.length'\u003earr_false\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { bool1:true, bool2:false, str1:'Yes', str2:'', num1:1, num2:0, arr: [], } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 05_v-if-elseif-else ✨Point 1. vue에선 if / elseif / else을 나누어 사용 가능. \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003c!-- 조건식도 가능 --\u003e \u003cp v-if=\"username === master\"\u003ehello master\u003c/p\u003e \u003cp v-else\u003ehello user\u003c/p\u003e \u003chr\u003e \u003cp v-if=\"number \u003e 0\"\u003e양수\u003c/p\u003e \u003cp v-else-if=\"number \u003c 0\"\u003e음수\u003c/p\u003e \u003cp v-else\u003e영\u003c/p\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { username: 'master', number: 0, } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ​ 06_v-for ✨Point (아주아주 중요) 1. list안에 담으면 for사용 가능 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='app'\u003e \u003cul\u003e \u003cli v-for='number in numbers'\u003e{{ number }}\u003c/li\u003e \u003c!-- 이런 것도 가능 --\u003e \u003cli v-for='number in numbers'\u003e{{ number + 1 }}\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli v-for='teacher in teachers'\u003e{{teacher}}\u003c/li\u003e \u003cli v-for='teacher in teachers'\u003e{{teacher.name}}\u003c/li\u003e \u003c/ol\u003e \u003c/div\u003e \u003c!-- CDN 설정 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e const app = new Vue({ el: '#app', data: { numbers: [0,1,2,3,4,5], teachers: [ { name: 'neo'}, { name: 'tak'}, ] } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e v-for 연관된 key라는 것이 있","date":"2020-07-17","objectID":"https://colinder.github.io/01_vue_basic/:2:0","tags":["Vue"],"title":"01_Vue_basic (Vue란? \u0026 Vue 문법1)","uri":"https://colinder.github.io/01_vue_basic/"},{"categories":["Vue"],"content":"​ Vue Vue.js는 웹 애플리케이션의 사용자 인터페이스를 만들기 위해 사용하는 오픈 소스 프로그레시브 자바스크립트 프레임워크 간단히, 온라인 홈페이지를 만드는 프로그램입니다. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:0:0","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"1. 시작하기 ‘Vue’ VS ‘Django’ 어느 정도 공부를 하면서 체득한 가장 큰 구분점은 “Django는 App별로 응답을 구분하고, Vue는 Component별로 응답을 구분한다.“는 것입니다. 큰 차이가 없어보이고, 큰 의미가 없어보일 수 있으나 알아두면 좋습니다! ​ 💻 개발 환경 설정 vscode 설치 nodeJS 설치 # 🤔 안정적인 버전 vs 최신 버전 # 상관없으나 개인적으로 안정적인 버전을 추천합니다. # 😀 설치가 잘 되었나 확인 방법! # terminal창(cmd) -\u003e node -v (명령어 입력) # 버전 넘버가 보이면 정상 설치 된 것입니다. 프로젝트를 시작할 폴더에서 마우스 오른쪽 클릭 후 vscode 실행 =\u003e terminal에서 npm install 설치 이후 Terminal에서 추가로 npm i -g @vue/cli 설치 설치가 잘 되었나 vue --version으로 확인 (버전이 보이면 ok) (선택사항) vscode의 추천 Extensions Vetur Vue VSCode Snippets Auto Rename Tag Auto Close Tag ​ 🎉 프로젝트 생성 $ vue create myproject # myproject 프로젝트 생성 $ cd myproject # 생성한 myproject 폴더로 이동 $ vue add router # (선택사항) myproject 히스토리를 관리해줄 router기능 설치 $ npm run serve # myproject의 디폴트 서버 실행 App running at: - Local: http://localhost:8080/ - Network: http://192.168.219.164:8080/ 이후 Local로 접속하면 생성된 서버 페이지 확인이 가능하다. 또 같은 공유기를 사용하고 있는 기기에서 접속하여 서버 확인이 가능하다. ​ 생성된 프로젝트의 기본사항 파악 Terminal창에 vue create myproject 명령어 입력 후 이와 같은 창이 뜨는데 default로 설정하고 enter하고, 프로젝트를 시작한다. ​ 프로젝트 생성이 완료되면 (router 미설치) 이와 같은 폴더 구조를 확인할 수 있다. ​ vue add router를 한다면. 두번의 묻는데 전부 y 로 처리(router와 history mode 설정을 묻는 것) ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:0","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"여기서 잠깐✋ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:1","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"1. VUE CLI 란? (공식문서) 간단히 vue-cli 는 기본 vue 개발 환경을 설정해주는 도구 여기서 CLI 란 ? 명령 줄 인터페이스(CLI, Command line interface) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호 작용하는 방식. 즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다. (출처: 위키백과) ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:2","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"2. vue add router 필요한가? 라우팅은 URI에 따라 해당하는 정적파일을 보여주는 방식. 이를 브라우저에서 구현 하는것이 SPA 개발의 핵심 아이디어는 간단하다. 요청 URI에 따라 브라우저에서 DOM을 변경하는 방식. 대부분의 경우 도움이 되는 기능이기 때문에 상당이 추천한다. (추가로 navbar? 도 생기니 더욱 추천) terminal에 vue add router 를 입력하면 history 모드를 사용하겠나고 묻는데 y 를 입력해주면 된다. ​ ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:3","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["Vue"],"content":"3. vue add router 후 History Mode 설정은 왜 필요한가? vue add router를 설치하게 되면 해쉬백 모드와 히스토리 모드 중 디폴트로 해쉬백 모드가 적용된다. 만약 위의 그림에서 히스토리 모드를 사용하지 않더라도 나중에 URL에 있는 해쉬를 제거하기 위해 라우터의 히스토리 모드로 변경할 수 있다. # src/router/index.js const router = new VueRouter({ mode: 'history', 👈요거를 등록하면 history 모드 실행 routes: [...] }) ","date":"2020-07-17","objectID":"https://colinder.github.io/00_vue_setting/:1:4","tags":["Vue"],"title":"00_Vue_setting","uri":"https://colinder.github.io/00_vue_setting/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4676_늘어지는 소리 만들기 for T in range(int(input())): sent = list(input()) # wow H = int(input()) po = sorted(list(map(int, input().split()))) # 2 3 2 for i in range(H): a = po[i]+i sent.insert(a,'-') print('#{} {}'.format(T+1, ''.join(sent))) # 단순 산수로 해결 ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4615_재미있는 오셀로 게임 dx = [0, 1, 1, 1, 0, -1, -1, -1] dy = [1, 1, 0, -1, -1, -1, 0, 1] def dfs(x, y, i ,stone): if board[x][y] == 0: return 0 elif board[x][y] == stone: return 1 else: if dfs(x+dx[i], y+dy[i], i, stone): board[x][y] = stone return 1 else: return 0 for T in range(int(input())): N, M = map(int, input().split()) command = [list(map(int, input().split())) for _ in range(M)] board = [[0]*(N+2) for _ in range(N+2)] board[N//2+1][N//2+1] = 2 board[N//2][N//2] = 2 board[N//2][N//2+1] = 1 board[N//2+1][N//2] = 1 for x, y, stone in command: for i in range(8): board[x][y] = stone dfs(x+dx[i], y+dy[i], i, stone) B = 0 W = 0 for i in range(N): for j in range(N): if board[i+1][j+1] == 1: B += 1 elif board[i+1][j+1] == 2: W += 1 print(f'#{T+1} {B} {W}') # dfs를 연습해볼 수 있는 좋은 문제라고 생각한다. # 추가적인 조건이 있어 dfs를 많이 사용해보지 못한 나는 해결하는데 오랜 시간이 걸렸다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4579_세상의 모든 팰린드롬 2 for T in range(int(input())): arr = input() result = 'Exist' for i in range(len(arr) // 2): if arr[i] == '*' or arr[-1 - i] == '*': result = 'Exist' break if arr[i] != arr[-1 - i]: result = 'Not exist' break print(f'#{T+1} {result}') # *이 등장하기 전까지 대칭을 이루고 있다면 무조건 'Exist'이고, # 만약 *가 없다면, 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"D3_4522_세상의 모든 팰린드롬 for T in range(int(input())): arr = list(map(str, input())) result = 'Exist' for i in range(len(arr)): if arr[i] == '?': arr[i] = arr[-i - 1] if arr != arr[::-1]: result = 'Not exist' print(f'#{T+1} {result}') # ?가 등장하면 무조건 해당 index의 반대쪽이 대칭을 이룬다고 생각할 수 있으니까, # ?의 index 반대쪽을 동일하게 변경해주고 대칭인지 판별하면 된다. ​ ","date":"2020-07-10","objectID":"https://colinder.github.io/sw_20.07.10/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 4676, 4615, 4579, 4522","uri":"https://colinder.github.io/sw_20.07.10/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_5162_두가지 빵의 딜레마 for T in range(int(input())): A, B, C = map(int, input().split()) N = min(A, B) print(\"#{} {}\".format(T+1, int(C/N))) # 단순 산수로 해결 ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4789_성공적인 공연 기획 for T in range(int(input())): P = list(map(int, map(str, input()))) need = P[0] count = 0 for i in range(1, len(P)): if need \u003e= i: need += P[i] else: count += i - need need = i + P[i] print(f'#{T+1} {count}') # 문제를 이해하는 것이 Point였다. # 먼저 str로 input을 받아 개별 숫자로 나누고 바로 int 변경하여 인자를 받음. # # \"i번째 글자가 의미하는 바는 기립 박수를 하고 있는 사람이 i-1명 이상일 때 기립 박수를 하는 사람의 수\" # Test case3의 경우 (09) 9는 큰 의미 없이 2번째 글자임으로 기립박수를 하고 있는 사람이 1명일 이상일 때 기립박수를 친다. # 즉 index만 가지고 조건을 판단 하면 된다! ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4751_다솔이의 다이아몬드 장식 T= int(input()) for tc in range(T): text = input() n= len(text) for i in range(5): if i == 0 : print('..#.'*n+'.') elif i == 1 : print('.#'*(n*2)+'.') elif i == 2 : print('#',end='') for a in range(len(text)) : print(('.{}.#'.format(text[a])), end=\"\") elif i == 3 : print() print('.#'*(n*2)+'.') elif i == 4 : print('..#.' * n + '.') # 단순 작업이었으나, 반복되는 곳의 기준을 어디로 할 것인가를 잘 지정해야 함. ​ ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"D3_4698_테네스의 특별한 소수 ","date":"2020-07-08","objectID":"https://colinder.github.io/sw_20.07.08/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5162, 4789, 4751, 4698","uri":"https://colinder.github.io/sw_20.07.08/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5431_민석이의 과제 체크하기 for T in range(int(input())): N, K = map(int, input().split()) P = list(map(int, input().split())) result = [] for i in range(1,N+1): if i not in P: result.append(str(i)) print('#{} {}'.format(T+1, ' '.join(result))) # 제출한 수강생 리스트를 만들고(P) 이를 for로 돌리며 검증 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5356_의석이의 세로로 말해요 for T in range(int(input())): sent = [list(str(input())) for _ in range(5)] #입력받은 요소의 길이를 알아내야 한다. max = 0 for n in range(5): long = len(sent[n]) if long \u003e= max: max = long result = '' for i in range(max): for j in range(5): try: if sent[j][i] != \"\": result += sent[j][i] except IndexError: pass print(f'다시 풀이 #{T+1} {result}') # 입력받은 5개의 단어 중 가자 긴 단어의 길이를 저장하고(long) # long 길이 만큼 순회를 하면서 5개의 단어에 index로 접근하고 index값이 비어있지 않으면 result에 추가 ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5293_이진 문자열 복원 for T in range(int(input())): A, B, C, D = map(int, input().split()) if B == 0 and C == 0 and A != 0 and D != 0: result = 'impossible' elif abs(B - C) \u003e 1: result = 'impossible' else: if B == 0 and C == 0: if A != 0: result = '0' * (A + 1) else: result = '1' * (D + 1) elif B \u003c C: result = '1' * D + '10' * C + '0' * A elif B \u003e C: result = '0' * A + '01' * B + '1' * D else: result = '0' * A + '01' * B + '1' * D + '0' print('#{} {}'.format(T+1, result)) # 하드코딩...ㅎㅎ ​ ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["SW Expert Academy"],"content":"D3_5215_햄버거 다이어트 for T in range(int(input())): N, maxKcal = map(int, input().split()) Sum = [0] * (10**4 + 1) for _ in range(N): Point, Kcal = map(int, input().split()) for idx in range(maxKcal, Kcal + 1, -1): if Sum[idx] \u003c Sum[idx - Kcal] + Point: Sum[idx] = Sum[idx - Kcal] + Point print(f'#{T+1} {Sum[maxKcal]}') ","date":"2020-07-01","objectID":"https://colinder.github.io/sw_20.07.01/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5431, 5356, 5293, 5215","uri":"https://colinder.github.io/sw_20.07.01/"},{"categories":["Hugo"],"content":"​ 블로그를 만들면서… 최초 기술블로그를 제작하면서 바닥부터 모든 것을 스스로 만들어 보기로 결심하고 제작을 시작하지만, 결코 쉽지 않았다. 개인적으로 꼭 원했던 기능이었던 tag기능과 categories를 구현하지 못하면서… 결국 기존에 있는 라이브러리들을 활용하기로 한다. ​ 가장 많은 사용자가 존재하는 jekyll로 시작한다. ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:0:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"jekyll 기초 설정 Jekyll : Jekyll은 Ruby Gem으로 제공되며 템플릿과 템플릿의 구성요소, 인라인 코드, 마크다운과 같은 동적인 구성요소를 정적인 웹페이지로 만들어주는 파싱 엔진 ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:1:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"jekyll 서버 구동 방법 # 공식 홈페이지 설명 ~$ gem install bundler jekyll # jekyll 구동을 위한 프로그램 설치 ~$ jekyll new MYBLOG # MYBLOG 라는 이름의 블로그 폴더 \u0026 기초틀 생성 ~$ cd MYBLOG # MYBLOG 폴더로 이동 ~MYBLOG $ bundle exec jekyll serve # MYBLOG 서버 구동 # 이후 명령창에 Servuer address : http://127.0.0.1:4000/ #로 인터넷 접속하면 jekell의 디폴트 서버 모습이 보인다. ​ 포스팅을 하면서 이 내용을 정리할 때쯤. 알 수 없는 치명적인 오류로 인해 작성했던 .md파일과 git 서버가 폭파했다. 여러 방면으로 복구를 시도했지만, 모든 방법이 실패했고. 그리하여.. 난 jekyll을 떠나 Hugo로 이동하기로 했다. ​ Why Hugo? #1. window를 공식 지원한다. ( Jekyll은 window를 공식적으로 지원하진 않는다. ) → Hugo가 Jekyll 보다 window환경에서 안정적이지 않을까? #2. The world’s fastest framework for building websites → 빠르다. Hugo로 블로그를 구축하고 / 이를 git의 서버를 통해 배포한다. ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:1:1","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"Hugo로 github.io 블로그 만들기 ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:0","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"1. Git, Hugo 설치 Git 설치란? Git_bash설치를 뜻한다. 링크를 타고 들어가 적절한 버전을 선택해 설치를 진행한다. ​ 👉 bash를 실행시키고 git --version을 입력해서 version 정보가 확인되면 정상 설치가 된 것이다. ​ Hugo 설치 (공식홈페이지의 Quick_Start 참고) ​ 👉 난 Hugo_release에서 최신버전을 다운받아 직접 설치했다. C:\\Hugo\\bin\\에 압축을 해제. window + Q로 검색창을 연 뒤 변수를 검색해서 시스템 환경 변수 편집에 들어간다. 아래의 환경 변수(N)를 클릭. 위쪽 박스에서 Path를 더블클릭한다. 새로 만들기를 클릭 후, 아까 압축을 풀었던 곳인 C:\\Hugo\\bin를 등록. 닫고 배경화면에서 bash 실행 후 hugo version을 입력해서 version 정보가 나오면 잘 설치가 된 것. ​ 어마어마한 특이사항 발견..(20.10.17) 난 커스텀이 되는 테마를 받아서 사용했으나, 아무리 시도해도 커스텀이 적용되지 않았었는데 만약 내가 사용할 테마가 Sass/SCSS를 사용한다면 반드시 extended version으로 설치하여야 한다!! extended version은 기본 버전에서 Sass/SCSS 프로세싱을 지원이 추가된 버전이다! ​ ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:1","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["Hugo"],"content":"2. Hugo 블로그 구축하기 프로젝트를 구축할 폴더(혹은 장소)에서 bash를 실행 hugo new site \u003c프로젝트 이름\u003e # ex) hugo new site MyBlog → MyBlog라는 프로젝트 폴더를 생성. hugo에서 site, theme, content를 만들때는 항상 new command를 사용하여 생성한다. 이때 생성된 폴더는 프로젝트폴더, root폴더, default폴더 등으로 불리며, 기본 구조는 이러하며, 먼저 테마를 설정해보자. 필자는 LoveIt 테마를 선택해 사용함. ​ Theme는 다운 → 적용의 2단계를 거친다. ​ ​ 1. 다운 먼저 LoveIt 테마 Git홈페이지에 가 clone을 떠온다. 프로젝트폴더에서 bash를 실행 후 cd theme # theme 폴더로 이동 git clone https://github.com/dillonzq/LoveIt.git # LoveIt 테마 클론(다운) ​ ​ 2. 적용 프로젝트폴더속 config.toml파일을 열어 수정을 하여 적용하는데 적용 방법은 각 Theme의 git_site에 정리 되어 있다. LoveIt theme의 경우 아래와 같은 방법으로 설정하며 추가 버전이 release되어 있어 이를 적용하는 방법은 공식 문서를 읽어보며 custom한다. baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" # Change the default theme to be use when building the site with Hugo theme = \"LoveIt\" ... ... ","date":"2020-06-29","objectID":"https://colinder.github.io/hugo_setting/:2:2","tags":["Hugo"],"title":"Hugo_setting stroy (feat.LoveTt 제작자)","uri":"https://colinder.github.io/hugo_setting/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5948_새샘이의 7-3-5 게임 for T in range(int(input())): N = list(map(int, input().split())) result = set() for i in range(5): for j in range(i+1, 6): for x in range(j+1, 7): result.add(N[i]+N[j]+N[x]) result = list(result) result.sort() print('#{} {}'.format(T+1, result[-5])) # 3수의 합을 정리하는데 set으로 중복을 제거하는 방법으로 result set을 정리 # set은 순서가 없기 때문에 result를 다시 list로 정리하고 .sort를 이용해 순서대로 나열 후 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5789_현주의 상자 바꾸기 for T in range(int(input())): N, Q = map(int, input().split()) arr = ['0' for _ in range(N)] for i in range(1, Q+1): L, R = map(int, input().split()) for _ in range(L-1, R): arr[_] = str(i) print('#{} {}'.format(T+1, ' '.join(arr))) # arr이라는 0이 적힌 상자 리스트를 생성 # index L~R에 _의 숫자를 입력(출력하기 쉽게 str형태로 입력) # join을 써서 str형태의 list인자를 붙여서 출력 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5688_세제곱근을 찾아라 for T in range(int(input())): N = round(int(input())**(1/3), 2) print(\"#{} {}\".format(T+1, int(N) if int(N) == N else -1)) # 출력 방식에 조건을 넣어서 시도해봄 ​ ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"D3_5549_홀수일까 짝수일까 for T in range(int(input())): N = int(input()) print('#{} {}'.format(T+1, 'Even' if N%2 == 0 else 'Odd')) # 출력 방식에 조건을 넣어서 시도해봄 ","date":"2020-06-25","objectID":"https://colinder.github.io/sw_20.06.25/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 5948, 5789, 5688, 5549","uri":"https://colinder.github.io/sw_20.06.25/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6190_정곤이의 단조 증가하는 수 for T in range(int(input())): N = int(input()) L = list(map(int, input().split())) result = -1 for i in range(N-1): for j in range(i+1, N): num = str(L[i]*L[j]) if len(num) \u003e 1 and '0' not in num and result \u003c int(num) and list(num) == sorted(num): result = int(num) print(f'#{T+1} {result}') # 단조증가하는 지를 검증하는 방법으로 sorted를 썼는데 이를 활용하기 위해서는 str형태로 변경해야 검증이 가능하다. # 한자리 숫자는 단조증가하는 수가 아니다. # 중간에 0이 있다면 볼 필요도 없이 단조증가수가 아니기 때문에 처리 속도 증가가 가능하다. ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6057_그래프의 삼각형 for T in range(int(input())): N, M = map(int,input().split()) # N: 정점, M: 간선 arr = [[0]*(N+1) for n in range(N+1)] # part1 for _ in range(M): X, Y = map(int,input().split()) arr[X][Y] = 1 arr[Y][X] = 1 # part2 result = 0 for i in range(1, N+1): for j in range(i+1, N+1): if arr[i][j] == 1: for r in range(j+1, N+1): if arr[j][r] == 1 and arr[r][i] == 1: result += 1 print(f\"#{T+1} {result}\") # part1에서 삼각형의 정점의 정보를 담는 arr을 만들고 # part2에서 만들어진 배열을 돌며 정점의 정보를 발견(1)하면 해당 정점을 기준으로 삼각형이 되는지 검증 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_6019_기차 사이의 파리 for T in range(int(input())): D, A, B, F = map(int,input().split()) t = D / (B+A) print('#{} {}'.format(T+1, F*t)) #단순 수학으로 해결 ​ ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"D3_5986_새샘이와 세 소수 for T in range(int(input())): N = int(input()) # part1 PN = set() for i in range(2, N+1): for j in range(2, i+1): if i % j == 0: break PN.add(j) PN =list(PN) pn = PN.sort(reverse=True) # part2 count = 0 for i in range(len(PN)): for j in range(i,len(PN)): for k in range(j,len(PN)): if N == PN[i]+PN[j]+PN[k]: count += 1 print('#{} {}'.format(T+1, count)) # part1에서 소수 리스트를 만들고(1과 자기 자신만을 약수로 가지는 수 리스트) # part2에서 세 소수의 합으로 나타낼 경우의 수를 종합. ","date":"2020-06-23","objectID":"https://colinder.github.io/sw_20.06.23/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 6190, 6057, 6019, 5986","uri":"https://colinder.github.io/sw_20.06.23/"},{"categories":["SW Expert Academy"],"content":"​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:0","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_9700_USB 꽂기의 미스터리 for T in range(int(input())): p, q = map(float, input().split()) s1 = (1-p)*q s2 = p*(1-q)*q if s1 \u003c s2: print(f'#{T+1} YES') else: print(f'#{T+1} NO') # 단순 수학을 통해 해결. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:1","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_7675_통역사 성경이 for T in range(int(input())): N = int(input()) sent = input() sent = sent.replace('.', ' @').replace('!', ' @').replace('?', ' @').split() #print(sent) result = \"\" count = 0 for i in sent: if i.isalpha() and i == i.capitalize(): count += 1 if i == '@': result += str(count) + ' ' count = 0 print(\"#{} {}\".format(T+1, result)) # 주어지는 문장을 띄어쓰기를 기준으로 나누기 위해 .split()을 사용하고 # 문제에서 주어진 `이름`의 조건이 `첫 알파벳이 대문자이고 나머진 소문자`이기 때문에 # 문자로만 이루어져있는 것인지 .isalpha()로 검증 (VS .isdigit() 주어진 문자열이 숫자인지 검증) # `이름`의 조건이 맞는지 .capitalize()로 검증 # 추가 공부 내용 # upper - 주어진 문자열에서 모든 알파벳들을 대문자로 변환시킨다. # capitalize - 주어진 문자열에서 맨 첫 글자를 대문자로 변환하고 나머지는 소문자로 변환시킨다. # title - 주어진 문자열에서 알파벳 외의 문자(숫자, 특수기호, 띄어쓰기 등)로 나누어져 있는 영단어들의 첫 글자를 모두 대문자로 변환시킨다. # .isalpha()와 .capitalize()를 알고나면 간단해지는 문제. ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:2","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6692_다솔이의 월급 상자 for T in range(int(input())): tc = int(input()) result = 0 for _ in range(tc): P, X = map(float, input().split()) result += P*X print(f'#{T+1} {result}') # input을 float형으로 받으면서 단순 수학을 사용해 해결 ​ ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:3","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":["SW Expert Academy"],"content":"D3_6485_삼성시의 버스 노선 for T in range(int(input())): info = [0]*5001 for N in range(int(input())): st, la = map(int, input().split()) for x in range(st, la+1): info[x] +=1 station = [] for P in range(int(input())): station.append(str(info[int(input())])) print('#{} {}'.format(T+1, ' '.join(station))) # info로 정류장의 index를 기록(중복되는 위치를 표기하기 위해 +1 씩 진행) # P개의 버스 정류장을 확인하는데 저장되어있는 info의 정류장 정보를 가져와서 station리스트에 기록 # 주어진 문제에서 만약 범위?를 알려준다면 그만큼의 저장 리스트를 생성하는 것이 빠르다. # 예를 들어 info = [] 보다 info = [0]*5001 로 설정해 사용하는 것이 더 빠른 실행시간을 보여준다. ","date":"2020-06-20","objectID":"https://colinder.github.io/sw_20.06.20/:0:4","tags":["algorithm"],"title":"SW Expert Academy_D3 9700, 7675, 6692, 6485","uri":"https://colinder.github.io/sw_20.06.20/"},{"categories":null,"content":"배포 방법 명령어 : ./deploy.sh ","date":"0001-01-01","objectID":"https://colinder.github.io/readme/:0:0","tags":null,"title":"","uri":"https://colinder.github.io/readme/"}]