<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - </title>
        <link>https://colinder.github.io/posts/</link>
        <description>All Posts | </description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 07 Oct 2021 10:17:20 &#43;0900</lastBuildDate><atom:link href="https://colinder.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Django_08_AbstractBaseUser VS AbstractUser</title>
    <link>https://colinder.github.io/django_08_abstractbaseuservsabstractuser/</link>
    <pubDate>Thu, 07 Oct 2021 10:17:20 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/django_08_abstractbaseuservsabstractuser/</guid>
    <description><![CDATA[​
Django AbstractBaseUser VS AbstractUser  Django로 프로젝트를 진행하면서 계정관련 내용을 등록하는 것을 가장 많이 했음에도, 아직 명확하게 차이를 알지 못하고 사용했던 것이 있었습니다.
바로! User custom에 관한 부분이었는데요. 크게 AbstractBaseUser와 AbstractUser를 사용하는 방법이 있는데 이 둘의 차이를 꼼꼼히 알아보기 위해 해당 포스팅이 작성되었습니다.
 ​
AbstractBaseUser VS AbstractUser  프로젝트 생성 후 accounts 라는 app을 만들고 makemigrations &amp; migrate를 하기 전
 ​
1. Model 설정 AbstractBaseUser
위치: accounts/models.py]]></description>
</item><item>
    <title>MariaDB 설치 방법</title>
    <link>https://colinder.github.io/mariadb_setting/</link>
    <pubDate>Wed, 15 Sep 2021 10:44:21 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/mariadb_setting/</guid>
    <description><![CDATA[​
MariaDB 설치 방법 1. 설치 https://mariadb.org/download/ 에서 자동으로 확인된 버전으로 다운로드 받습니다.
​
Next 클릭​
별도의 커스텀은 하지 않습니다.​
&lsquo;root 비밀번호 설정&rsquo;과 &lsquo;UTF 변환 및 외부에서 root 접속을 허용 할 것&rsquo;인지 물어보는 데 이곳이 중요합니다.
단순 개발용이라면 상관없을 수 있으나 개인적으로 실제 운용할 서버 or 개발 서버라도 외부에서 root에 접속하게 하는 것은 보안상 좋지 않을 것이라고 생각합니다.
실제로 서비스를 운영 할 서버라면 절때 root를 원격지에서 사용할 수 없게 하는 것을 추천합니다.]]></description>
</item><item>
    <title>Django_07_1:N 불러오기</title>
    <link>https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/</link>
    <pubDate>Tue, 14 Sep 2021 17:25:44 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/django_07_1vsn_%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/</guid>
    <description><![CDATA[​
Django 1:N 불러오기  prefetch_related() or annotate()
 ​
models.py 구성
1 2 3  class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&#39;date published&#39;)   1 2 3 4  class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE, related_name=&#39;choices&#39;) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0)   ​
​
prefetch_related() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # views.py def get_context_data(): context[&#34;questions&#34;] = Question.]]></description>
</item><item>
    <title>Django_06_Django &amp; Oracle18 error LOG</title>
    <link>https://colinder.github.io/django_06_djangooracle18_error_log/</link>
    <pubDate>Mon, 06 Sep 2021 11:41:44 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/django_06_djangooracle18_error_log/</guid>
    <description><![CDATA[​
Django &amp; Oracle 18 오류 일지  각종 스트레스의 원인에 대하여 해결방법을 정리합니다.
 ​
  ORA-00955: name is already used by an existing object
 1 2 3  # 해결법 python manage.py makemigrations python manage.py migrate --fake-initial    이미 migrate 한 내용을 수정하니 반영되지 않아 오류가 발생하였는데 위의 명령어는 migratie를 초기화해서 재설정 하는 것 같습니다.
​
  그리고 많은 경우에
 1 2  python manage.]]></description>
</item><item>
    <title>Django_05_Check DB connection</title>
    <link>https://colinder.github.io/django_05_check-db-connection/</link>
    <pubDate>Mon, 06 Sep 2021 11:29:11 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/django_05_check-db-connection/</guid>
    <description><![CDATA[​
Django DB 연결 확인 ​
python manage.py createsuperuser 후.. default로 생기는 DB를 기준으로 실행
​
1 2  ## setting.py AUTH_USER_MODEL = &#39;auth.User&#39; # default 설정.   ​
이후 terminal에서
1 2 3 4 5 6 7  $ python manage.py shell_plus	# 모델에 접근하기 위해 shell_plus 실행 &gt; Post = get_user_model()	# 생성된 모델의 user table 불러오기 &gt; post = Post.objects.all()	# user table의 모든 값 가져오기 &gt; for i in post:	# for문으로 user table값 순환 &gt; print(i)	# user table 값 출력   하면 연결된 모델의 값을 확인할 수 있다.]]></description>
</item><item>
    <title>정적(Static) 링크 Vs 동적(Dynamic) 링크</title>
    <link>https://colinder.github.io/staticvsdynamic_link/</link>
    <pubDate>Mon, 06 Sep 2021 10:10:24 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/staticvsdynamic_link/</guid>
    <description><![CDATA[​
정적(Static) 링크 Vs 동적(Dynamic) 링크 ​
정적(Static) 링크 란?  link 단계에서 라이브러리(*.lib 파일)을 실행 바이너리(컴퓨터가 이해할 수 있는 문법으로 만들어진 결과물)에 포함한다는 의미
 *.lib 파일이란? &gt; Library 파일, 개발 코드에서 반복되는 기능들을 모아둔 파일
  ex) *.exe 파일
  라이브러리 관련 수정사항이 생기면 파일 전체를 다시 컴파일하여 재배포해야 한다.
​
​
  동적(Dynamic) 링크 란?  특정 기능을 사용하고자 하는 실행 바이너리에서 필요시 사용할 수 있도록 최소한의 정보만 포함하여 링크하거나, 독립적으로 dll을 로드/사용/해제 시킨다는 의미.]]></description>
</item><item>
    <title>License 배포 시 소스코드 제공 의무와 범위</title>
    <link>https://colinder.github.io/01_dutis_and_scope_at_deployment/</link>
    <pubDate>Thu, 02 Sep 2021 16:37:00 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/01_dutis_and_scope_at_deployment/</guid>
    <description><![CDATA[​
License 배포 시 소스코드 제공 의무와 범위  License에 대하여 알아보다보니, 배포 시 준수해야 하는 내용이 별도로 존재하고 있어 오픈소스 SW라이선스 종합정보시스템에서 발최한 내용을 추가로 정리합니다.
 ​
​
- Work Based on the Code -제공의무: 원 저작물의 소스코드를 원본 그대로, 혹은 수정하여 새로운 SW에 포함하였을 경우 -제공범위: 원 저작물의 소스코드가 포함되어, 파생 저작물로 인정되는 범위내의 모든 소스코드 -GNU GPL, GNU AGPL 등
​
- Derivative Work -제공의무: 원 저작물의 소스코드를 수정하여 사용한 경우 제공의무가 존재하며, 수정 없이 그대로 사용하였을 경우에는 소스코드를 제공하지 않아도 됨 -제공범위: 원 저작물을 사용함에 있어 수정을 거쳤다면, 원 저작물의 소스코드에서부터 존재하던 파일을 모두 공개해야 하며, 파생 저작물의 저작자가 추가적으로 생성한 부분에 대해서는 공개하지 않아도 됨 -GNU LGPL, NASA Open Source Agreement, Simple Public License 등]]></description>
</item><item>
    <title>Software License</title>
    <link>https://colinder.github.io/00_license/</link>
    <pubDate>Thu, 02 Sep 2021 09:54:00 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/00_license/</guid>
    <description><![CDATA[​
License  실무를 담당하고 있다면, 새로운 프로젝트에 앞서 어떤 기술을 사용할 것인지 조사하는 것도 업무중의 하나입니다.
근데 항상 고민이 되는 부분. 비용과 권한
그리고 비용과 권한 정리되어 있는 것이 License
 ​
한국저작권위원회의 OLIS(오픈소스SW 라이선스 종합정보시스템)에는 라이선스에 대한 내용이 잘 정리 되어 있습니다. 많은 라이선스들이 있지만,
접해본 라이선스 위주로, 개발을 위해 중요하게 보았던 부분을 정리합니다.
​
​
1. MIT License  아마 가장 흔하게 접하는 라이선스일 것입니다.
&ldquo;MIT 라이선스(MIT License)는 미국 매사추세츠 공과대학교(MIT)에서 해당 대학의 소프트웨어 공학도들을 돕기 위해 개발한 라이선스다.]]></description>
</item><item>
    <title>Vue_DevInfo</title>
    <link>https://colinder.github.io/vue_devinfo/</link>
    <pubDate>Sun, 08 Aug 2021 14:09:22 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/vue_devinfo/</guid>
    <description><![CDATA[​
Vue Dev_Info  Vue 개발을 하면서 알게 된(깨닫게 된) 내용을 정리해 기록합니다.
 ​
1. Vuex 동작에 대한 고찰  개인적으로 DB의 자료를 가져오는데 5개 이상의 테이블에서 DB를 가져오고, 이를 종합해 새로운 리스트 혹은 데이터를 만들어야 한다면 무조건 vuex의 사용을 추천합니다. 다만, vuex를 사용하는데 일반적으로 알려진 단계를 지켜야 하는 이유와 방법에 대하여 정리합니다.
  위의 그래프를 보면 .vue 파일에서 .dispatch()를 사용에 vuex의 store.js에 등록된 actions의 함수를 동작하는 신호를 보냅니다.]]></description>
</item><item>
    <title>Oracle 18C_network_connect</title>
    <link>https://colinder.github.io/oracle_network_connect/</link>
    <pubDate>Tue, 06 Jul 2021 14:17:20 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/oracle_network_connect/</guid>
    <description><![CDATA[​
오라클 18C_외부DB 접근(네트워크 연동) 방법  오라클 18 버전의 외부 DB 접근(네트워크 연동) 방법에 대하여 정리합니다.
제가 네트워크 연동을 기획하면서 두 가지 관점으로 생각했습니다.
첫째, DB를 가진 host가 있을 것이고
둘째, DB에 연결할 guest가 있을 것이다.
그렇다면, host가 guest의 IP를 등록해놓으면 guest가 접근하면 DB가 연결되는 걸까?
guest가 host의 IP를 입력해 DB를 연결하는 걸까?
아래 내용은 위의 두 가지를 다 진행하여 연결하였습니다. 
 ​
👀주의
각 단계 단계들이 필수적인 사항인지는 파악되지 않았습니다.]]></description>
</item></channel>
</rss>
