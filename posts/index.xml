<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - </title>
        <link>https://colinder.github.io/posts/</link>
        <description>All Posts | </description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 25 Oct 2022 12:38:54 &#43;0900</lastBuildDate><atom:link href="https://colinder.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>What is Sequence_data &amp; apply AI</title>
    <link>https://colinder.github.io/what_is_sequence_data/</link>
    <pubDate>Tue, 25 Oct 2022 12:38:54 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/what_is_sequence_data/</guid>
    <description><![CDATA[​
Sequence data 자연에는 사건이 발생하는데, 이는 대부분 시간에 따른 원인에 의한 결과로써 발생하게 된다. 예를들어
  오전에는 맑았는데 오후에는 흐리다.
  상반기에는 잘 팔렸는데, 하반기에는 잘 안팔린다.
  기분이 나빴는데, 좋아졌다. 등등
   순서(sequence)대로 하나씩 나열하여 나타낼 수 있는 데이터를 Sequence data라고 한다.
그리고 이 데이터들은 서로 독립적이지 않다.는 특징을 가지고 있다. 원인과 결과가 무한이 이어져있다.
  ​
​
Sequence data의 구조와 주로 활용되는 형태 많은 사람들이 시도해보는 주식 예측 인공지능 개발을 가정하여 설명.]]></description>
</item><item>
    <title>Machine_learning type</title>
    <link>https://colinder.github.io/machine_learning_classification/</link>
    <pubDate>Wed, 10 Aug 2022 14:07:57 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/machine_learning_classification/</guid>
    <description><![CDATA[​
Machine learning (ML)  머신러닝을 활용하기에 좋은 분야에 대하여 알아보겠습니다.
 ​
  분류(classification)
 정해진 카테고리 중 어디에 속하는지 알아내는 경우
   종류
  KNN(k-nearest neighbor)
 k-nearest neighbor는 데이터를 분류하고 새로운 데이터 포인트의 카테고리를 결정할 때 K 개의 가장 가까운 포인트를 선점하고 그중 가장 많이 선택된 포인트의 카테고리로 이 새로운 데이터를 분류하는 방법이다.
 중요 개념
  좌표와 같이 데이터의 위치를 특정할 수 있게 변환]]></description>
</item><item>
    <title>AI학습 때 왜 .fit() 한 뒤에 train, test data를 .transform()할까?</title>
    <link>https://colinder.github.io/why_transform_after_fit/</link>
    <pubDate>Fri, 08 Jul 2022 14:50:36 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/why_transform_after_fit/</guid>
    <description><![CDATA[​
🤔 왜 .fit() 한 뒤에 train, test data를 .transform()할까?  결론은 .fit()을 통해 학습데이터(train)의 경향을 파악 및 저장하고 이 경향을 train, test data를 적용해 조정해주기 위함입니다.
  minmaxScaler를 대표로 .fit()한 결과를 출력해보면  .fit()이 어떤 역할을 하는지 알 수 없습니다. 그냥 MinMaxScaler()라는 객체가 할당된 것만 알 수 있습니다.
공식문서를 살펴보면
 fit(X, y=None)
Compute the minimum and maximum to be used for later scaling.
 * StandardScale()의 경우 Compute the mean and std to be used for later scaling.]]></description>
</item><item>
    <title>What is Data_Scaling</title>
    <link>https://colinder.github.io/what_is_data_scaling/</link>
    <pubDate>Thu, 07 Jul 2022 17:19:29 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/what_is_data_scaling/</guid>
    <description><![CDATA[​
데이터 스케일링(Data Scaling) 이란?  데이터의 값의 범위를 조정하는 것
 ​
​
​
🤔 왜 데이터 스케일링을 하는가?  데이터의 경향, feature의 영향, 상관관계 등 데이터를 분석하는데 활용할 수 있으며, 인공지능 개발 중 학습단계에서 여러 feature의 영향도를 비슷한 수준으로 맞추기 위해 범위를 조정.
 ​
아래 그림을 보면서 이해해보겠습니다.
과제  여러 feature(성별, 나이, 몸무게, 자산현황)의 특성을 보고 Label을 예측하는 모델을 만든다고 가정  문제점  값의 범위를 보면  성별 0, 1 나이 0~100, 몸무게 0~120, 자산현황 0~700,000,000, Label은 0~800,000,000의 값을 갖는다고 가정한다면,    ​]]></description>
</item><item>
    <title>What is train_test_split()?</title>
    <link>https://colinder.github.io/what_is_train_test_split/</link>
    <pubDate>Thu, 30 Jun 2022 13:30:53 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/what_is_train_test_split/</guid>
    <description><![CDATA[​
What is &lsquo;train_test_split()&rsquo;?  AI 모델링을 위해 X_train, X_test, y_train, y_test로 나누는 작업은 필수적입니다. 저는 train과 test를 나누는 코드를 직접 짜서 사용했었는데 scikit learn에서 제공되는 함수가 있었습니다. &ldquo;train_test_split()&quot;이를 알아보겠습니다.
 ​
​
직접 사용되는 모습을 보며 이해해보겠습니다.
1 2 3 4  import numpy as np from sklearn.model_selection import train_test_split X_train, X_test, y_train, y_test = train_test_split(data, label, test_size=0.3, random_state=29)   ​
​
train_test_split() 함수안에 사용되는 인자에 대하여 하나씩 알아보겠습니다.]]></description>
</item><item>
    <title>React-Native_icon_and_splash</title>
    <link>https://colinder.github.io/react-native_icon_and_splash/</link>
    <pubDate>Thu, 23 Jun 2022 14:01:21 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/react-native_icon_and_splash/</guid>
    <description><![CDATA[​
React-native (android)  icon 변경과 splash를 적용해보겠습니다.
 icon: 핸드폰에서 어플 접속시 보이는 모습을 의미.
splash: 어플 실행시 잠시 노출되는 화면을 의미.​
​
Icon 변경 방법  결론부터 정리하자면 특정 폴더안에 이미지만 넣으면 됩니다.
 ​
*프로젝트를 시작할 때 이름을 test로 만들어 진행하였습니다. (버전은 0.67)
1  npx react-native init test --version 0.67.0   ​
1. android/app/src/main/res 까지 폴더를 들어갑니다. 이미지와 같은 구조가 보인다면 잘 접근한 것입니다.]]></description>
</item><item>
    <title>Selenium 동작 대기 방법</title>
    <link>https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/</link>
    <pubDate>Tue, 17 May 2022 15:50:42 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/selenium_%EB%8F%99%EC%9E%91%EB%8C%80%EA%B8%B0/</guid>
    <description><![CDATA[​
Selenium 동작대기 접근하려는 요소가 존재하지 않을 때 발생하는 NoSuchElementException error. 페이지와 서버가 통신중이거나 네트워크 지연 등으로 위의 크롤링을 원하는 요소가 html에 존재하기 전에 요소에 접근을 시도하기 때문에 발생하는 에러입니다.
어떤 멋진 코드로 이를 해결할 수 있을까? 고민하였지만 조금 무식한? 방법인 시간 지연으로 이를 해결하였습니다.
​
​
1. time.sleep  python 내장 library 지정한 시간만큼 지연 (프로세스 자체를 지정한 시간동안 기다림)  사용법 1 2 3  from time import sleep sleep(3) //3초간 기다림   ​]]></description>
</item><item>
    <title>Epoch</title>
    <link>https://colinder.github.io/epoch/</link>
    <pubDate>Fri, 18 Mar 2022 14:15:59 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/epoch/</guid>
    <description><![CDATA[​
Epoch의 의미 1~100의 데이터가 input의 양(x_train)으로 주어졌을 때
20 epoch를 적용한다는 의미는
단계별로 설명하자면,
  1번째 학습(1 epoch) 시작
  초기화된 가중치(w)와 편향(b)을 가지고 1에 대한 계산 진행 &gt;
  1을 대입하여 나온 가중치(w) 와 편향(b) 도출
  2에게 1을 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출
  3에게 2를 대입하여 나온 가중치(w) 와 편향(b)을 대입하여 새로운 가중치(w)와 편향(b)가 도출
  &hellip;]]></description>
</item><item>
    <title>what is optimizer</title>
    <link>https://colinder.github.io/what_is_optimizer/</link>
    <pubDate>Fri, 18 Mar 2022 14:13:56 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/what_is_optimizer/</guid>
    <description><![CDATA[​
​
​
옵티마이저의 목적  옵티마이저는 학습 데이터(Train data)셋을 이용하여 모델을 학습 할 때 데이터의 실제 결과와 모델이 예측한 결과를 기반으로 오차를 잘 줄일 수 있게 만들어주는 역할입니다.
 ​
따라서 최적화(Optimization)은 손실 함수(Loss Function)의 결과값을 최소화하는 모델의 파라미터(가중치)를 찾는 것을 의미합니다.
​
​
​
옵티마이저 리스트  경사 하강법(Gradient Descent) 확률적 경사 하강법(Stochastic Gradient Descent, SGD) Momentum Nesterov Accelerated Gradient (NAG) Adam AdaGrad RMSProp AdaMax Nadam  참고 https://keras.]]></description>
</item><item>
    <title>what is Linter?</title>
    <link>https://colinder.github.io/what_is_linter/</link>
    <pubDate>Fri, 18 Mar 2022 13:28:48 &#43;0900</pubDate>
    <author>Author</author>
    <guid>https://colinder.github.io/what_is_linter/</guid>
    <description><![CDATA[​
Linter란?  Linter 혹은 Lint는 소스 코드를 분석해 오류나 오타, 잠재적인 버그를 찾아주는 도구입니다.
javascript는 다른 언어들에 비해 유연한 문법 구조를 갖습니다. 이런 특징은 찾기 어려운 버그를 만들기도하고, 코드를 실행하기 전까지 알 수 없는 오류를 만들기도 합니다.
Lint를 사용하면 검증을 자동화하여 이런 문제를 예방할 수 있습니다. 가장 많이 사용되는 javascript 린터로는 ESLint와 코드 포맷터인 Prettier, css 린터인 Stylelint가 있습니다.
 ​
​
ESLint 2002년 JSON을 만든 더글라스 크락포드가 자바스크립트 린터인 JSLint를 만들었습니다.]]></description>
</item></channel>
</rss>
